//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g 2014-10-06 20:43:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class VhdlAntlrLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ABS=4;
	public const int ACCESS=5;
	public const int AFTER=6;
	public const int AGGREGATE=7;
	public const int ALIAS=8;
	public const int ALL=9;
	public const int AMPERSAND=10;
	public const int AND=11;
	public const int APOSTROPHE=12;
	public const int ARCHITECTURE=13;
	public const int ARRAY=14;
	public const int ARROW=15;
	public const int ASSERT=16;
	public const int ASSOCIATION_LIST=17;
	public const int ATTRIBUTE=18;
	public const int ATTRIBUTE_DECLARATION=19;
	public const int ATTRIBUTE_SPECIFICATION=20;
	public const int BACKSLASH=21;
	public const int BAR=22;
	public const int BASED_LITERAL=23;
	public const int BASIC_IDENTIFIER=24;
	public const int BEGIN=25;
	public const int BINANRY_BASED_INTEGER=26;
	public const int BINDING_INDICATION=27;
	public const int BIT_STRING_LITERAL_BINARY=28;
	public const int BIT_STRING_LITERAL_HEX=29;
	public const int BIT_STRING_LITERAL_OCTAL=30;
	public const int BLOCK=31;
	public const int BLOCK_CONFIGURATION=32;
	public const int BLOCK_STATEMENT=33;
	public const int BODY=34;
	public const int BOX=35;
	public const int BUFFER=36;
	public const int BUS=37;
	public const int CASE=38;
	public const int CHARACTER_LITERAL=39;
	public const int CHOICES=40;
	public const int COLON=41;
	public const int COMMA=42;
	public const int COMMENT=43;
	public const int COMPONENT=44;
	public const int COMPONENT_CONFIGURATION=45;
	public const int COMPONENT_INSTANCE=46;
	public const int COMPONENT_INSTANTIATION_STATEMENT=47;
	public const int CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT=48;
	public const int CONDITIONAL_WAVEFORMS=49;
	public const int CONFIGURATION=50;
	public const int CONFIGURATION_SPECIFICATION=51;
	public const int CONSTANT=52;
	public const int CONSTRAINED_ARRAY_DEFINITION=53;
	public const int DBLQUOTE=54;
	public const int DEC_BASED_INTEGER=55;
	public const int DIGIT=56;
	public const int DISCONNECT=57;
	public const int DISCRETE_RANGE=58;
	public const int DIV=59;
	public const int DOT=60;
	public const int DOUBLESTAR=61;
	public const int DOWNTO=62;
	public const int ELSE=63;
	public const int ELSIF=64;
	public const int END=65;
	public const int ENTITY=66;
	public const int ENTITY_STATEMENT=67;
	public const int ENUMERATION_TYPE_DEFINITION=68;
	public const int EQ=69;
	public const int EXCLAMATION=70;
	public const int EXIT=71;
	public const int EXPONENT=72;
	public const int EXPRESSION=73;
	public const int EXTENDED_IDENTIFIER=74;
	public const int FILE=75;
	public const int FILE_TYPE_DEFINITION=76;
	public const int FLOAT_POINT_LITERAL=77;
	public const int FOR=78;
	public const int FULL_TYPE_DECLARATION=79;
	public const int FUNCTION=80;
	public const int GE=81;
	public const int GENERATE=82;
	public const int GENERIC=83;
	public const int GENERIC_MAP=84;
	public const int GRAPHIC_CHARACTER=85;
	public const int GROUP=86;
	public const int GROUP_DECLARATION=87;
	public const int GROUP_TEMPLATE_DECLARATION=88;
	public const int GT=89;
	public const int GUARDED=90;
	public const int HEXA_BASED_INTEGER=91;
	public const int IF=92;
	public const int IMPURE=93;
	public const int IN=94;
	public const int INCOMPLETE_TYPE_DECLARATION=95;
	public const int INDEX_CONSTRAINT=96;
	public const int INERTIAL=97;
	public const int INOUT=98;
	public const int INSTANTIATION_LIST=99;
	public const int INTEGER_OR_FLOAT_TYPE_DEFINITION=100;
	public const int INTERFACE_CONSTANT_DECLARATION=101;
	public const int INTERFACE_FILE_DECLARATION=102;
	public const int INTERFACE_SIGNAL_DECLARATION=103;
	public const int INTERFACE_VARIABLE_DECLARATION=104;
	public const int IS=105;
	public const int LABEL=106;
	public const int LABEL_STATEMENT=107;
	public const int LBRACKET=108;
	public const int LE=109;
	public const int LETTER=110;
	public const int LETTER_OR_DIGIT=111;
	public const int LIBRARY=112;
	public const int LINKAGE=113;
	public const int LITERAL=114;
	public const int LOOP=115;
	public const int LOWER_CASE_LETTER=116;
	public const int LPAREN=117;
	public const int LT=118;
	public const int MAP=119;
	public const int MINUS=120;
	public const int MOD=121;
	public const int MUL=122;
	public const int NAME=123;
	public const int NAME_ATTRIBUTE_PART=124;
	public const int NAME_INDEXED_OR_SLICE_PART=125;
	public const int NAME_INDEXED_PART=126;
	public const int NAME_SELECTED_PART=127;
	public const int NAME_SLICE_PART=128;
	public const int NAND=129;
	public const int NEQ=130;
	public const int NEW=131;
	public const int NEXT=132;
	public const int NOR=133;
	public const int NOT=134;
	public const int NULLTOK=135;
	public const int OCTAL_BASED_INTEGER=136;
	public const int OF=137;
	public const int ON=138;
	public const int OPEN=139;
	public const int OR=140;
	public const int OTHERS=141;
	public const int OTHER_SPECIAL_CHARACTER=142;
	public const int OUT=143;
	public const int PACKAGE=144;
	public const int PACKAGE_BODY=145;
	public const int PHYSICAL_LITERAL=146;
	public const int PHYSICAL_TYPE_DEFINITION=147;
	public const int PLUS=148;
	public const int PORT=149;
	public const int PORT_MAP=150;
	public const int POSTPONED=151;
	public const int PROCEDURE=152;
	public const int PROCEDURE_CALL=153;
	public const int PROCESS=154;
	public const int PURE=155;
	public const int QUALIFIED_EXPRESSION=156;
	public const int RANGETOK=157;
	public const int RBRACKET=158;
	public const int RECORD=159;
	public const int RECORD_TYPE_DEFINITION=160;
	public const int REGISTER=161;
	public const int REJECT=162;
	public const int REM=163;
	public const int REPORT=164;
	public const int RESOLVED=165;
	public const int RETURN=166;
	public const int ROL=167;
	public const int ROR=168;
	public const int RPAREN=169;
	public const int SELECT=170;
	public const int SELECTED_SIGNAL_ASSIGNMENT_STATEMENT=171;
	public const int SEMI=172;
	public const int SEVERITY=173;
	public const int SHARED=174;
	public const int SIGNAL=175;
	public const int SIGNAL_ASSIGNMENT_STATEMENT=176;
	public const int SIGNAL_LIST=177;
	public const int SIGNATURE=178;
	public const int SLA=179;
	public const int SLL=180;
	public const int SPACE_CHARACTER=181;
	public const int SPECIAL_CHARACTER=182;
	public const int SRA=183;
	public const int SRL=184;
	public const int STRING_LITERAL=185;
	public const int SUBPROGRAM_BODY=186;
	public const int SUBPROGRAM_DECLARATION=187;
	public const int SUBTYPE=188;
	public const int SUBTYPE_INDICATION=189;
	public const int THEN=190;
	public const int TO=191;
	public const int TRANSPORT=192;
	public const int TYPE=193;
	public const int UNAFFECTED=194;
	public const int UNCONDITIONAL_LOOP=195;
	public const int UNCONSTRAINED_ARRAY_DEFINITION=196;
	public const int UNITS=197;
	public const int UNTIL=198;
	public const int UPPER_CASE_LETTER=199;
	public const int USE=200;
	public const int VARASGN=201;
	public const int VARIABLE=202;
	public const int VARIABLE_ASSIGNMENT_STATEMENT=203;
	public const int WAIT=204;
	public const int WAVEFORM=205;
	public const int WAVEFORM_ELEMENT=206;
	public const int WHEN=207;
	public const int WHILE=208;
	public const int WHITESPACE=209;
	public const int WITH=210;
	public const int XNOR=211;
	public const int XOR=212;

	    public const int CHANNEL_COMMENT = 80;


    // delegates
    // delegators

	public VhdlAntlrLexer()
	{
		OnCreated();
	}

	public VhdlAntlrLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public VhdlAntlrLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_ABS();
	partial void LeaveRule_ABS();

	// $ANTLR start "ABS"
	[GrammarRule("ABS")]
	private void mABS()
	{
		EnterRule_ABS();
		EnterRule("ABS", 1);
		TraceIn("ABS", 1);
		try
		{
			int _type = ABS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:11:5: ( 'abs' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:11:7: 'abs'
			{
			DebugLocation(11, 7);
			Match("abs"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ABS", 1);
			LeaveRule("ABS", 1);
			LeaveRule_ABS();
		}
	}
	// $ANTLR end "ABS"

	partial void EnterRule_ACCESS();
	partial void LeaveRule_ACCESS();

	// $ANTLR start "ACCESS"
	[GrammarRule("ACCESS")]
	private void mACCESS()
	{
		EnterRule_ACCESS();
		EnterRule("ACCESS", 2);
		TraceIn("ACCESS", 2);
		try
		{
			int _type = ACCESS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:12:8: ( 'access' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:12:10: 'access'
			{
			DebugLocation(12, 10);
			Match("access"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ACCESS", 2);
			LeaveRule("ACCESS", 2);
			LeaveRule_ACCESS();
		}
	}
	// $ANTLR end "ACCESS"

	partial void EnterRule_AFTER();
	partial void LeaveRule_AFTER();

	// $ANTLR start "AFTER"
	[GrammarRule("AFTER")]
	private void mAFTER()
	{
		EnterRule_AFTER();
		EnterRule("AFTER", 3);
		TraceIn("AFTER", 3);
		try
		{
			int _type = AFTER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:13:7: ( 'after' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:13:9: 'after'
			{
			DebugLocation(13, 9);
			Match("after"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AFTER", 3);
			LeaveRule("AFTER", 3);
			LeaveRule_AFTER();
		}
	}
	// $ANTLR end "AFTER"

	partial void EnterRule_ALIAS();
	partial void LeaveRule_ALIAS();

	// $ANTLR start "ALIAS"
	[GrammarRule("ALIAS")]
	private void mALIAS()
	{
		EnterRule_ALIAS();
		EnterRule("ALIAS", 4);
		TraceIn("ALIAS", 4);
		try
		{
			int _type = ALIAS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:14:7: ( 'alias' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:14:9: 'alias'
			{
			DebugLocation(14, 9);
			Match("alias"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ALIAS", 4);
			LeaveRule("ALIAS", 4);
			LeaveRule_ALIAS();
		}
	}
	// $ANTLR end "ALIAS"

	partial void EnterRule_ALL();
	partial void LeaveRule_ALL();

	// $ANTLR start "ALL"
	[GrammarRule("ALL")]
	private void mALL()
	{
		EnterRule_ALL();
		EnterRule("ALL", 5);
		TraceIn("ALL", 5);
		try
		{
			int _type = ALL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:15:5: ( 'all' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:15:7: 'all'
			{
			DebugLocation(15, 7);
			Match("all"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ALL", 5);
			LeaveRule("ALL", 5);
			LeaveRule_ALL();
		}
	}
	// $ANTLR end "ALL"

	partial void EnterRule_AMPERSAND();
	partial void LeaveRule_AMPERSAND();

	// $ANTLR start "AMPERSAND"
	[GrammarRule("AMPERSAND")]
	private void mAMPERSAND()
	{
		EnterRule_AMPERSAND();
		EnterRule("AMPERSAND", 6);
		TraceIn("AMPERSAND", 6);
		try
		{
			int _type = AMPERSAND;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:16:11: ( '&' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:16:13: '&'
			{
			DebugLocation(16, 13);
			Match('&'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AMPERSAND", 6);
			LeaveRule("AMPERSAND", 6);
			LeaveRule_AMPERSAND();
		}
	}
	// $ANTLR end "AMPERSAND"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 7);
		TraceIn("AND", 7);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:17:5: ( 'and' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:17:7: 'and'
			{
			DebugLocation(17, 7);
			Match("and"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 7);
			LeaveRule("AND", 7);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_ARCHITECTURE();
	partial void LeaveRule_ARCHITECTURE();

	// $ANTLR start "ARCHITECTURE"
	[GrammarRule("ARCHITECTURE")]
	private void mARCHITECTURE()
	{
		EnterRule_ARCHITECTURE();
		EnterRule("ARCHITECTURE", 8);
		TraceIn("ARCHITECTURE", 8);
		try
		{
			int _type = ARCHITECTURE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:18:14: ( 'architecture' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:18:16: 'architecture'
			{
			DebugLocation(18, 16);
			Match("architecture"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ARCHITECTURE", 8);
			LeaveRule("ARCHITECTURE", 8);
			LeaveRule_ARCHITECTURE();
		}
	}
	// $ANTLR end "ARCHITECTURE"

	partial void EnterRule_ARRAY();
	partial void LeaveRule_ARRAY();

	// $ANTLR start "ARRAY"
	[GrammarRule("ARRAY")]
	private void mARRAY()
	{
		EnterRule_ARRAY();
		EnterRule("ARRAY", 9);
		TraceIn("ARRAY", 9);
		try
		{
			int _type = ARRAY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:19:7: ( 'array' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:19:9: 'array'
			{
			DebugLocation(19, 9);
			Match("array"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ARRAY", 9);
			LeaveRule("ARRAY", 9);
			LeaveRule_ARRAY();
		}
	}
	// $ANTLR end "ARRAY"

	partial void EnterRule_ARROW();
	partial void LeaveRule_ARROW();

	// $ANTLR start "ARROW"
	[GrammarRule("ARROW")]
	private void mARROW()
	{
		EnterRule_ARROW();
		EnterRule("ARROW", 10);
		TraceIn("ARROW", 10);
		try
		{
			int _type = ARROW;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:20:7: ( '=>' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:20:9: '=>'
			{
			DebugLocation(20, 9);
			Match("=>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ARROW", 10);
			LeaveRule("ARROW", 10);
			LeaveRule_ARROW();
		}
	}
	// $ANTLR end "ARROW"

	partial void EnterRule_ASSERT();
	partial void LeaveRule_ASSERT();

	// $ANTLR start "ASSERT"
	[GrammarRule("ASSERT")]
	private void mASSERT()
	{
		EnterRule_ASSERT();
		EnterRule("ASSERT", 11);
		TraceIn("ASSERT", 11);
		try
		{
			int _type = ASSERT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:21:8: ( 'assert' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:21:10: 'assert'
			{
			DebugLocation(21, 10);
			Match("assert"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSERT", 11);
			LeaveRule("ASSERT", 11);
			LeaveRule_ASSERT();
		}
	}
	// $ANTLR end "ASSERT"

	partial void EnterRule_ATTRIBUTE();
	partial void LeaveRule_ATTRIBUTE();

	// $ANTLR start "ATTRIBUTE"
	[GrammarRule("ATTRIBUTE")]
	private void mATTRIBUTE()
	{
		EnterRule_ATTRIBUTE();
		EnterRule("ATTRIBUTE", 12);
		TraceIn("ATTRIBUTE", 12);
		try
		{
			int _type = ATTRIBUTE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:22:11: ( 'attribute' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:22:13: 'attribute'
			{
			DebugLocation(22, 13);
			Match("attribute"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ATTRIBUTE", 12);
			LeaveRule("ATTRIBUTE", 12);
			LeaveRule_ATTRIBUTE();
		}
	}
	// $ANTLR end "ATTRIBUTE"

	partial void EnterRule_BACKSLASH();
	partial void LeaveRule_BACKSLASH();

	// $ANTLR start "BACKSLASH"
	[GrammarRule("BACKSLASH")]
	private void mBACKSLASH()
	{
		EnterRule_BACKSLASH();
		EnterRule("BACKSLASH", 13);
		TraceIn("BACKSLASH", 13);
		try
		{
			int _type = BACKSLASH;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:23:11: ( '\\\\' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:23:13: '\\\\'
			{
			DebugLocation(23, 13);
			Match('\\'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BACKSLASH", 13);
			LeaveRule("BACKSLASH", 13);
			LeaveRule_BACKSLASH();
		}
	}
	// $ANTLR end "BACKSLASH"

	partial void EnterRule_BAR();
	partial void LeaveRule_BAR();

	// $ANTLR start "BAR"
	[GrammarRule("BAR")]
	private void mBAR()
	{
		EnterRule_BAR();
		EnterRule("BAR", 14);
		TraceIn("BAR", 14);
		try
		{
			int _type = BAR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:24:5: ( '|' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:24:7: '|'
			{
			DebugLocation(24, 7);
			Match('|'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BAR", 14);
			LeaveRule("BAR", 14);
			LeaveRule_BAR();
		}
	}
	// $ANTLR end "BAR"

	partial void EnterRule_BEGIN();
	partial void LeaveRule_BEGIN();

	// $ANTLR start "BEGIN"
	[GrammarRule("BEGIN")]
	private void mBEGIN()
	{
		EnterRule_BEGIN();
		EnterRule("BEGIN", 15);
		TraceIn("BEGIN", 15);
		try
		{
			int _type = BEGIN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:25:7: ( 'begin' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:25:9: 'begin'
			{
			DebugLocation(25, 9);
			Match("begin"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BEGIN", 15);
			LeaveRule("BEGIN", 15);
			LeaveRule_BEGIN();
		}
	}
	// $ANTLR end "BEGIN"

	partial void EnterRule_BLOCK();
	partial void LeaveRule_BLOCK();

	// $ANTLR start "BLOCK"
	[GrammarRule("BLOCK")]
	private void mBLOCK()
	{
		EnterRule_BLOCK();
		EnterRule("BLOCK", 16);
		TraceIn("BLOCK", 16);
		try
		{
			int _type = BLOCK;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:26:7: ( 'block' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:26:9: 'block'
			{
			DebugLocation(26, 9);
			Match("block"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BLOCK", 16);
			LeaveRule("BLOCK", 16);
			LeaveRule_BLOCK();
		}
	}
	// $ANTLR end "BLOCK"

	partial void EnterRule_BODY();
	partial void LeaveRule_BODY();

	// $ANTLR start "BODY"
	[GrammarRule("BODY")]
	private void mBODY()
	{
		EnterRule_BODY();
		EnterRule("BODY", 17);
		TraceIn("BODY", 17);
		try
		{
			int _type = BODY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:27:6: ( 'body' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:27:8: 'body'
			{
			DebugLocation(27, 8);
			Match("body"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BODY", 17);
			LeaveRule("BODY", 17);
			LeaveRule_BODY();
		}
	}
	// $ANTLR end "BODY"

	partial void EnterRule_BOX();
	partial void LeaveRule_BOX();

	// $ANTLR start "BOX"
	[GrammarRule("BOX")]
	private void mBOX()
	{
		EnterRule_BOX();
		EnterRule("BOX", 18);
		TraceIn("BOX", 18);
		try
		{
			int _type = BOX;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:28:5: ( '<>' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:28:7: '<>'
			{
			DebugLocation(28, 7);
			Match("<>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOX", 18);
			LeaveRule("BOX", 18);
			LeaveRule_BOX();
		}
	}
	// $ANTLR end "BOX"

	partial void EnterRule_BUFFER();
	partial void LeaveRule_BUFFER();

	// $ANTLR start "BUFFER"
	[GrammarRule("BUFFER")]
	private void mBUFFER()
	{
		EnterRule_BUFFER();
		EnterRule("BUFFER", 19);
		TraceIn("BUFFER", 19);
		try
		{
			int _type = BUFFER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:29:8: ( 'buffer' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:29:10: 'buffer'
			{
			DebugLocation(29, 10);
			Match("buffer"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BUFFER", 19);
			LeaveRule("BUFFER", 19);
			LeaveRule_BUFFER();
		}
	}
	// $ANTLR end "BUFFER"

	partial void EnterRule_BUS();
	partial void LeaveRule_BUS();

	// $ANTLR start "BUS"
	[GrammarRule("BUS")]
	private void mBUS()
	{
		EnterRule_BUS();
		EnterRule("BUS", 20);
		TraceIn("BUS", 20);
		try
		{
			int _type = BUS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:30:5: ( 'bus' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:30:7: 'bus'
			{
			DebugLocation(30, 7);
			Match("bus"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BUS", 20);
			LeaveRule("BUS", 20);
			LeaveRule_BUS();
		}
	}
	// $ANTLR end "BUS"

	partial void EnterRule_CASE();
	partial void LeaveRule_CASE();

	// $ANTLR start "CASE"
	[GrammarRule("CASE")]
	private void mCASE()
	{
		EnterRule_CASE();
		EnterRule("CASE", 21);
		TraceIn("CASE", 21);
		try
		{
			int _type = CASE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:31:6: ( 'case' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:31:8: 'case'
			{
			DebugLocation(31, 8);
			Match("case"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CASE", 21);
			LeaveRule("CASE", 21);
			LeaveRule_CASE();
		}
	}
	// $ANTLR end "CASE"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 22);
		TraceIn("COLON", 22);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:32:7: ( ':' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:32:9: ':'
			{
			DebugLocation(32, 9);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 22);
			LeaveRule("COLON", 22);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 23);
		TraceIn("COMMA", 23);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:33:7: ( ',' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:33:9: ','
			{
			DebugLocation(33, 9);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 23);
			LeaveRule("COMMA", 23);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_COMPONENT();
	partial void LeaveRule_COMPONENT();

	// $ANTLR start "COMPONENT"
	[GrammarRule("COMPONENT")]
	private void mCOMPONENT()
	{
		EnterRule_COMPONENT();
		EnterRule("COMPONENT", 24);
		TraceIn("COMPONENT", 24);
		try
		{
			int _type = COMPONENT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:34:11: ( 'component' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:34:13: 'component'
			{
			DebugLocation(34, 13);
			Match("component"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMPONENT", 24);
			LeaveRule("COMPONENT", 24);
			LeaveRule_COMPONENT();
		}
	}
	// $ANTLR end "COMPONENT"

	partial void EnterRule_CONFIGURATION();
	partial void LeaveRule_CONFIGURATION();

	// $ANTLR start "CONFIGURATION"
	[GrammarRule("CONFIGURATION")]
	private void mCONFIGURATION()
	{
		EnterRule_CONFIGURATION();
		EnterRule("CONFIGURATION", 25);
		TraceIn("CONFIGURATION", 25);
		try
		{
			int _type = CONFIGURATION;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:35:15: ( 'configuration' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:35:17: 'configuration'
			{
			DebugLocation(35, 17);
			Match("configuration"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONFIGURATION", 25);
			LeaveRule("CONFIGURATION", 25);
			LeaveRule_CONFIGURATION();
		}
	}
	// $ANTLR end "CONFIGURATION"

	partial void EnterRule_CONSTANT();
	partial void LeaveRule_CONSTANT();

	// $ANTLR start "CONSTANT"
	[GrammarRule("CONSTANT")]
	private void mCONSTANT()
	{
		EnterRule_CONSTANT();
		EnterRule("CONSTANT", 26);
		TraceIn("CONSTANT", 26);
		try
		{
			int _type = CONSTANT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:36:10: ( 'constant' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:36:12: 'constant'
			{
			DebugLocation(36, 12);
			Match("constant"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONSTANT", 26);
			LeaveRule("CONSTANT", 26);
			LeaveRule_CONSTANT();
		}
	}
	// $ANTLR end "CONSTANT"

	partial void EnterRule_DBLQUOTE();
	partial void LeaveRule_DBLQUOTE();

	// $ANTLR start "DBLQUOTE"
	[GrammarRule("DBLQUOTE")]
	private void mDBLQUOTE()
	{
		EnterRule_DBLQUOTE();
		EnterRule("DBLQUOTE", 27);
		TraceIn("DBLQUOTE", 27);
		try
		{
			int _type = DBLQUOTE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:37:10: ( '\\\"' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:37:12: '\\\"'
			{
			DebugLocation(37, 12);
			Match('\"'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DBLQUOTE", 27);
			LeaveRule("DBLQUOTE", 27);
			LeaveRule_DBLQUOTE();
		}
	}
	// $ANTLR end "DBLQUOTE"

	partial void EnterRule_DISCONNECT();
	partial void LeaveRule_DISCONNECT();

	// $ANTLR start "DISCONNECT"
	[GrammarRule("DISCONNECT")]
	private void mDISCONNECT()
	{
		EnterRule_DISCONNECT();
		EnterRule("DISCONNECT", 28);
		TraceIn("DISCONNECT", 28);
		try
		{
			int _type = DISCONNECT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:38:12: ( 'disconnect' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:38:14: 'disconnect'
			{
			DebugLocation(38, 14);
			Match("disconnect"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DISCONNECT", 28);
			LeaveRule("DISCONNECT", 28);
			LeaveRule_DISCONNECT();
		}
	}
	// $ANTLR end "DISCONNECT"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 29);
		TraceIn("DIV", 29);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:39:5: ( '/' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:39:7: '/'
			{
			DebugLocation(39, 7);
			Match('/'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 29);
			LeaveRule("DIV", 29);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 30);
		TraceIn("DOT", 30);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:40:5: ( '.' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:40:7: '.'
			{
			DebugLocation(40, 7);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 30);
			LeaveRule("DOT", 30);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_DOUBLESTAR();
	partial void LeaveRule_DOUBLESTAR();

	// $ANTLR start "DOUBLESTAR"
	[GrammarRule("DOUBLESTAR")]
	private void mDOUBLESTAR()
	{
		EnterRule_DOUBLESTAR();
		EnterRule("DOUBLESTAR", 31);
		TraceIn("DOUBLESTAR", 31);
		try
		{
			int _type = DOUBLESTAR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:41:12: ( '**' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:41:14: '**'
			{
			DebugLocation(41, 14);
			Match("**"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOUBLESTAR", 31);
			LeaveRule("DOUBLESTAR", 31);
			LeaveRule_DOUBLESTAR();
		}
	}
	// $ANTLR end "DOUBLESTAR"

	partial void EnterRule_DOWNTO();
	partial void LeaveRule_DOWNTO();

	// $ANTLR start "DOWNTO"
	[GrammarRule("DOWNTO")]
	private void mDOWNTO()
	{
		EnterRule_DOWNTO();
		EnterRule("DOWNTO", 32);
		TraceIn("DOWNTO", 32);
		try
		{
			int _type = DOWNTO;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:42:8: ( 'downto' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:42:10: 'downto'
			{
			DebugLocation(42, 10);
			Match("downto"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOWNTO", 32);
			LeaveRule("DOWNTO", 32);
			LeaveRule_DOWNTO();
		}
	}
	// $ANTLR end "DOWNTO"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 33);
		TraceIn("ELSE", 33);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:43:6: ( 'else' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:43:8: 'else'
			{
			DebugLocation(43, 8);
			Match("else"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 33);
			LeaveRule("ELSE", 33);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_ELSIF();
	partial void LeaveRule_ELSIF();

	// $ANTLR start "ELSIF"
	[GrammarRule("ELSIF")]
	private void mELSIF()
	{
		EnterRule_ELSIF();
		EnterRule("ELSIF", 34);
		TraceIn("ELSIF", 34);
		try
		{
			int _type = ELSIF;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:44:7: ( 'elsif' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:44:9: 'elsif'
			{
			DebugLocation(44, 9);
			Match("elsif"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSIF", 34);
			LeaveRule("ELSIF", 34);
			LeaveRule_ELSIF();
		}
	}
	// $ANTLR end "ELSIF"

	partial void EnterRule_END();
	partial void LeaveRule_END();

	// $ANTLR start "END"
	[GrammarRule("END")]
	private void mEND()
	{
		EnterRule_END();
		EnterRule("END", 35);
		TraceIn("END", 35);
		try
		{
			int _type = END;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:45:5: ( 'end' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:45:7: 'end'
			{
			DebugLocation(45, 7);
			Match("end"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("END", 35);
			LeaveRule("END", 35);
			LeaveRule_END();
		}
	}
	// $ANTLR end "END"

	partial void EnterRule_ENTITY();
	partial void LeaveRule_ENTITY();

	// $ANTLR start "ENTITY"
	[GrammarRule("ENTITY")]
	private void mENTITY()
	{
		EnterRule_ENTITY();
		EnterRule("ENTITY", 36);
		TraceIn("ENTITY", 36);
		try
		{
			int _type = ENTITY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:46:8: ( 'entity' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:46:10: 'entity'
			{
			DebugLocation(46, 10);
			Match("entity"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ENTITY", 36);
			LeaveRule("ENTITY", 36);
			LeaveRule_ENTITY();
		}
	}
	// $ANTLR end "ENTITY"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 37);
		TraceIn("EQ", 37);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:47:4: ( '=' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:47:6: '='
			{
			DebugLocation(47, 6);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 37);
			LeaveRule("EQ", 37);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_EXCLAMATION();
	partial void LeaveRule_EXCLAMATION();

	// $ANTLR start "EXCLAMATION"
	[GrammarRule("EXCLAMATION")]
	private void mEXCLAMATION()
	{
		EnterRule_EXCLAMATION();
		EnterRule("EXCLAMATION", 38);
		TraceIn("EXCLAMATION", 38);
		try
		{
			int _type = EXCLAMATION;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:48:13: ( '!' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:48:15: '!'
			{
			DebugLocation(48, 15);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXCLAMATION", 38);
			LeaveRule("EXCLAMATION", 38);
			LeaveRule_EXCLAMATION();
		}
	}
	// $ANTLR end "EXCLAMATION"

	partial void EnterRule_EXIT();
	partial void LeaveRule_EXIT();

	// $ANTLR start "EXIT"
	[GrammarRule("EXIT")]
	private void mEXIT()
	{
		EnterRule_EXIT();
		EnterRule("EXIT", 39);
		TraceIn("EXIT", 39);
		try
		{
			int _type = EXIT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:49:6: ( 'exit' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:49:8: 'exit'
			{
			DebugLocation(49, 8);
			Match("exit"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXIT", 39);
			LeaveRule("EXIT", 39);
			LeaveRule_EXIT();
		}
	}
	// $ANTLR end "EXIT"

	partial void EnterRule_FILE();
	partial void LeaveRule_FILE();

	// $ANTLR start "FILE"
	[GrammarRule("FILE")]
	private void mFILE()
	{
		EnterRule_FILE();
		EnterRule("FILE", 40);
		TraceIn("FILE", 40);
		try
		{
			int _type = FILE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:50:6: ( 'file' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:50:8: 'file'
			{
			DebugLocation(50, 8);
			Match("file"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FILE", 40);
			LeaveRule("FILE", 40);
			LeaveRule_FILE();
		}
	}
	// $ANTLR end "FILE"

	partial void EnterRule_FOR();
	partial void LeaveRule_FOR();

	// $ANTLR start "FOR"
	[GrammarRule("FOR")]
	private void mFOR()
	{
		EnterRule_FOR();
		EnterRule("FOR", 41);
		TraceIn("FOR", 41);
		try
		{
			int _type = FOR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:51:5: ( 'for' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:51:7: 'for'
			{
			DebugLocation(51, 7);
			Match("for"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FOR", 41);
			LeaveRule("FOR", 41);
			LeaveRule_FOR();
		}
	}
	// $ANTLR end "FOR"

	partial void EnterRule_FUNCTION();
	partial void LeaveRule_FUNCTION();

	// $ANTLR start "FUNCTION"
	[GrammarRule("FUNCTION")]
	private void mFUNCTION()
	{
		EnterRule_FUNCTION();
		EnterRule("FUNCTION", 42);
		TraceIn("FUNCTION", 42);
		try
		{
			int _type = FUNCTION;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:52:10: ( 'function' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:52:12: 'function'
			{
			DebugLocation(52, 12);
			Match("function"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FUNCTION", 42);
			LeaveRule("FUNCTION", 42);
			LeaveRule_FUNCTION();
		}
	}
	// $ANTLR end "FUNCTION"

	partial void EnterRule_GE();
	partial void LeaveRule_GE();

	// $ANTLR start "GE"
	[GrammarRule("GE")]
	private void mGE()
	{
		EnterRule_GE();
		EnterRule("GE", 43);
		TraceIn("GE", 43);
		try
		{
			int _type = GE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:53:4: ( '>=' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:53:6: '>='
			{
			DebugLocation(53, 6);
			Match(">="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GE", 43);
			LeaveRule("GE", 43);
			LeaveRule_GE();
		}
	}
	// $ANTLR end "GE"

	partial void EnterRule_GENERATE();
	partial void LeaveRule_GENERATE();

	// $ANTLR start "GENERATE"
	[GrammarRule("GENERATE")]
	private void mGENERATE()
	{
		EnterRule_GENERATE();
		EnterRule("GENERATE", 44);
		TraceIn("GENERATE", 44);
		try
		{
			int _type = GENERATE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:54:10: ( 'generate' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:54:12: 'generate'
			{
			DebugLocation(54, 12);
			Match("generate"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GENERATE", 44);
			LeaveRule("GENERATE", 44);
			LeaveRule_GENERATE();
		}
	}
	// $ANTLR end "GENERATE"

	partial void EnterRule_GENERIC();
	partial void LeaveRule_GENERIC();

	// $ANTLR start "GENERIC"
	[GrammarRule("GENERIC")]
	private void mGENERIC()
	{
		EnterRule_GENERIC();
		EnterRule("GENERIC", 45);
		TraceIn("GENERIC", 45);
		try
		{
			int _type = GENERIC;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:55:9: ( 'generic' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:55:11: 'generic'
			{
			DebugLocation(55, 11);
			Match("generic"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GENERIC", 45);
			LeaveRule("GENERIC", 45);
			LeaveRule_GENERIC();
		}
	}
	// $ANTLR end "GENERIC"

	partial void EnterRule_GROUP();
	partial void LeaveRule_GROUP();

	// $ANTLR start "GROUP"
	[GrammarRule("GROUP")]
	private void mGROUP()
	{
		EnterRule_GROUP();
		EnterRule("GROUP", 46);
		TraceIn("GROUP", 46);
		try
		{
			int _type = GROUP;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:56:7: ( 'group' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:56:9: 'group'
			{
			DebugLocation(56, 9);
			Match("group"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GROUP", 46);
			LeaveRule("GROUP", 46);
			LeaveRule_GROUP();
		}
	}
	// $ANTLR end "GROUP"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 47);
		TraceIn("GT", 47);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:57:4: ( '>' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:57:6: '>'
			{
			DebugLocation(57, 6);
			Match('>'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 47);
			LeaveRule("GT", 47);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_GUARDED();
	partial void LeaveRule_GUARDED();

	// $ANTLR start "GUARDED"
	[GrammarRule("GUARDED")]
	private void mGUARDED()
	{
		EnterRule_GUARDED();
		EnterRule("GUARDED", 48);
		TraceIn("GUARDED", 48);
		try
		{
			int _type = GUARDED;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:58:9: ( 'guarded' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:58:11: 'guarded'
			{
			DebugLocation(58, 11);
			Match("guarded"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GUARDED", 48);
			LeaveRule("GUARDED", 48);
			LeaveRule_GUARDED();
		}
	}
	// $ANTLR end "GUARDED"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 49);
		TraceIn("IF", 49);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:59:4: ( 'if' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:59:6: 'if'
			{
			DebugLocation(59, 6);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 49);
			LeaveRule("IF", 49);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_IMPURE();
	partial void LeaveRule_IMPURE();

	// $ANTLR start "IMPURE"
	[GrammarRule("IMPURE")]
	private void mIMPURE()
	{
		EnterRule_IMPURE();
		EnterRule("IMPURE", 50);
		TraceIn("IMPURE", 50);
		try
		{
			int _type = IMPURE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:60:8: ( 'impure' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:60:10: 'impure'
			{
			DebugLocation(60, 10);
			Match("impure"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IMPURE", 50);
			LeaveRule("IMPURE", 50);
			LeaveRule_IMPURE();
		}
	}
	// $ANTLR end "IMPURE"

	partial void EnterRule_IN();
	partial void LeaveRule_IN();

	// $ANTLR start "IN"
	[GrammarRule("IN")]
	private void mIN()
	{
		EnterRule_IN();
		EnterRule("IN", 51);
		TraceIn("IN", 51);
		try
		{
			int _type = IN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:61:4: ( 'in' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:61:6: 'in'
			{
			DebugLocation(61, 6);
			Match("in"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IN", 51);
			LeaveRule("IN", 51);
			LeaveRule_IN();
		}
	}
	// $ANTLR end "IN"

	partial void EnterRule_INERTIAL();
	partial void LeaveRule_INERTIAL();

	// $ANTLR start "INERTIAL"
	[GrammarRule("INERTIAL")]
	private void mINERTIAL()
	{
		EnterRule_INERTIAL();
		EnterRule("INERTIAL", 52);
		TraceIn("INERTIAL", 52);
		try
		{
			int _type = INERTIAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:62:10: ( 'inertial' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:62:12: 'inertial'
			{
			DebugLocation(62, 12);
			Match("inertial"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INERTIAL", 52);
			LeaveRule("INERTIAL", 52);
			LeaveRule_INERTIAL();
		}
	}
	// $ANTLR end "INERTIAL"

	partial void EnterRule_INOUT();
	partial void LeaveRule_INOUT();

	// $ANTLR start "INOUT"
	[GrammarRule("INOUT")]
	private void mINOUT()
	{
		EnterRule_INOUT();
		EnterRule("INOUT", 53);
		TraceIn("INOUT", 53);
		try
		{
			int _type = INOUT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:63:7: ( 'inout' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:63:9: 'inout'
			{
			DebugLocation(63, 9);
			Match("inout"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INOUT", 53);
			LeaveRule("INOUT", 53);
			LeaveRule_INOUT();
		}
	}
	// $ANTLR end "INOUT"

	partial void EnterRule_IS();
	partial void LeaveRule_IS();

	// $ANTLR start "IS"
	[GrammarRule("IS")]
	private void mIS()
	{
		EnterRule_IS();
		EnterRule("IS", 54);
		TraceIn("IS", 54);
		try
		{
			int _type = IS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:64:4: ( 'is' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:64:6: 'is'
			{
			DebugLocation(64, 6);
			Match("is"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IS", 54);
			LeaveRule("IS", 54);
			LeaveRule_IS();
		}
	}
	// $ANTLR end "IS"

	partial void EnterRule_LABEL();
	partial void LeaveRule_LABEL();

	// $ANTLR start "LABEL"
	[GrammarRule("LABEL")]
	private void mLABEL()
	{
		EnterRule_LABEL();
		EnterRule("LABEL", 55);
		TraceIn("LABEL", 55);
		try
		{
			int _type = LABEL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:65:7: ( 'label' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:65:9: 'label'
			{
			DebugLocation(65, 9);
			Match("label"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LABEL", 55);
			LeaveRule("LABEL", 55);
			LeaveRule_LABEL();
		}
	}
	// $ANTLR end "LABEL"

	partial void EnterRule_LBRACKET();
	partial void LeaveRule_LBRACKET();

	// $ANTLR start "LBRACKET"
	[GrammarRule("LBRACKET")]
	private void mLBRACKET()
	{
		EnterRule_LBRACKET();
		EnterRule("LBRACKET", 56);
		TraceIn("LBRACKET", 56);
		try
		{
			int _type = LBRACKET;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:66:10: ( '[' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:66:12: '['
			{
			DebugLocation(66, 12);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACKET", 56);
			LeaveRule("LBRACKET", 56);
			LeaveRule_LBRACKET();
		}
	}
	// $ANTLR end "LBRACKET"

	partial void EnterRule_LE();
	partial void LeaveRule_LE();

	// $ANTLR start "LE"
	[GrammarRule("LE")]
	private void mLE()
	{
		EnterRule_LE();
		EnterRule("LE", 57);
		TraceIn("LE", 57);
		try
		{
			int _type = LE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:67:4: ( '<=' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:67:6: '<='
			{
			DebugLocation(67, 6);
			Match("<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LE", 57);
			LeaveRule("LE", 57);
			LeaveRule_LE();
		}
	}
	// $ANTLR end "LE"

	partial void EnterRule_LIBRARY();
	partial void LeaveRule_LIBRARY();

	// $ANTLR start "LIBRARY"
	[GrammarRule("LIBRARY")]
	private void mLIBRARY()
	{
		EnterRule_LIBRARY();
		EnterRule("LIBRARY", 58);
		TraceIn("LIBRARY", 58);
		try
		{
			int _type = LIBRARY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:68:9: ( 'library' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:68:11: 'library'
			{
			DebugLocation(68, 11);
			Match("library"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LIBRARY", 58);
			LeaveRule("LIBRARY", 58);
			LeaveRule_LIBRARY();
		}
	}
	// $ANTLR end "LIBRARY"

	partial void EnterRule_LINKAGE();
	partial void LeaveRule_LINKAGE();

	// $ANTLR start "LINKAGE"
	[GrammarRule("LINKAGE")]
	private void mLINKAGE()
	{
		EnterRule_LINKAGE();
		EnterRule("LINKAGE", 59);
		TraceIn("LINKAGE", 59);
		try
		{
			int _type = LINKAGE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:69:9: ( 'linkage' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:69:11: 'linkage'
			{
			DebugLocation(69, 11);
			Match("linkage"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LINKAGE", 59);
			LeaveRule("LINKAGE", 59);
			LeaveRule_LINKAGE();
		}
	}
	// $ANTLR end "LINKAGE"

	partial void EnterRule_LITERAL();
	partial void LeaveRule_LITERAL();

	// $ANTLR start "LITERAL"
	[GrammarRule("LITERAL")]
	private void mLITERAL()
	{
		EnterRule_LITERAL();
		EnterRule("LITERAL", 60);
		TraceIn("LITERAL", 60);
		try
		{
			int _type = LITERAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:70:9: ( 'literal' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:70:11: 'literal'
			{
			DebugLocation(70, 11);
			Match("literal"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LITERAL", 60);
			LeaveRule("LITERAL", 60);
			LeaveRule_LITERAL();
		}
	}
	// $ANTLR end "LITERAL"

	partial void EnterRule_LOOP();
	partial void LeaveRule_LOOP();

	// $ANTLR start "LOOP"
	[GrammarRule("LOOP")]
	private void mLOOP()
	{
		EnterRule_LOOP();
		EnterRule("LOOP", 61);
		TraceIn("LOOP", 61);
		try
		{
			int _type = LOOP;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:71:6: ( 'loop' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:71:8: 'loop'
			{
			DebugLocation(71, 8);
			Match("loop"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LOOP", 61);
			LeaveRule("LOOP", 61);
			LeaveRule_LOOP();
		}
	}
	// $ANTLR end "LOOP"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 62);
		TraceIn("LPAREN", 62);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:72:8: ( '(' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:72:10: '('
			{
			DebugLocation(72, 10);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 62);
			LeaveRule("LPAREN", 62);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 63);
		TraceIn("LT", 63);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:73:4: ( '<' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:73:6: '<'
			{
			DebugLocation(73, 6);
			Match('<'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 63);
			LeaveRule("LT", 63);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_MAP();
	partial void LeaveRule_MAP();

	// $ANTLR start "MAP"
	[GrammarRule("MAP")]
	private void mMAP()
	{
		EnterRule_MAP();
		EnterRule("MAP", 64);
		TraceIn("MAP", 64);
		try
		{
			int _type = MAP;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:74:5: ( 'map' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:74:7: 'map'
			{
			DebugLocation(74, 7);
			Match("map"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MAP", 64);
			LeaveRule("MAP", 64);
			LeaveRule_MAP();
		}
	}
	// $ANTLR end "MAP"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 65);
		TraceIn("MINUS", 65);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:75:7: ( '-' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:75:9: '-'
			{
			DebugLocation(75, 9);
			Match('-'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 65);
			LeaveRule("MINUS", 65);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MOD();
	partial void LeaveRule_MOD();

	// $ANTLR start "MOD"
	[GrammarRule("MOD")]
	private void mMOD()
	{
		EnterRule_MOD();
		EnterRule("MOD", 66);
		TraceIn("MOD", 66);
		try
		{
			int _type = MOD;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:76:5: ( 'mod' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:76:7: 'mod'
			{
			DebugLocation(76, 7);
			Match("mod"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MOD", 66);
			LeaveRule("MOD", 66);
			LeaveRule_MOD();
		}
	}
	// $ANTLR end "MOD"

	partial void EnterRule_MUL();
	partial void LeaveRule_MUL();

	// $ANTLR start "MUL"
	[GrammarRule("MUL")]
	private void mMUL()
	{
		EnterRule_MUL();
		EnterRule("MUL", 67);
		TraceIn("MUL", 67);
		try
		{
			int _type = MUL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:77:5: ( '*' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:77:7: '*'
			{
			DebugLocation(77, 7);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MUL", 67);
			LeaveRule("MUL", 67);
			LeaveRule_MUL();
		}
	}
	// $ANTLR end "MUL"

	partial void EnterRule_NAND();
	partial void LeaveRule_NAND();

	// $ANTLR start "NAND"
	[GrammarRule("NAND")]
	private void mNAND()
	{
		EnterRule_NAND();
		EnterRule("NAND", 68);
		TraceIn("NAND", 68);
		try
		{
			int _type = NAND;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:78:6: ( 'nand' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:78:8: 'nand'
			{
			DebugLocation(78, 8);
			Match("nand"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NAND", 68);
			LeaveRule("NAND", 68);
			LeaveRule_NAND();
		}
	}
	// $ANTLR end "NAND"

	partial void EnterRule_NEQ();
	partial void LeaveRule_NEQ();

	// $ANTLR start "NEQ"
	[GrammarRule("NEQ")]
	private void mNEQ()
	{
		EnterRule_NEQ();
		EnterRule("NEQ", 69);
		TraceIn("NEQ", 69);
		try
		{
			int _type = NEQ;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:79:5: ( '/=' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:79:7: '/='
			{
			DebugLocation(79, 7);
			Match("/="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEQ", 69);
			LeaveRule("NEQ", 69);
			LeaveRule_NEQ();
		}
	}
	// $ANTLR end "NEQ"

	partial void EnterRule_NEW();
	partial void LeaveRule_NEW();

	// $ANTLR start "NEW"
	[GrammarRule("NEW")]
	private void mNEW()
	{
		EnterRule_NEW();
		EnterRule("NEW", 70);
		TraceIn("NEW", 70);
		try
		{
			int _type = NEW;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:80:5: ( 'new' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:80:7: 'new'
			{
			DebugLocation(80, 7);
			Match("new"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEW", 70);
			LeaveRule("NEW", 70);
			LeaveRule_NEW();
		}
	}
	// $ANTLR end "NEW"

	partial void EnterRule_NEXT();
	partial void LeaveRule_NEXT();

	// $ANTLR start "NEXT"
	[GrammarRule("NEXT")]
	private void mNEXT()
	{
		EnterRule_NEXT();
		EnterRule("NEXT", 71);
		TraceIn("NEXT", 71);
		try
		{
			int _type = NEXT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:81:6: ( 'next' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:81:8: 'next'
			{
			DebugLocation(81, 8);
			Match("next"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEXT", 71);
			LeaveRule("NEXT", 71);
			LeaveRule_NEXT();
		}
	}
	// $ANTLR end "NEXT"

	partial void EnterRule_NOR();
	partial void LeaveRule_NOR();

	// $ANTLR start "NOR"
	[GrammarRule("NOR")]
	private void mNOR()
	{
		EnterRule_NOR();
		EnterRule("NOR", 72);
		TraceIn("NOR", 72);
		try
		{
			int _type = NOR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:82:5: ( 'nor' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:82:7: 'nor'
			{
			DebugLocation(82, 7);
			Match("nor"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOR", 72);
			LeaveRule("NOR", 72);
			LeaveRule_NOR();
		}
	}
	// $ANTLR end "NOR"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 73);
		TraceIn("NOT", 73);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:83:5: ( 'not' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:83:7: 'not'
			{
			DebugLocation(83, 7);
			Match("not"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 73);
			LeaveRule("NOT", 73);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_NULLTOK();
	partial void LeaveRule_NULLTOK();

	// $ANTLR start "NULLTOK"
	[GrammarRule("NULLTOK")]
	private void mNULLTOK()
	{
		EnterRule_NULLTOK();
		EnterRule("NULLTOK", 74);
		TraceIn("NULLTOK", 74);
		try
		{
			int _type = NULLTOK;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:84:9: ( 'null' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:84:11: 'null'
			{
			DebugLocation(84, 11);
			Match("null"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NULLTOK", 74);
			LeaveRule("NULLTOK", 74);
			LeaveRule_NULLTOK();
		}
	}
	// $ANTLR end "NULLTOK"

	partial void EnterRule_OF();
	partial void LeaveRule_OF();

	// $ANTLR start "OF"
	[GrammarRule("OF")]
	private void mOF()
	{
		EnterRule_OF();
		EnterRule("OF", 75);
		TraceIn("OF", 75);
		try
		{
			int _type = OF;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:85:4: ( 'of' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:85:6: 'of'
			{
			DebugLocation(85, 6);
			Match("of"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OF", 75);
			LeaveRule("OF", 75);
			LeaveRule_OF();
		}
	}
	// $ANTLR end "OF"

	partial void EnterRule_ON();
	partial void LeaveRule_ON();

	// $ANTLR start "ON"
	[GrammarRule("ON")]
	private void mON()
	{
		EnterRule_ON();
		EnterRule("ON", 76);
		TraceIn("ON", 76);
		try
		{
			int _type = ON;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:86:4: ( 'on' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:86:6: 'on'
			{
			DebugLocation(86, 6);
			Match("on"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ON", 76);
			LeaveRule("ON", 76);
			LeaveRule_ON();
		}
	}
	// $ANTLR end "ON"

	partial void EnterRule_OPEN();
	partial void LeaveRule_OPEN();

	// $ANTLR start "OPEN"
	[GrammarRule("OPEN")]
	private void mOPEN()
	{
		EnterRule_OPEN();
		EnterRule("OPEN", 77);
		TraceIn("OPEN", 77);
		try
		{
			int _type = OPEN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:87:6: ( 'open' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:87:8: 'open'
			{
			DebugLocation(87, 8);
			Match("open"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OPEN", 77);
			LeaveRule("OPEN", 77);
			LeaveRule_OPEN();
		}
	}
	// $ANTLR end "OPEN"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 78);
		TraceIn("OR", 78);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:88:4: ( 'or' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:88:6: 'or'
			{
			DebugLocation(88, 6);
			Match("or"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 78);
			LeaveRule("OR", 78);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_OTHERS();
	partial void LeaveRule_OTHERS();

	// $ANTLR start "OTHERS"
	[GrammarRule("OTHERS")]
	private void mOTHERS()
	{
		EnterRule_OTHERS();
		EnterRule("OTHERS", 79);
		TraceIn("OTHERS", 79);
		try
		{
			int _type = OTHERS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:89:8: ( 'others' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:89:10: 'others'
			{
			DebugLocation(89, 10);
			Match("others"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OTHERS", 79);
			LeaveRule("OTHERS", 79);
			LeaveRule_OTHERS();
		}
	}
	// $ANTLR end "OTHERS"

	partial void EnterRule_OUT();
	partial void LeaveRule_OUT();

	// $ANTLR start "OUT"
	[GrammarRule("OUT")]
	private void mOUT()
	{
		EnterRule_OUT();
		EnterRule("OUT", 80);
		TraceIn("OUT", 80);
		try
		{
			int _type = OUT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:90:5: ( 'out' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:90:7: 'out'
			{
			DebugLocation(90, 7);
			Match("out"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OUT", 80);
			LeaveRule("OUT", 80);
			LeaveRule_OUT();
		}
	}
	// $ANTLR end "OUT"

	partial void EnterRule_PACKAGE();
	partial void LeaveRule_PACKAGE();

	// $ANTLR start "PACKAGE"
	[GrammarRule("PACKAGE")]
	private void mPACKAGE()
	{
		EnterRule_PACKAGE();
		EnterRule("PACKAGE", 81);
		TraceIn("PACKAGE", 81);
		try
		{
			int _type = PACKAGE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:91:9: ( 'package' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:91:11: 'package'
			{
			DebugLocation(91, 11);
			Match("package"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PACKAGE", 81);
			LeaveRule("PACKAGE", 81);
			LeaveRule_PACKAGE();
		}
	}
	// $ANTLR end "PACKAGE"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 82);
		TraceIn("PLUS", 82);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:92:6: ( '+' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:92:8: '+'
			{
			DebugLocation(92, 8);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 82);
			LeaveRule("PLUS", 82);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_PORT();
	partial void LeaveRule_PORT();

	// $ANTLR start "PORT"
	[GrammarRule("PORT")]
	private void mPORT()
	{
		EnterRule_PORT();
		EnterRule("PORT", 83);
		TraceIn("PORT", 83);
		try
		{
			int _type = PORT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:93:6: ( 'port' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:93:8: 'port'
			{
			DebugLocation(93, 8);
			Match("port"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PORT", 83);
			LeaveRule("PORT", 83);
			LeaveRule_PORT();
		}
	}
	// $ANTLR end "PORT"

	partial void EnterRule_POSTPONED();
	partial void LeaveRule_POSTPONED();

	// $ANTLR start "POSTPONED"
	[GrammarRule("POSTPONED")]
	private void mPOSTPONED()
	{
		EnterRule_POSTPONED();
		EnterRule("POSTPONED", 84);
		TraceIn("POSTPONED", 84);
		try
		{
			int _type = POSTPONED;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:94:11: ( 'postponed' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:94:13: 'postponed'
			{
			DebugLocation(94, 13);
			Match("postponed"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("POSTPONED", 84);
			LeaveRule("POSTPONED", 84);
			LeaveRule_POSTPONED();
		}
	}
	// $ANTLR end "POSTPONED"

	partial void EnterRule_PROCEDURE();
	partial void LeaveRule_PROCEDURE();

	// $ANTLR start "PROCEDURE"
	[GrammarRule("PROCEDURE")]
	private void mPROCEDURE()
	{
		EnterRule_PROCEDURE();
		EnterRule("PROCEDURE", 85);
		TraceIn("PROCEDURE", 85);
		try
		{
			int _type = PROCEDURE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:95:11: ( 'procedure' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:95:13: 'procedure'
			{
			DebugLocation(95, 13);
			Match("procedure"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROCEDURE", 85);
			LeaveRule("PROCEDURE", 85);
			LeaveRule_PROCEDURE();
		}
	}
	// $ANTLR end "PROCEDURE"

	partial void EnterRule_PROCESS();
	partial void LeaveRule_PROCESS();

	// $ANTLR start "PROCESS"
	[GrammarRule("PROCESS")]
	private void mPROCESS()
	{
		EnterRule_PROCESS();
		EnterRule("PROCESS", 86);
		TraceIn("PROCESS", 86);
		try
		{
			int _type = PROCESS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:96:9: ( 'process' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:96:11: 'process'
			{
			DebugLocation(96, 11);
			Match("process"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROCESS", 86);
			LeaveRule("PROCESS", 86);
			LeaveRule_PROCESS();
		}
	}
	// $ANTLR end "PROCESS"

	partial void EnterRule_PURE();
	partial void LeaveRule_PURE();

	// $ANTLR start "PURE"
	[GrammarRule("PURE")]
	private void mPURE()
	{
		EnterRule_PURE();
		EnterRule("PURE", 87);
		TraceIn("PURE", 87);
		try
		{
			int _type = PURE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:97:6: ( 'pure' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:97:8: 'pure'
			{
			DebugLocation(97, 8);
			Match("pure"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PURE", 87);
			LeaveRule("PURE", 87);
			LeaveRule_PURE();
		}
	}
	// $ANTLR end "PURE"

	partial void EnterRule_RANGETOK();
	partial void LeaveRule_RANGETOK();

	// $ANTLR start "RANGETOK"
	[GrammarRule("RANGETOK")]
	private void mRANGETOK()
	{
		EnterRule_RANGETOK();
		EnterRule("RANGETOK", 88);
		TraceIn("RANGETOK", 88);
		try
		{
			int _type = RANGETOK;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:98:10: ( 'range' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:98:12: 'range'
			{
			DebugLocation(98, 12);
			Match("range"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RANGETOK", 88);
			LeaveRule("RANGETOK", 88);
			LeaveRule_RANGETOK();
		}
	}
	// $ANTLR end "RANGETOK"

	partial void EnterRule_RBRACKET();
	partial void LeaveRule_RBRACKET();

	// $ANTLR start "RBRACKET"
	[GrammarRule("RBRACKET")]
	private void mRBRACKET()
	{
		EnterRule_RBRACKET();
		EnterRule("RBRACKET", 89);
		TraceIn("RBRACKET", 89);
		try
		{
			int _type = RBRACKET;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:99:10: ( ']' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:99:12: ']'
			{
			DebugLocation(99, 12);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACKET", 89);
			LeaveRule("RBRACKET", 89);
			LeaveRule_RBRACKET();
		}
	}
	// $ANTLR end "RBRACKET"

	partial void EnterRule_RECORD();
	partial void LeaveRule_RECORD();

	// $ANTLR start "RECORD"
	[GrammarRule("RECORD")]
	private void mRECORD()
	{
		EnterRule_RECORD();
		EnterRule("RECORD", 90);
		TraceIn("RECORD", 90);
		try
		{
			int _type = RECORD;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:100:8: ( 'record' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:100:10: 'record'
			{
			DebugLocation(100, 10);
			Match("record"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RECORD", 90);
			LeaveRule("RECORD", 90);
			LeaveRule_RECORD();
		}
	}
	// $ANTLR end "RECORD"

	partial void EnterRule_REGISTER();
	partial void LeaveRule_REGISTER();

	// $ANTLR start "REGISTER"
	[GrammarRule("REGISTER")]
	private void mREGISTER()
	{
		EnterRule_REGISTER();
		EnterRule("REGISTER", 91);
		TraceIn("REGISTER", 91);
		try
		{
			int _type = REGISTER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:101:10: ( 'register' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:101:12: 'register'
			{
			DebugLocation(101, 12);
			Match("register"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REGISTER", 91);
			LeaveRule("REGISTER", 91);
			LeaveRule_REGISTER();
		}
	}
	// $ANTLR end "REGISTER"

	partial void EnterRule_REJECT();
	partial void LeaveRule_REJECT();

	// $ANTLR start "REJECT"
	[GrammarRule("REJECT")]
	private void mREJECT()
	{
		EnterRule_REJECT();
		EnterRule("REJECT", 92);
		TraceIn("REJECT", 92);
		try
		{
			int _type = REJECT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:102:8: ( 'reject' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:102:10: 'reject'
			{
			DebugLocation(102, 10);
			Match("reject"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REJECT", 92);
			LeaveRule("REJECT", 92);
			LeaveRule_REJECT();
		}
	}
	// $ANTLR end "REJECT"

	partial void EnterRule_REM();
	partial void LeaveRule_REM();

	// $ANTLR start "REM"
	[GrammarRule("REM")]
	private void mREM()
	{
		EnterRule_REM();
		EnterRule("REM", 93);
		TraceIn("REM", 93);
		try
		{
			int _type = REM;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:103:5: ( 'rem' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:103:7: 'rem'
			{
			DebugLocation(103, 7);
			Match("rem"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REM", 93);
			LeaveRule("REM", 93);
			LeaveRule_REM();
		}
	}
	// $ANTLR end "REM"

	partial void EnterRule_REPORT();
	partial void LeaveRule_REPORT();

	// $ANTLR start "REPORT"
	[GrammarRule("REPORT")]
	private void mREPORT()
	{
		EnterRule_REPORT();
		EnterRule("REPORT", 94);
		TraceIn("REPORT", 94);
		try
		{
			int _type = REPORT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:104:8: ( 'report' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:104:10: 'report'
			{
			DebugLocation(104, 10);
			Match("report"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REPORT", 94);
			LeaveRule("REPORT", 94);
			LeaveRule_REPORT();
		}
	}
	// $ANTLR end "REPORT"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 95);
		TraceIn("RETURN", 95);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:105:8: ( 'return' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:105:10: 'return'
			{
			DebugLocation(105, 10);
			Match("return"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 95);
			LeaveRule("RETURN", 95);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_ROL();
	partial void LeaveRule_ROL();

	// $ANTLR start "ROL"
	[GrammarRule("ROL")]
	private void mROL()
	{
		EnterRule_ROL();
		EnterRule("ROL", 96);
		TraceIn("ROL", 96);
		try
		{
			int _type = ROL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:106:5: ( 'rol' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:106:7: 'rol'
			{
			DebugLocation(106, 7);
			Match("rol"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ROL", 96);
			LeaveRule("ROL", 96);
			LeaveRule_ROL();
		}
	}
	// $ANTLR end "ROL"

	partial void EnterRule_ROR();
	partial void LeaveRule_ROR();

	// $ANTLR start "ROR"
	[GrammarRule("ROR")]
	private void mROR()
	{
		EnterRule_ROR();
		EnterRule("ROR", 97);
		TraceIn("ROR", 97);
		try
		{
			int _type = ROR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:107:5: ( 'ror' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:107:7: 'ror'
			{
			DebugLocation(107, 7);
			Match("ror"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ROR", 97);
			LeaveRule("ROR", 97);
			LeaveRule_ROR();
		}
	}
	// $ANTLR end "ROR"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 98);
		TraceIn("RPAREN", 98);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:108:8: ( ')' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:108:10: ')'
			{
			DebugLocation(108, 10);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 98);
			LeaveRule("RPAREN", 98);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_SELECT();
	partial void LeaveRule_SELECT();

	// $ANTLR start "SELECT"
	[GrammarRule("SELECT")]
	private void mSELECT()
	{
		EnterRule_SELECT();
		EnterRule("SELECT", 99);
		TraceIn("SELECT", 99);
		try
		{
			int _type = SELECT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:109:8: ( 'select' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:109:10: 'select'
			{
			DebugLocation(109, 10);
			Match("select"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SELECT", 99);
			LeaveRule("SELECT", 99);
			LeaveRule_SELECT();
		}
	}
	// $ANTLR end "SELECT"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 100);
		TraceIn("SEMI", 100);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:110:6: ( ';' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:110:8: ';'
			{
			DebugLocation(110, 8);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 100);
			LeaveRule("SEMI", 100);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_SEVERITY();
	partial void LeaveRule_SEVERITY();

	// $ANTLR start "SEVERITY"
	[GrammarRule("SEVERITY")]
	private void mSEVERITY()
	{
		EnterRule_SEVERITY();
		EnterRule("SEVERITY", 101);
		TraceIn("SEVERITY", 101);
		try
		{
			int _type = SEVERITY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:111:10: ( 'severity' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:111:12: 'severity'
			{
			DebugLocation(111, 12);
			Match("severity"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEVERITY", 101);
			LeaveRule("SEVERITY", 101);
			LeaveRule_SEVERITY();
		}
	}
	// $ANTLR end "SEVERITY"

	partial void EnterRule_SHARED();
	partial void LeaveRule_SHARED();

	// $ANTLR start "SHARED"
	[GrammarRule("SHARED")]
	private void mSHARED()
	{
		EnterRule_SHARED();
		EnterRule("SHARED", 102);
		TraceIn("SHARED", 102);
		try
		{
			int _type = SHARED;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:112:8: ( 'shared' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:112:10: 'shared'
			{
			DebugLocation(112, 10);
			Match("shared"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SHARED", 102);
			LeaveRule("SHARED", 102);
			LeaveRule_SHARED();
		}
	}
	// $ANTLR end "SHARED"

	partial void EnterRule_SIGNAL();
	partial void LeaveRule_SIGNAL();

	// $ANTLR start "SIGNAL"
	[GrammarRule("SIGNAL")]
	private void mSIGNAL()
	{
		EnterRule_SIGNAL();
		EnterRule("SIGNAL", 103);
		TraceIn("SIGNAL", 103);
		try
		{
			int _type = SIGNAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:113:8: ( 'signal' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:113:10: 'signal'
			{
			DebugLocation(113, 10);
			Match("signal"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SIGNAL", 103);
			LeaveRule("SIGNAL", 103);
			LeaveRule_SIGNAL();
		}
	}
	// $ANTLR end "SIGNAL"

	partial void EnterRule_SLA();
	partial void LeaveRule_SLA();

	// $ANTLR start "SLA"
	[GrammarRule("SLA")]
	private void mSLA()
	{
		EnterRule_SLA();
		EnterRule("SLA", 104);
		TraceIn("SLA", 104);
		try
		{
			int _type = SLA;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:114:5: ( 'sla' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:114:7: 'sla'
			{
			DebugLocation(114, 7);
			Match("sla"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SLA", 104);
			LeaveRule("SLA", 104);
			LeaveRule_SLA();
		}
	}
	// $ANTLR end "SLA"

	partial void EnterRule_SLL();
	partial void LeaveRule_SLL();

	// $ANTLR start "SLL"
	[GrammarRule("SLL")]
	private void mSLL()
	{
		EnterRule_SLL();
		EnterRule("SLL", 105);
		TraceIn("SLL", 105);
		try
		{
			int _type = SLL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:115:5: ( 'sll' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:115:7: 'sll'
			{
			DebugLocation(115, 7);
			Match("sll"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SLL", 105);
			LeaveRule("SLL", 105);
			LeaveRule_SLL();
		}
	}
	// $ANTLR end "SLL"

	partial void EnterRule_SRA();
	partial void LeaveRule_SRA();

	// $ANTLR start "SRA"
	[GrammarRule("SRA")]
	private void mSRA()
	{
		EnterRule_SRA();
		EnterRule("SRA", 106);
		TraceIn("SRA", 106);
		try
		{
			int _type = SRA;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:116:5: ( 'sra' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:116:7: 'sra'
			{
			DebugLocation(116, 7);
			Match("sra"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SRA", 106);
			LeaveRule("SRA", 106);
			LeaveRule_SRA();
		}
	}
	// $ANTLR end "SRA"

	partial void EnterRule_SRL();
	partial void LeaveRule_SRL();

	// $ANTLR start "SRL"
	[GrammarRule("SRL")]
	private void mSRL()
	{
		EnterRule_SRL();
		EnterRule("SRL", 107);
		TraceIn("SRL", 107);
		try
		{
			int _type = SRL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:117:5: ( 'srl' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:117:7: 'srl'
			{
			DebugLocation(117, 7);
			Match("srl"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SRL", 107);
			LeaveRule("SRL", 107);
			LeaveRule_SRL();
		}
	}
	// $ANTLR end "SRL"

	partial void EnterRule_SUBTYPE();
	partial void LeaveRule_SUBTYPE();

	// $ANTLR start "SUBTYPE"
	[GrammarRule("SUBTYPE")]
	private void mSUBTYPE()
	{
		EnterRule_SUBTYPE();
		EnterRule("SUBTYPE", 108);
		TraceIn("SUBTYPE", 108);
		try
		{
			int _type = SUBTYPE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:118:9: ( 'subtype' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:118:11: 'subtype'
			{
			DebugLocation(118, 11);
			Match("subtype"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SUBTYPE", 108);
			LeaveRule("SUBTYPE", 108);
			LeaveRule_SUBTYPE();
		}
	}
	// $ANTLR end "SUBTYPE"

	partial void EnterRule_THEN();
	partial void LeaveRule_THEN();

	// $ANTLR start "THEN"
	[GrammarRule("THEN")]
	private void mTHEN()
	{
		EnterRule_THEN();
		EnterRule("THEN", 109);
		TraceIn("THEN", 109);
		try
		{
			int _type = THEN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:119:6: ( 'then' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:119:8: 'then'
			{
			DebugLocation(119, 8);
			Match("then"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("THEN", 109);
			LeaveRule("THEN", 109);
			LeaveRule_THEN();
		}
	}
	// $ANTLR end "THEN"

	partial void EnterRule_TO();
	partial void LeaveRule_TO();

	// $ANTLR start "TO"
	[GrammarRule("TO")]
	private void mTO()
	{
		EnterRule_TO();
		EnterRule("TO", 110);
		TraceIn("TO", 110);
		try
		{
			int _type = TO;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:120:4: ( 'to' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:120:6: 'to'
			{
			DebugLocation(120, 6);
			Match("to"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TO", 110);
			LeaveRule("TO", 110);
			LeaveRule_TO();
		}
	}
	// $ANTLR end "TO"

	partial void EnterRule_TRANSPORT();
	partial void LeaveRule_TRANSPORT();

	// $ANTLR start "TRANSPORT"
	[GrammarRule("TRANSPORT")]
	private void mTRANSPORT()
	{
		EnterRule_TRANSPORT();
		EnterRule("TRANSPORT", 111);
		TraceIn("TRANSPORT", 111);
		try
		{
			int _type = TRANSPORT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:121:11: ( 'transport' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:121:13: 'transport'
			{
			DebugLocation(121, 13);
			Match("transport"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRANSPORT", 111);
			LeaveRule("TRANSPORT", 111);
			LeaveRule_TRANSPORT();
		}
	}
	// $ANTLR end "TRANSPORT"

	partial void EnterRule_TYPE();
	partial void LeaveRule_TYPE();

	// $ANTLR start "TYPE"
	[GrammarRule("TYPE")]
	private void mTYPE()
	{
		EnterRule_TYPE();
		EnterRule("TYPE", 112);
		TraceIn("TYPE", 112);
		try
		{
			int _type = TYPE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:122:6: ( 'type' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:122:8: 'type'
			{
			DebugLocation(122, 8);
			Match("type"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TYPE", 112);
			LeaveRule("TYPE", 112);
			LeaveRule_TYPE();
		}
	}
	// $ANTLR end "TYPE"

	partial void EnterRule_UNAFFECTED();
	partial void LeaveRule_UNAFFECTED();

	// $ANTLR start "UNAFFECTED"
	[GrammarRule("UNAFFECTED")]
	private void mUNAFFECTED()
	{
		EnterRule_UNAFFECTED();
		EnterRule("UNAFFECTED", 113);
		TraceIn("UNAFFECTED", 113);
		try
		{
			int _type = UNAFFECTED;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:123:12: ( 'unaffected' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:123:14: 'unaffected'
			{
			DebugLocation(123, 14);
			Match("unaffected"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNAFFECTED", 113);
			LeaveRule("UNAFFECTED", 113);
			LeaveRule_UNAFFECTED();
		}
	}
	// $ANTLR end "UNAFFECTED"

	partial void EnterRule_UNITS();
	partial void LeaveRule_UNITS();

	// $ANTLR start "UNITS"
	[GrammarRule("UNITS")]
	private void mUNITS()
	{
		EnterRule_UNITS();
		EnterRule("UNITS", 114);
		TraceIn("UNITS", 114);
		try
		{
			int _type = UNITS;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:124:7: ( 'units' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:124:9: 'units'
			{
			DebugLocation(124, 9);
			Match("units"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNITS", 114);
			LeaveRule("UNITS", 114);
			LeaveRule_UNITS();
		}
	}
	// $ANTLR end "UNITS"

	partial void EnterRule_UNTIL();
	partial void LeaveRule_UNTIL();

	// $ANTLR start "UNTIL"
	[GrammarRule("UNTIL")]
	private void mUNTIL()
	{
		EnterRule_UNTIL();
		EnterRule("UNTIL", 115);
		TraceIn("UNTIL", 115);
		try
		{
			int _type = UNTIL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:125:7: ( 'until' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:125:9: 'until'
			{
			DebugLocation(125, 9);
			Match("until"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNTIL", 115);
			LeaveRule("UNTIL", 115);
			LeaveRule_UNTIL();
		}
	}
	// $ANTLR end "UNTIL"

	partial void EnterRule_USE();
	partial void LeaveRule_USE();

	// $ANTLR start "USE"
	[GrammarRule("USE")]
	private void mUSE()
	{
		EnterRule_USE();
		EnterRule("USE", 116);
		TraceIn("USE", 116);
		try
		{
			int _type = USE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:126:5: ( 'use' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:126:7: 'use'
			{
			DebugLocation(126, 7);
			Match("use"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("USE", 116);
			LeaveRule("USE", 116);
			LeaveRule_USE();
		}
	}
	// $ANTLR end "USE"

	partial void EnterRule_VARASGN();
	partial void LeaveRule_VARASGN();

	// $ANTLR start "VARASGN"
	[GrammarRule("VARASGN")]
	private void mVARASGN()
	{
		EnterRule_VARASGN();
		EnterRule("VARASGN", 117);
		TraceIn("VARASGN", 117);
		try
		{
			int _type = VARASGN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:127:9: ( ':=' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:127:11: ':='
			{
			DebugLocation(127, 11);
			Match(":="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VARASGN", 117);
			LeaveRule("VARASGN", 117);
			LeaveRule_VARASGN();
		}
	}
	// $ANTLR end "VARASGN"

	partial void EnterRule_VARIABLE();
	partial void LeaveRule_VARIABLE();

	// $ANTLR start "VARIABLE"
	[GrammarRule("VARIABLE")]
	private void mVARIABLE()
	{
		EnterRule_VARIABLE();
		EnterRule("VARIABLE", 118);
		TraceIn("VARIABLE", 118);
		try
		{
			int _type = VARIABLE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:128:10: ( 'variable' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:128:12: 'variable'
			{
			DebugLocation(128, 12);
			Match("variable"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VARIABLE", 118);
			LeaveRule("VARIABLE", 118);
			LeaveRule_VARIABLE();
		}
	}
	// $ANTLR end "VARIABLE"

	partial void EnterRule_WAIT();
	partial void LeaveRule_WAIT();

	// $ANTLR start "WAIT"
	[GrammarRule("WAIT")]
	private void mWAIT()
	{
		EnterRule_WAIT();
		EnterRule("WAIT", 119);
		TraceIn("WAIT", 119);
		try
		{
			int _type = WAIT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:129:6: ( 'wait' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:129:8: 'wait'
			{
			DebugLocation(129, 8);
			Match("wait"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WAIT", 119);
			LeaveRule("WAIT", 119);
			LeaveRule_WAIT();
		}
	}
	// $ANTLR end "WAIT"

	partial void EnterRule_WHEN();
	partial void LeaveRule_WHEN();

	// $ANTLR start "WHEN"
	[GrammarRule("WHEN")]
	private void mWHEN()
	{
		EnterRule_WHEN();
		EnterRule("WHEN", 120);
		TraceIn("WHEN", 120);
		try
		{
			int _type = WHEN;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:130:6: ( 'when' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:130:8: 'when'
			{
			DebugLocation(130, 8);
			Match("when"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHEN", 120);
			LeaveRule("WHEN", 120);
			LeaveRule_WHEN();
		}
	}
	// $ANTLR end "WHEN"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 121);
		TraceIn("WHILE", 121);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:131:7: ( 'while' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:131:9: 'while'
			{
			DebugLocation(131, 9);
			Match("while"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 121);
			LeaveRule("WHILE", 121);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_WITH();
	partial void LeaveRule_WITH();

	// $ANTLR start "WITH"
	[GrammarRule("WITH")]
	private void mWITH()
	{
		EnterRule_WITH();
		EnterRule("WITH", 122);
		TraceIn("WITH", 122);
		try
		{
			int _type = WITH;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:132:6: ( 'with' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:132:8: 'with'
			{
			DebugLocation(132, 8);
			Match("with"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WITH", 122);
			LeaveRule("WITH", 122);
			LeaveRule_WITH();
		}
	}
	// $ANTLR end "WITH"

	partial void EnterRule_XNOR();
	partial void LeaveRule_XNOR();

	// $ANTLR start "XNOR"
	[GrammarRule("XNOR")]
	private void mXNOR()
	{
		EnterRule_XNOR();
		EnterRule("XNOR", 123);
		TraceIn("XNOR", 123);
		try
		{
			int _type = XNOR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:133:6: ( 'xnor' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:133:8: 'xnor'
			{
			DebugLocation(133, 8);
			Match("xnor"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("XNOR", 123);
			LeaveRule("XNOR", 123);
			LeaveRule_XNOR();
		}
	}
	// $ANTLR end "XNOR"

	partial void EnterRule_XOR();
	partial void LeaveRule_XOR();

	// $ANTLR start "XOR"
	[GrammarRule("XOR")]
	private void mXOR()
	{
		EnterRule_XOR();
		EnterRule("XOR", 124);
		TraceIn("XOR", 124);
		try
		{
			int _type = XOR;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:134:5: ( 'xor' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:134:7: 'xor'
			{
			DebugLocation(134, 7);
			Match("xor"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("XOR", 124);
			LeaveRule("XOR", 124);
			LeaveRule_XOR();
		}
	}
	// $ANTLR end "XOR"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 125);
		TraceIn("WHITESPACE", 125);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1731:5: ( ( '\\t' | ' ' | '\\n' | '\\r' )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1731:9: ( '\\t' | ' ' | '\\n' | '\\r' )+
			{
			DebugLocation(1731, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1731:9: ( '\\t' | ' ' | '\\n' | '\\r' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='\t' && LA1_0<='\n')||LA1_0=='\r'||LA1_0==' '))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1731, 9);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(1731, 39);
			if (state.backtracking == 0)
			{
				 _channel = Hidden; 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 125);
			LeaveRule("WHITESPACE", 125);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 126);
		TraceIn("COMMENT", 126);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1735:5: ( '--' (~ ( '\\n' | '\\r' ) )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1735:9: '--' (~ ( '\\n' | '\\r' ) )*
			{
			DebugLocation(1735, 9);
			Match("--"); if (state.failed) return;

			DebugLocation(1735, 14);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1735:14: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>='\u0000' && LA2_0<='\t')||(LA2_0>='\u000B' && LA2_0<='\f')||(LA2_0>='\u000E' && LA2_0<='\uFFFF')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1735, 14);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(1735, 36);
			if (state.backtracking == 0)
			{
				 _channel = CHANNEL_COMMENT; 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 126);
			LeaveRule("COMMENT", 126);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_BASIC_IDENTIFIER();
	partial void LeaveRule_BASIC_IDENTIFIER();

	// $ANTLR start "BASIC_IDENTIFIER"
	[GrammarRule("BASIC_IDENTIFIER")]
	private void mBASIC_IDENTIFIER()
	{
		EnterRule_BASIC_IDENTIFIER();
		EnterRule("BASIC_IDENTIFIER", 127);
		TraceIn("BASIC_IDENTIFIER", 127);
		try
		{
			int _type = BASIC_IDENTIFIER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1739:5: ( LETTER ( LETTER_OR_DIGIT | '_' )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1739:9: LETTER ( LETTER_OR_DIGIT | '_' )*
			{
			DebugLocation(1739, 9);
			mLETTER(); if (state.failed) return;
			DebugLocation(1739, 16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1739:16: ( LETTER_OR_DIGIT | '_' )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if (((LA3_0>='0' && LA3_0<='9')||(LA3_0>='A' && LA3_0<='Z')||LA3_0=='_'||(LA3_0>='a' && LA3_0<='z')||(LA3_0>='\u00C0' && LA3_0<='\u00D6')||(LA3_0>='\u00D8' && LA3_0<='\u00F6')||(LA3_0>='\u00F8' && LA3_0<='\u00FF')))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1739, 16);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BASIC_IDENTIFIER", 127);
			LeaveRule("BASIC_IDENTIFIER", 127);
			LeaveRule_BASIC_IDENTIFIER();
		}
	}
	// $ANTLR end "BASIC_IDENTIFIER"

	partial void EnterRule_EXTENDED_IDENTIFIER();
	partial void LeaveRule_EXTENDED_IDENTIFIER();

	// $ANTLR start "EXTENDED_IDENTIFIER"
	[GrammarRule("EXTENDED_IDENTIFIER")]
	private void mEXTENDED_IDENTIFIER()
	{
		EnterRule_EXTENDED_IDENTIFIER();
		EnterRule("EXTENDED_IDENTIFIER", 128);
		TraceIn("EXTENDED_IDENTIFIER", 128);
		try
		{
			int _type = EXTENDED_IDENTIFIER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:5: ( '\\\\' ( '\\\"' | '\\\\\\\\' | '%' | GRAPHIC_CHARACTER )+ '\\\\' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:9: '\\\\' ( '\\\"' | '\\\\\\\\' | '%' | GRAPHIC_CHARACTER )+ '\\\\'
			{
			DebugLocation(1744, 9);
			Match('\\'); if (state.failed) return;
			DebugLocation(1744, 14);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:14: ( '\\\"' | '\\\\\\\\' | '%' | GRAPHIC_CHARACTER )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=5;
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case '\\':
					{
					int LA4_1 = input.LA(2);

					if ((LA4_1=='\\'))
					{
						alt4 = 2;
					}


					}
					break;
				case '\"':
					{
					alt4 = 1;
					}
					break;
				case '%':
					{
					alt4 = 3;
					}
					break;
				case ' ':
				case '!':
				case '#':
				case '$':
				case '&':
				case '\'':
				case '(':
				case ')':
				case '*':
				case '+':
				case ',':
				case '-':
				case '.':
				case '/':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case ':':
				case ';':
				case '<':
				case '=':
				case '>':
				case '?':
				case '@':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '[':
				case ']':
				case '^':
				case '_':
				case '`':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z':
				case '{':
				case '|':
				case '}':
				case '~':
				case '\u00A0':
				case '\u00A1':
				case '\u00A2':
				case '\u00A3':
				case '\u00A4':
				case '\u00A5':
				case '\u00A6':
				case '\u00A7':
				case '\u00A8':
				case '\u00A9':
				case '\u00AA':
				case '\u00AB':
				case '\u00AC':
				case '\u00AD':
				case '\u00AE':
				case '\u00AF':
				case '\u00B0':
				case '\u00B1':
				case '\u00B2':
				case '\u00B3':
				case '\u00B4':
				case '\u00B5':
				case '\u00B6':
				case '\u00B7':
				case '\u00B8':
				case '\u00B9':
				case '\u00BA':
				case '\u00BB':
				case '\u00BC':
				case '\u00BD':
				case '\u00BE':
				case '\u00BF':
				case '\u00C0':
				case '\u00C1':
				case '\u00C2':
				case '\u00C3':
				case '\u00C4':
				case '\u00C5':
				case '\u00C6':
				case '\u00C7':
				case '\u00C8':
				case '\u00C9':
				case '\u00CA':
				case '\u00CB':
				case '\u00CC':
				case '\u00CD':
				case '\u00CE':
				case '\u00CF':
				case '\u00D0':
				case '\u00D1':
				case '\u00D2':
				case '\u00D3':
				case '\u00D4':
				case '\u00D5':
				case '\u00D6':
				case '\u00D7':
				case '\u00D8':
				case '\u00D9':
				case '\u00DA':
				case '\u00DB':
				case '\u00DC':
				case '\u00DD':
				case '\u00DE':
				case '\u00DF':
				case '\u00E0':
				case '\u00E1':
				case '\u00E2':
				case '\u00E3':
				case '\u00E4':
				case '\u00E5':
				case '\u00E6':
				case '\u00E7':
				case '\u00E8':
				case '\u00E9':
				case '\u00EA':
				case '\u00EB':
				case '\u00EC':
				case '\u00ED':
				case '\u00EE':
				case '\u00EF':
				case '\u00F0':
				case '\u00F1':
				case '\u00F2':
				case '\u00F3':
				case '\u00F4':
				case '\u00F5':
				case '\u00F6':
				case '\u00F7':
				case '\u00F8':
				case '\u00F9':
				case '\u00FA':
				case '\u00FB':
				case '\u00FC':
				case '\u00FD':
				case '\u00FE':
				case '\u00FF':
					{
					alt4 = 4;
					}
					break;
				}

				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:16: '\\\"'
					{
					DebugLocation(1744, 16);
					Match('\"'); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:23: '\\\\\\\\'
					{
					DebugLocation(1744, 23);
					Match("\\\\"); if (state.failed) return;


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:32: '%'
					{
					DebugLocation(1744, 32);
					Match('%'); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1744:39: GRAPHIC_CHARACTER
					{
					DebugLocation(1744, 39);
					mGRAPHIC_CHARACTER(); if (state.failed) return;

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(1744, 60);
			Match('\\'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXTENDED_IDENTIFIER", 128);
			LeaveRule("EXTENDED_IDENTIFIER", 128);
			LeaveRule_EXTENDED_IDENTIFIER();
		}
	}
	// $ANTLR end "EXTENDED_IDENTIFIER"

	partial void EnterRule_FLOAT_POINT_LITERAL();
	partial void LeaveRule_FLOAT_POINT_LITERAL();

	// $ANTLR start "FLOAT_POINT_LITERAL"
	[GrammarRule("FLOAT_POINT_LITERAL")]
	private void mFLOAT_POINT_LITERAL()
	{
		EnterRule_FLOAT_POINT_LITERAL();
		EnterRule("FLOAT_POINT_LITERAL", 129);
		TraceIn("FLOAT_POINT_LITERAL", 129);
		try
		{
			int _type = FLOAT_POINT_LITERAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:2: ( DEC_BASED_INTEGER ( '.' ( DIGIT )+ ) ( EXPONENT )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:4: DEC_BASED_INTEGER ( '.' ( DIGIT )+ ) ( EXPONENT )?
			{
			DebugLocation(1748, 4);
			mDEC_BASED_INTEGER(); if (state.failed) return;
			DebugLocation(1748, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:22: ( '.' ( DIGIT )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:23: '.' ( DIGIT )+
			{
			DebugLocation(1748, 23);
			Match('.'); if (state.failed) return;
			DebugLocation(1748, 27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:27: ( DIGIT )+
			int cnt5=0;
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if (((LA5_0>='0' && LA5_0<='9')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1748, 27);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt5 >= 1)
						goto loop5;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee5 = new EarlyExitException( 5, input );
					DebugRecognitionException(eee5);
					throw eee5;
				}
				cnt5++;
			}
			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			DebugLocation(1748, 37);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:37: ( EXPONENT )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0=='E'||LA6_0=='e'))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1748:37: EXPONENT
				{
				DebugLocation(1748, 37);
				mEXPONENT(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT_POINT_LITERAL", 129);
			LeaveRule("FLOAT_POINT_LITERAL", 129);
			LeaveRule_FLOAT_POINT_LITERAL();
		}
	}
	// $ANTLR end "FLOAT_POINT_LITERAL"

	partial void EnterRule_APOSTROPHE();
	partial void LeaveRule_APOSTROPHE();

	// $ANTLR start "APOSTROPHE"
	[GrammarRule("APOSTROPHE")]
	private void mAPOSTROPHE()
	{
		EnterRule_APOSTROPHE();
		EnterRule("APOSTROPHE", 130);
		TraceIn("APOSTROPHE", 130);
		try
		{
			int _type = APOSTROPHE;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1769:5: ( '\\'' |{...}? => ( '\\'' ( ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )? ) )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0=='\''))
			{
				int LA8_1 = input.LA(2);

				if ((!((( state.type != BASIC_IDENTIFIER && state.type != EXTENDED_IDENTIFIER )))))
				{
					alt8 = 1;
				}
				else if ((( state.type != BASIC_IDENTIFIER && state.type != EXTENDED_IDENTIFIER )))
				{
					alt8 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 8, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1769:11: '\\''
				{
				DebugLocation(1769, 11);
				Match('\''); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1770:11: {...}? => ( '\\'' ( ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )? )
				{
				DebugLocation(1770, 11);
				if (!(( state.type != BASIC_IDENTIFIER && state.type != EXTENDED_IDENTIFIER )))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "APOSTROPHE", " state.type != BASIC_IDENTIFIER && state.type != EXTENDED_IDENTIFIER ");
				}
				DebugLocation(1771, 13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1771:13: ( '\\'' ( ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )? )
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1771:15: '\\'' ( ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )?
				{
				DebugLocation(1771, 15);
				Match('\''); if (state.failed) return;
				DebugLocation(1772, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1772:17: ( ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if (((LA7_0>=' ' && LA7_0<='~')||(LA7_0>='\u00A0' && LA7_0<='\u00FF')) && (EvaluatePredicate(synpred1_VhdlAntlr_fragment)))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1773:21: ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )=> ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\''
					{
					DebugLocation(1774, 25);
					input.Consume();
					state.failed=false;
					DebugLocation(1774, 67);
					Match('\''); if (state.failed) return;
					DebugLocation(1775, 25);
					if (state.backtracking == 0)
					{
						 _type = CHARACTER_LITERAL; 
					}

					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("APOSTROPHE", 130);
			LeaveRule("APOSTROPHE", 130);
			LeaveRule_APOSTROPHE();
		}
	}
	// $ANTLR end "APOSTROPHE"

	partial void EnterRule_STRING_LITERAL();
	partial void LeaveRule_STRING_LITERAL();

	// $ANTLR start "STRING_LITERAL"
	[GrammarRule("STRING_LITERAL")]
	private void mSTRING_LITERAL()
	{
		EnterRule_STRING_LITERAL();
		EnterRule("STRING_LITERAL", 131);
		TraceIn("STRING_LITERAL", 131);
		try
		{
			int _type = STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:5: ( '\\\"' ( '\\\"\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER )* '\\\"' | '%' ( '%%' | '\\\\' | GRAPHIC_CHARACTER )* '%' )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0=='\"'))
			{
				alt11 = 1;
			}
			else if ((LA11_0=='%'))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:9: '\\\"' ( '\\\"\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER )* '\\\"'
				{
				DebugLocation(1782, 9);
				Match('\"'); if (state.failed) return;
				DebugLocation(1782, 14);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:14: ( '\\\"\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=5;
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case '\"':
						{
						int LA9_1 = input.LA(2);

						if ((LA9_1=='\"'))
						{
							alt9 = 1;
						}


						}
						break;
					case '\\':
						{
						alt9 = 2;
						}
						break;
					case '%':
						{
						alt9 = 3;
						}
						break;
					case ' ':
					case '!':
					case '#':
					case '$':
					case '&':
					case '\'':
					case '(':
					case ')':
					case '*':
					case '+':
					case ',':
					case '-':
					case '.':
					case '/':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					case ':':
					case ';':
					case '<':
					case '=':
					case '>':
					case '?':
					case '@':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
					case 'H':
					case 'I':
					case 'J':
					case 'K':
					case 'L':
					case 'M':
					case 'N':
					case 'O':
					case 'P':
					case 'Q':
					case 'R':
					case 'S':
					case 'T':
					case 'U':
					case 'V':
					case 'W':
					case 'X':
					case 'Y':
					case 'Z':
					case '[':
					case ']':
					case '^':
					case '_':
					case '`':
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'h':
					case 'i':
					case 'j':
					case 'k':
					case 'l':
					case 'm':
					case 'n':
					case 'o':
					case 'p':
					case 'q':
					case 'r':
					case 's':
					case 't':
					case 'u':
					case 'v':
					case 'w':
					case 'x':
					case 'y':
					case 'z':
					case '{':
					case '|':
					case '}':
					case '~':
					case '\u00A0':
					case '\u00A1':
					case '\u00A2':
					case '\u00A3':
					case '\u00A4':
					case '\u00A5':
					case '\u00A6':
					case '\u00A7':
					case '\u00A8':
					case '\u00A9':
					case '\u00AA':
					case '\u00AB':
					case '\u00AC':
					case '\u00AD':
					case '\u00AE':
					case '\u00AF':
					case '\u00B0':
					case '\u00B1':
					case '\u00B2':
					case '\u00B3':
					case '\u00B4':
					case '\u00B5':
					case '\u00B6':
					case '\u00B7':
					case '\u00B8':
					case '\u00B9':
					case '\u00BA':
					case '\u00BB':
					case '\u00BC':
					case '\u00BD':
					case '\u00BE':
					case '\u00BF':
					case '\u00C0':
					case '\u00C1':
					case '\u00C2':
					case '\u00C3':
					case '\u00C4':
					case '\u00C5':
					case '\u00C6':
					case '\u00C7':
					case '\u00C8':
					case '\u00C9':
					case '\u00CA':
					case '\u00CB':
					case '\u00CC':
					case '\u00CD':
					case '\u00CE':
					case '\u00CF':
					case '\u00D0':
					case '\u00D1':
					case '\u00D2':
					case '\u00D3':
					case '\u00D4':
					case '\u00D5':
					case '\u00D6':
					case '\u00D7':
					case '\u00D8':
					case '\u00D9':
					case '\u00DA':
					case '\u00DB':
					case '\u00DC':
					case '\u00DD':
					case '\u00DE':
					case '\u00DF':
					case '\u00E0':
					case '\u00E1':
					case '\u00E2':
					case '\u00E3':
					case '\u00E4':
					case '\u00E5':
					case '\u00E6':
					case '\u00E7':
					case '\u00E8':
					case '\u00E9':
					case '\u00EA':
					case '\u00EB':
					case '\u00EC':
					case '\u00ED':
					case '\u00EE':
					case '\u00EF':
					case '\u00F0':
					case '\u00F1':
					case '\u00F2':
					case '\u00F3':
					case '\u00F4':
					case '\u00F5':
					case '\u00F6':
					case '\u00F7':
					case '\u00F8':
					case '\u00F9':
					case '\u00FA':
					case '\u00FB':
					case '\u00FC':
					case '\u00FD':
					case '\u00FE':
					case '\u00FF':
						{
						alt9 = 4;
						}
						break;
					}

					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:16: '\\\"\\\"'
						{
						DebugLocation(1782, 16);
						Match("\"\""); if (state.failed) return;


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:25: '\\\\'
						{
						DebugLocation(1782, 25);
						Match('\\'); if (state.failed) return;

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:32: '%'
						{
						DebugLocation(1782, 32);
						Match('%'); if (state.failed) return;

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1782:38: GRAPHIC_CHARACTER
						{
						DebugLocation(1782, 38);
						mGRAPHIC_CHARACTER(); if (state.failed) return;

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }

				DebugLocation(1782, 59);
				Match('\"'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1783:9: '%' ( '%%' | '\\\\' | GRAPHIC_CHARACTER )* '%'
				{
				DebugLocation(1783, 9);
				Match('%'); if (state.failed) return;
				DebugLocation(1783, 14);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1783:14: ( '%%' | '\\\\' | GRAPHIC_CHARACTER )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=4;
					try { DebugEnterDecision(10, false);
					switch (input.LA(1))
					{
					case '%':
						{
						int LA10_1 = input.LA(2);

						if ((LA10_1=='%'))
						{
							alt10 = 1;
						}


						}
						break;
					case '\\':
						{
						alt10 = 2;
						}
						break;
					case ' ':
					case '!':
					case '#':
					case '$':
					case '&':
					case '\'':
					case '(':
					case ')':
					case '*':
					case '+':
					case ',':
					case '-':
					case '.':
					case '/':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					case ':':
					case ';':
					case '<':
					case '=':
					case '>':
					case '?':
					case '@':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
					case 'H':
					case 'I':
					case 'J':
					case 'K':
					case 'L':
					case 'M':
					case 'N':
					case 'O':
					case 'P':
					case 'Q':
					case 'R':
					case 'S':
					case 'T':
					case 'U':
					case 'V':
					case 'W':
					case 'X':
					case 'Y':
					case 'Z':
					case '[':
					case ']':
					case '^':
					case '_':
					case '`':
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'h':
					case 'i':
					case 'j':
					case 'k':
					case 'l':
					case 'm':
					case 'n':
					case 'o':
					case 'p':
					case 'q':
					case 'r':
					case 's':
					case 't':
					case 'u':
					case 'v':
					case 'w':
					case 'x':
					case 'y':
					case 'z':
					case '{':
					case '|':
					case '}':
					case '~':
					case '\u00A0':
					case '\u00A1':
					case '\u00A2':
					case '\u00A3':
					case '\u00A4':
					case '\u00A5':
					case '\u00A6':
					case '\u00A7':
					case '\u00A8':
					case '\u00A9':
					case '\u00AA':
					case '\u00AB':
					case '\u00AC':
					case '\u00AD':
					case '\u00AE':
					case '\u00AF':
					case '\u00B0':
					case '\u00B1':
					case '\u00B2':
					case '\u00B3':
					case '\u00B4':
					case '\u00B5':
					case '\u00B6':
					case '\u00B7':
					case '\u00B8':
					case '\u00B9':
					case '\u00BA':
					case '\u00BB':
					case '\u00BC':
					case '\u00BD':
					case '\u00BE':
					case '\u00BF':
					case '\u00C0':
					case '\u00C1':
					case '\u00C2':
					case '\u00C3':
					case '\u00C4':
					case '\u00C5':
					case '\u00C6':
					case '\u00C7':
					case '\u00C8':
					case '\u00C9':
					case '\u00CA':
					case '\u00CB':
					case '\u00CC':
					case '\u00CD':
					case '\u00CE':
					case '\u00CF':
					case '\u00D0':
					case '\u00D1':
					case '\u00D2':
					case '\u00D3':
					case '\u00D4':
					case '\u00D5':
					case '\u00D6':
					case '\u00D7':
					case '\u00D8':
					case '\u00D9':
					case '\u00DA':
					case '\u00DB':
					case '\u00DC':
					case '\u00DD':
					case '\u00DE':
					case '\u00DF':
					case '\u00E0':
					case '\u00E1':
					case '\u00E2':
					case '\u00E3':
					case '\u00E4':
					case '\u00E5':
					case '\u00E6':
					case '\u00E7':
					case '\u00E8':
					case '\u00E9':
					case '\u00EA':
					case '\u00EB':
					case '\u00EC':
					case '\u00ED':
					case '\u00EE':
					case '\u00EF':
					case '\u00F0':
					case '\u00F1':
					case '\u00F2':
					case '\u00F3':
					case '\u00F4':
					case '\u00F5':
					case '\u00F6':
					case '\u00F7':
					case '\u00F8':
					case '\u00F9':
					case '\u00FA':
					case '\u00FB':
					case '\u00FC':
					case '\u00FD':
					case '\u00FE':
					case '\u00FF':
						{
						alt10 = 3;
						}
						break;
					}

					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1783:16: '%%'
						{
						DebugLocation(1783, 16);
						Match("%%"); if (state.failed) return;


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1783:23: '\\\\'
						{
						DebugLocation(1783, 23);
						Match('\\'); if (state.failed) return;

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1783:30: GRAPHIC_CHARACTER
						{
						DebugLocation(1783, 30);
						mGRAPHIC_CHARACTER(); if (state.failed) return;

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(1783, 51);
				Match('%'); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL", 131);
			LeaveRule("STRING_LITERAL", 131);
			LeaveRule_STRING_LITERAL();
		}
	}
	// $ANTLR end "STRING_LITERAL"

	partial void EnterRule_BIT_STRING_LITERAL_BINARY();
	partial void LeaveRule_BIT_STRING_LITERAL_BINARY();

	// $ANTLR start "BIT_STRING_LITERAL_BINARY"
	[GrammarRule("BIT_STRING_LITERAL_BINARY")]
	private void mBIT_STRING_LITERAL_BINARY()
	{
		EnterRule_BIT_STRING_LITERAL_BINARY();
		EnterRule("BIT_STRING_LITERAL_BINARY", 132);
		TraceIn("BIT_STRING_LITERAL_BINARY", 132);
		try
		{
			int _type = BIT_STRING_LITERAL_BINARY;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1787:5: ( 'b' '\\\"' ( '1' | '0' | '_' )+ '\\\"' | 'b' '%' ( '1' | '0' | '_' )+ '%' )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0=='b'))
			{
				int LA14_1 = input.LA(2);

				if ((LA14_1=='\"'))
				{
					alt14 = 1;
				}
				else if ((LA14_1=='%'))
				{
					alt14 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 14, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1787:9: 'b' '\\\"' ( '1' | '0' | '_' )+ '\\\"'
				{
				DebugLocation(1787, 9);
				Match('b'); if (state.failed) return;
				DebugLocation(1787, 13);
				Match('\"'); if (state.failed) return;
				DebugLocation(1787, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1787:18: ( '1' | '0' | '_' )+
				int cnt12=0;
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if (((LA12_0>='0' && LA12_0<='1')||LA12_0=='_'))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch (alt12)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1787, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt12 >= 1)
							goto loop12;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee12 = new EarlyExitException( 12, input );
						DebugRecognitionException(eee12);
						throw eee12;
					}
					cnt12++;
				}
				loop12:
					;

				} finally { DebugExitSubRule(12); }

				DebugLocation(1787, 37);
				Match('\"'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1788:9: 'b' '%' ( '1' | '0' | '_' )+ '%'
				{
				DebugLocation(1788, 9);
				Match('b'); if (state.failed) return;
				DebugLocation(1788, 13);
				Match('%'); if (state.failed) return;
				DebugLocation(1788, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1788:18: ( '1' | '0' | '_' )+
				int cnt13=0;
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if (((LA13_0>='0' && LA13_0<='1')||LA13_0=='_'))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1788, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt13 >= 1)
							goto loop13;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee13 = new EarlyExitException( 13, input );
						DebugRecognitionException(eee13);
						throw eee13;
					}
					cnt13++;
				}
				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(1788, 37);
				Match('%'); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_STRING_LITERAL_BINARY", 132);
			LeaveRule("BIT_STRING_LITERAL_BINARY", 132);
			LeaveRule_BIT_STRING_LITERAL_BINARY();
		}
	}
	// $ANTLR end "BIT_STRING_LITERAL_BINARY"

	partial void EnterRule_BIT_STRING_LITERAL_OCTAL();
	partial void LeaveRule_BIT_STRING_LITERAL_OCTAL();

	// $ANTLR start "BIT_STRING_LITERAL_OCTAL"
	[GrammarRule("BIT_STRING_LITERAL_OCTAL")]
	private void mBIT_STRING_LITERAL_OCTAL()
	{
		EnterRule_BIT_STRING_LITERAL_OCTAL();
		EnterRule("BIT_STRING_LITERAL_OCTAL", 133);
		TraceIn("BIT_STRING_LITERAL_OCTAL", 133);
		try
		{
			int _type = BIT_STRING_LITERAL_OCTAL;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1792:5: ( 'o' '\\\"' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '\\\"' | 'o' '%' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '%' )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0=='o'))
			{
				int LA17_1 = input.LA(2);

				if ((LA17_1=='\"'))
				{
					alt17 = 1;
				}
				else if ((LA17_1=='%'))
				{
					alt17 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1792:9: 'o' '\\\"' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '\\\"'
				{
				DebugLocation(1792, 9);
				Match('o'); if (state.failed) return;
				DebugLocation(1792, 13);
				Match('\"'); if (state.failed) return;
				DebugLocation(1792, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1792:18: ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
				int cnt15=0;
				try { DebugEnterSubRule(15);
				while (true)
				{
					int alt15=2;
					try { DebugEnterDecision(15, false);
					int LA15_0 = input.LA(1);

					if (((LA15_0>='0' && LA15_0<='7')||LA15_0=='_'))
					{
						alt15 = 1;
					}


					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1792, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt15 >= 1)
							goto loop15;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee15 = new EarlyExitException( 15, input );
						DebugRecognitionException(eee15);
						throw eee15;
					}
					cnt15++;
				}
				loop15:
					;

				} finally { DebugExitSubRule(15); }

				DebugLocation(1792, 67);
				Match('\"'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1793:9: 'o' '%' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '%'
				{
				DebugLocation(1793, 9);
				Match('o'); if (state.failed) return;
				DebugLocation(1793, 13);
				Match('%'); if (state.failed) return;
				DebugLocation(1793, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1793:18: ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
				int cnt16=0;
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_0 = input.LA(1);

					if (((LA16_0>='0' && LA16_0<='7')||LA16_0=='_'))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch (alt16)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1793, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt16 >= 1)
							goto loop16;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee16 = new EarlyExitException( 16, input );
						DebugRecognitionException(eee16);
						throw eee16;
					}
					cnt16++;
				}
				loop16:
					;

				} finally { DebugExitSubRule(16); }

				DebugLocation(1793, 67);
				Match('%'); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_STRING_LITERAL_OCTAL", 133);
			LeaveRule("BIT_STRING_LITERAL_OCTAL", 133);
			LeaveRule_BIT_STRING_LITERAL_OCTAL();
		}
	}
	// $ANTLR end "BIT_STRING_LITERAL_OCTAL"

	partial void EnterRule_BIT_STRING_LITERAL_HEX();
	partial void LeaveRule_BIT_STRING_LITERAL_HEX();

	// $ANTLR start "BIT_STRING_LITERAL_HEX"
	[GrammarRule("BIT_STRING_LITERAL_HEX")]
	private void mBIT_STRING_LITERAL_HEX()
	{
		EnterRule_BIT_STRING_LITERAL_HEX();
		EnterRule("BIT_STRING_LITERAL_HEX", 134);
		TraceIn("BIT_STRING_LITERAL_HEX", 134);
		try
		{
			int _type = BIT_STRING_LITERAL_HEX;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1797:5: ( 'x' '\\\"' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '\\\"' | 'x' '%' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '%' )
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0=='x'))
			{
				int LA20_1 = input.LA(2);

				if ((LA20_1=='\"'))
				{
					alt20 = 1;
				}
				else if ((LA20_1=='%'))
				{
					alt20 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1797:9: 'x' '\\\"' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '\\\"'
				{
				DebugLocation(1797, 9);
				Match('x'); if (state.failed) return;
				DebugLocation(1797, 13);
				Match('\"'); if (state.failed) return;
				DebugLocation(1797, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1797:18: ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
				int cnt18=0;
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_0 = input.LA(1);

					if (((LA18_0>='0' && LA18_0<='9')||(LA18_0>='A' && LA18_0<='F')||LA18_0=='_'||(LA18_0>='a' && LA18_0<='f')))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1797, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt18 >= 1)
							goto loop18;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee18 = new EarlyExitException( 18, input );
						DebugRecognitionException(eee18);
						throw eee18;
					}
					cnt18++;
				}
				loop18:
					;

				} finally { DebugExitSubRule(18); }

				DebugLocation(1797, 142);
				Match('\"'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1798:9: 'x' '%' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '%'
				{
				DebugLocation(1798, 9);
				Match('x'); if (state.failed) return;
				DebugLocation(1798, 13);
				Match('%'); if (state.failed) return;
				DebugLocation(1798, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1798:18: ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
				int cnt19=0;
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if (((LA19_0>='0' && LA19_0<='9')||(LA19_0>='A' && LA19_0<='F')||LA19_0=='_'||(LA19_0>='a' && LA19_0<='f')))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1798, 18);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt19 >= 1)
							goto loop19;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee19 = new EarlyExitException( 19, input );
						DebugRecognitionException(eee19);
						throw eee19;
					}
					cnt19++;
				}
				loop19:
					;

				} finally { DebugExitSubRule(19); }

				DebugLocation(1798, 142);
				Match('%'); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BIT_STRING_LITERAL_HEX", 134);
			LeaveRule("BIT_STRING_LITERAL_HEX", 134);
			LeaveRule_BIT_STRING_LITERAL_HEX();
		}
	}
	// $ANTLR end "BIT_STRING_LITERAL_HEX"

	partial void EnterRule_BINANRY_BASED_INTEGER();
	partial void LeaveRule_BINANRY_BASED_INTEGER();

	// $ANTLR start "BINANRY_BASED_INTEGER"
	[GrammarRule("BINANRY_BASED_INTEGER")]
	private void mBINANRY_BASED_INTEGER()
	{
		EnterRule_BINANRY_BASED_INTEGER();
		EnterRule("BINANRY_BASED_INTEGER", 135);
		TraceIn("BINANRY_BASED_INTEGER", 135);
		try
		{
			int _type = BINANRY_BASED_INTEGER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1804:2: ( '2' '#' ( '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1805:2: '2' '#' ( '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )?
			{
			DebugLocation(1805, 2);
			Match('2'); if (state.failed) return;
			DebugLocation(1805, 6);
			Match('#'); if (state.failed) return;
			DebugLocation(1805, 10);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1805:10: ( '1' | '0' | '_' )+
			int cnt21=0;
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if (((LA21_0>='0' && LA21_0<='1')||LA21_0=='_'))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1805, 10);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt21 >= 1)
						goto loop21;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee21 = new EarlyExitException( 21, input );
					DebugRecognitionException(eee21);
					throw eee21;
				}
				cnt21++;
			}
			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(1805, 29);
			Match('#'); if (state.failed) return;
			DebugLocation(1805, 33);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1805:33: ( DEC_BASED_INTEGER )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if (((LA22_0>='0' && LA22_0<='9')))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1805:34: DEC_BASED_INTEGER
				{
				DebugLocation(1805, 34);
				mDEC_BASED_INTEGER(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(22); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BINANRY_BASED_INTEGER", 135);
			LeaveRule("BINANRY_BASED_INTEGER", 135);
			LeaveRule_BINANRY_BASED_INTEGER();
		}
	}
	// $ANTLR end "BINANRY_BASED_INTEGER"

	partial void EnterRule_OCTAL_BASED_INTEGER();
	partial void LeaveRule_OCTAL_BASED_INTEGER();

	// $ANTLR start "OCTAL_BASED_INTEGER"
	[GrammarRule("OCTAL_BASED_INTEGER")]
	private void mOCTAL_BASED_INTEGER()
	{
		EnterRule_OCTAL_BASED_INTEGER();
		EnterRule("OCTAL_BASED_INTEGER", 136);
		TraceIn("OCTAL_BASED_INTEGER", 136);
		try
		{
			int _type = OCTAL_BASED_INTEGER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1811:2: ( '8' '#' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1812:2: '8' '#' ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )?
			{
			DebugLocation(1812, 2);
			Match('8'); if (state.failed) return;
			DebugLocation(1812, 6);
			Match('#'); if (state.failed) return;
			DebugLocation(1812, 10);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1812:10: ( '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
			int cnt23=0;
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if (((LA23_0>='0' && LA23_0<='7')||LA23_0=='_'))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1812, 10);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt23 >= 1)
						goto loop23;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee23 = new EarlyExitException( 23, input );
					DebugRecognitionException(eee23);
					throw eee23;
				}
				cnt23++;
			}
			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(1812, 59);
			Match('#'); if (state.failed) return;
			DebugLocation(1812, 63);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1812:63: ( DEC_BASED_INTEGER )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if (((LA24_0>='0' && LA24_0<='9')))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1812:64: DEC_BASED_INTEGER
				{
				DebugLocation(1812, 64);
				mDEC_BASED_INTEGER(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(24); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OCTAL_BASED_INTEGER", 136);
			LeaveRule("OCTAL_BASED_INTEGER", 136);
			LeaveRule_OCTAL_BASED_INTEGER();
		}
	}
	// $ANTLR end "OCTAL_BASED_INTEGER"

	partial void EnterRule_HEXA_BASED_INTEGER();
	partial void LeaveRule_HEXA_BASED_INTEGER();

	// $ANTLR start "HEXA_BASED_INTEGER"
	[GrammarRule("HEXA_BASED_INTEGER")]
	private void mHEXA_BASED_INTEGER()
	{
		EnterRule_HEXA_BASED_INTEGER();
		EnterRule("HEXA_BASED_INTEGER", 137);
		TraceIn("HEXA_BASED_INTEGER", 137);
		try
		{
			int _type = HEXA_BASED_INTEGER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1817:2: ( '16' '#' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1818:2: '16' '#' ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+ '#' ( DEC_BASED_INTEGER )?
			{
			DebugLocation(1818, 2);
			Match("16"); if (state.failed) return;

			DebugLocation(1818, 7);
			Match('#'); if (state.failed) return;
			DebugLocation(1818, 11);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1818:11: ( 'f' | 'e' | 'd' | 'c' | 'b' | 'a' | 'F' | 'E' | 'D' | 'C' | 'B' | 'A' | '9' | '8' | '7' | '6' | '5' | '4' | '3' | '2' | '1' | '0' | '_' )+
			int cnt25=0;
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if (((LA25_0>='0' && LA25_0<='9')||(LA25_0>='A' && LA25_0<='F')||LA25_0=='_'||(LA25_0>='a' && LA25_0<='f')))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
					{
					DebugLocation(1818, 11);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt25 >= 1)
						goto loop25;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee25 = new EarlyExitException( 25, input );
					DebugRecognitionException(eee25);
					throw eee25;
				}
				cnt25++;
			}
			loop25:
				;

			} finally { DebugExitSubRule(25); }

			DebugLocation(1818, 135);
			Match('#'); if (state.failed) return;
			DebugLocation(1818, 139);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1818:139: ( DEC_BASED_INTEGER )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if (((LA26_0>='0' && LA26_0<='9')))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1818:140: DEC_BASED_INTEGER
				{
				DebugLocation(1818, 140);
				mDEC_BASED_INTEGER(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(26); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEXA_BASED_INTEGER", 137);
			LeaveRule("HEXA_BASED_INTEGER", 137);
			LeaveRule_HEXA_BASED_INTEGER();
		}
	}
	// $ANTLR end "HEXA_BASED_INTEGER"

	partial void EnterRule_DEC_BASED_INTEGER();
	partial void LeaveRule_DEC_BASED_INTEGER();

	// $ANTLR start "DEC_BASED_INTEGER"
	[GrammarRule("DEC_BASED_INTEGER")]
	private void mDEC_BASED_INTEGER()
	{
		EnterRule_DEC_BASED_INTEGER();
		EnterRule("DEC_BASED_INTEGER", 138);
		TraceIn("DEC_BASED_INTEGER", 138);
		try
		{
			int _type = DEC_BASED_INTEGER;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1823:2: ( DIGIT | ( '1' .. '9' ) ( DIGIT | '_' )+ )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if (((LA28_0>='1' && LA28_0<='9')))
			{
				int LA28_1 = input.LA(2);

				if (((LA28_1>='0' && LA28_1<='9')||LA28_1=='_'))
				{
					alt28 = 2;
				}
				else
				{
					alt28 = 1;
				}
			}
			else if ((LA28_0=='0'))
			{
				alt28 = 1;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1823:6: DIGIT
				{
				DebugLocation(1823, 6);
				mDIGIT(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1824:6: ( '1' .. '9' ) ( DIGIT | '_' )+
				{
				DebugLocation(1824, 6);
				input.Consume();
				state.failed=false;
				DebugLocation(1824, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1824:17: ( DIGIT | '_' )+
				int cnt27=0;
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if (((LA27_0>='0' && LA27_0<='9')||LA27_0=='_'))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
						{
						DebugLocation(1824, 17);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt27 >= 1)
							goto loop27;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee27 = new EarlyExitException( 27, input );
						DebugRecognitionException(eee27);
						throw eee27;
					}
					cnt27++;
				}
				loop27:
					;

				} finally { DebugExitSubRule(27); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEC_BASED_INTEGER", 138);
			LeaveRule("DEC_BASED_INTEGER", 138);
			LeaveRule_DEC_BASED_INTEGER();
		}
	}
	// $ANTLR end "DEC_BASED_INTEGER"

	partial void EnterRule_EXPONENT();
	partial void LeaveRule_EXPONENT();

	// $ANTLR start "EXPONENT"
	[GrammarRule("EXPONENT")]
	private void mEXPONENT()
	{
		EnterRule_EXPONENT();
		EnterRule("EXPONENT", 139);
		TraceIn("EXPONENT", 139);
		try
		{
			int _type = EXPONENT;
			int _channel = DefaultTokenChannel;
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1829:5: ( ( 'e' | 'E' ) ( '-' | '+' )? DEC_BASED_INTEGER )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1829:9: ( 'e' | 'E' ) ( '-' | '+' )? DEC_BASED_INTEGER
			{
			DebugLocation(1829, 9);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(1829, 19);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1829:19: ( '-' | '+' )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0=='+'||LA29_0=='-'))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
				{
				DebugLocation(1829, 19);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(1829, 30);
			mDEC_BASED_INTEGER(); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXPONENT", 139);
			LeaveRule("EXPONENT", 139);
			LeaveRule_EXPONENT();
		}
	}
	// $ANTLR end "EXPONENT"

	partial void EnterRule_LETTER_OR_DIGIT();
	partial void LeaveRule_LETTER_OR_DIGIT();

	// $ANTLR start "LETTER_OR_DIGIT"
	[GrammarRule("LETTER_OR_DIGIT")]
	private void mLETTER_OR_DIGIT()
	{
		EnterRule_LETTER_OR_DIGIT();
		EnterRule("LETTER_OR_DIGIT", 140);
		TraceIn("LETTER_OR_DIGIT", 140);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1835:5: ( LETTER | DIGIT )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1835, 5);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z')||(input.LA(1)>='\u00C0' && input.LA(1)<='\u00D6')||(input.LA(1)>='\u00D8' && input.LA(1)<='\u00F6')||(input.LA(1)>='\u00F8' && input.LA(1)<='\u00FF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("LETTER_OR_DIGIT", 140);
			LeaveRule("LETTER_OR_DIGIT", 140);
			LeaveRule_LETTER_OR_DIGIT();
		}
	}
	// $ANTLR end "LETTER_OR_DIGIT"

	partial void EnterRule_LETTER();
	partial void LeaveRule_LETTER();

	// $ANTLR start "LETTER"
	[GrammarRule("LETTER")]
	private void mLETTER()
	{
		EnterRule_LETTER();
		EnterRule("LETTER", 141);
		TraceIn("LETTER", 141);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1841:5: ( UPPER_CASE_LETTER | LOWER_CASE_LETTER )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1841, 5);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z')||(input.LA(1)>='\u00C0' && input.LA(1)<='\u00D6')||(input.LA(1)>='\u00D8' && input.LA(1)<='\u00F6')||(input.LA(1)>='\u00F8' && input.LA(1)<='\u00FF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("LETTER", 141);
			LeaveRule("LETTER", 141);
			LeaveRule_LETTER();
		}
	}
	// $ANTLR end "LETTER"

	partial void EnterRule_GRAPHIC_CHARACTER();
	partial void LeaveRule_GRAPHIC_CHARACTER();

	// $ANTLR start "GRAPHIC_CHARACTER"
	[GrammarRule("GRAPHIC_CHARACTER")]
	private void mGRAPHIC_CHARACTER()
	{
		EnterRule_GRAPHIC_CHARACTER();
		EnterRule("GRAPHIC_CHARACTER", 142);
		TraceIn("GRAPHIC_CHARACTER", 142);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1848:5: ( UPPER_CASE_LETTER | DIGIT | SPECIAL_CHARACTER | SPACE_CHARACTER | LOWER_CASE_LETTER | OTHER_SPECIAL_CHARACTER )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1848, 5);
			if ((input.LA(1)>=' ' && input.LA(1)<='!')||(input.LA(1)>='#' && input.LA(1)<='$')||(input.LA(1)>='&' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='~')||(input.LA(1)>='\u00A0' && input.LA(1)<='\u00FF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("GRAPHIC_CHARACTER", 142);
			LeaveRule("GRAPHIC_CHARACTER", 142);
			LeaveRule_GRAPHIC_CHARACTER();
		}
	}
	// $ANTLR end "GRAPHIC_CHARACTER"

	partial void EnterRule_UPPER_CASE_LETTER();
	partial void LeaveRule_UPPER_CASE_LETTER();

	// $ANTLR start "UPPER_CASE_LETTER"
	[GrammarRule("UPPER_CASE_LETTER")]
	private void mUPPER_CASE_LETTER()
	{
		EnterRule_UPPER_CASE_LETTER();
		EnterRule("UPPER_CASE_LETTER", 143);
		TraceIn("UPPER_CASE_LETTER", 143);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1858:5: ( 'A' .. 'Z' | '\\u00c0' .. '\\u00d6' | '\\u00d8' .. '\\u00de' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1858, 5);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='\u00C0' && input.LA(1)<='\u00D6')||(input.LA(1)>='\u00D8' && input.LA(1)<='\u00DE'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("UPPER_CASE_LETTER", 143);
			LeaveRule("UPPER_CASE_LETTER", 143);
			LeaveRule_UPPER_CASE_LETTER();
		}
	}
	// $ANTLR end "UPPER_CASE_LETTER"

	partial void EnterRule_LOWER_CASE_LETTER();
	partial void LeaveRule_LOWER_CASE_LETTER();

	// $ANTLR start "LOWER_CASE_LETTER"
	[GrammarRule("LOWER_CASE_LETTER")]
	private void mLOWER_CASE_LETTER()
	{
		EnterRule_LOWER_CASE_LETTER();
		EnterRule("LOWER_CASE_LETTER", 144);
		TraceIn("LOWER_CASE_LETTER", 144);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1863:5: ( 'a' .. 'z' | '\\u00df' .. '\\u00f6' | '\\u00f8' .. '\\u00ff' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1863, 5);
			if ((input.LA(1)>='a' && input.LA(1)<='z')||(input.LA(1)>='\u00DF' && input.LA(1)<='\u00F6')||(input.LA(1)>='\u00F8' && input.LA(1)<='\u00FF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("LOWER_CASE_LETTER", 144);
			LeaveRule("LOWER_CASE_LETTER", 144);
			LeaveRule_LOWER_CASE_LETTER();
		}
	}
	// $ANTLR end "LOWER_CASE_LETTER"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 145);
		TraceIn("DIGIT", 145);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1868:5: ( '0' .. '9' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1868, 5);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 145);
			LeaveRule("DIGIT", 145);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_SPECIAL_CHARACTER();
	partial void LeaveRule_SPECIAL_CHARACTER();

	// $ANTLR start "SPECIAL_CHARACTER"
	[GrammarRule("SPECIAL_CHARACTER")]
	private void mSPECIAL_CHARACTER()
	{
		EnterRule_SPECIAL_CHARACTER();
		EnterRule("SPECIAL_CHARACTER", 146);
		TraceIn("SPECIAL_CHARACTER", 146);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1874:5: ( '#' | '&' | '\\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '[' | ']' | '_' | '|' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1874, 5);
			if (input.LA(1)=='#'||(input.LA(1)>='&' && input.LA(1)<='/')||(input.LA(1)>=':' && input.LA(1)<='>')||input.LA(1)=='['||input.LA(1)==']'||input.LA(1)=='_'||input.LA(1)=='|')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("SPECIAL_CHARACTER", 146);
			LeaveRule("SPECIAL_CHARACTER", 146);
			LeaveRule_SPECIAL_CHARACTER();
		}
	}
	// $ANTLR end "SPECIAL_CHARACTER"

	partial void EnterRule_SPACE_CHARACTER();
	partial void LeaveRule_SPACE_CHARACTER();

	// $ANTLR start "SPACE_CHARACTER"
	[GrammarRule("SPACE_CHARACTER")]
	private void mSPACE_CHARACTER()
	{
		EnterRule_SPACE_CHARACTER();
		EnterRule("SPACE_CHARACTER", 147);
		TraceIn("SPACE_CHARACTER", 147);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1880:5: ( ' ' | '\\u00a0' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1880, 5);
			if (input.LA(1)==' '||input.LA(1)=='\u00A0')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("SPACE_CHARACTER", 147);
			LeaveRule("SPACE_CHARACTER", 147);
			LeaveRule_SPACE_CHARACTER();
		}
	}
	// $ANTLR end "SPACE_CHARACTER"

	partial void EnterRule_OTHER_SPECIAL_CHARACTER();
	partial void LeaveRule_OTHER_SPECIAL_CHARACTER();

	// $ANTLR start "OTHER_SPECIAL_CHARACTER"
	[GrammarRule("OTHER_SPECIAL_CHARACTER")]
	private void mOTHER_SPECIAL_CHARACTER()
	{
		EnterRule_OTHER_SPECIAL_CHARACTER();
		EnterRule("OTHER_SPECIAL_CHARACTER", 148);
		TraceIn("OTHER_SPECIAL_CHARACTER", 148);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1886:5: ( '!' | '$' | '@' | '?' | '^' | '`' | '{' | '}' | '~' | '\\u00a1' .. '\\u00bf' | '\\u00d7' | '\\u00f7' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			DebugLocation(1886, 5);
			if (input.LA(1)=='!'||input.LA(1)=='$'||(input.LA(1)>='?' && input.LA(1)<='@')||input.LA(1)=='^'||input.LA(1)=='`'||input.LA(1)=='{'||(input.LA(1)>='}' && input.LA(1)<='~')||(input.LA(1)>='\u00A1' && input.LA(1)<='\u00BF')||input.LA(1)=='\u00D7'||input.LA(1)=='\u00F7')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("OTHER_SPECIAL_CHARACTER", 148);
			LeaveRule("OTHER_SPECIAL_CHARACTER", 148);
			LeaveRule_OTHER_SPECIAL_CHARACTER();
		}
	}
	// $ANTLR end "OTHER_SPECIAL_CHARACTER"

	partial void EnterRule_CHARACTER_LITERAL();
	partial void LeaveRule_CHARACTER_LITERAL();

	// $ANTLR start "CHARACTER_LITERAL"
	[GrammarRule("CHARACTER_LITERAL")]
	private void mCHARACTER_LITERAL()
	{
		EnterRule_CHARACTER_LITERAL();
		EnterRule("CHARACTER_LITERAL", 149);
		TraceIn("CHARACTER_LITERAL", 149);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1895:5: ()
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1896:5: 
			{
			}

		}
		finally
		{
			TraceOut("CHARACTER_LITERAL", 149);
			LeaveRule("CHARACTER_LITERAL", 149);
			LeaveRule_CHARACTER_LITERAL();
		}
	}
	// $ANTLR end "CHARACTER_LITERAL"

	partial void EnterRule_BASED_LITERAL();
	partial void LeaveRule_BASED_LITERAL();

	// $ANTLR start "BASED_LITERAL"
	[GrammarRule("BASED_LITERAL")]
	private void mBASED_LITERAL()
	{
		EnterRule_BASED_LITERAL();
		EnterRule("BASED_LITERAL", 150);
		TraceIn("BASED_LITERAL", 150);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1900:5: ()
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1901:5: 
			{
			}

		}
		finally
		{
			TraceOut("BASED_LITERAL", 150);
			LeaveRule("BASED_LITERAL", 150);
			LeaveRule_BASED_LITERAL();
		}
	}
	// $ANTLR end "BASED_LITERAL"

	public override void mTokens()
	{
		// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:8: ( ABS | ACCESS | AFTER | ALIAS | ALL | AMPERSAND | AND | ARCHITECTURE | ARRAY | ARROW | ASSERT | ATTRIBUTE | BACKSLASH | BAR | BEGIN | BLOCK | BODY | BOX | BUFFER | BUS | CASE | COLON | COMMA | COMPONENT | CONFIGURATION | CONSTANT | DBLQUOTE | DISCONNECT | DIV | DOT | DOUBLESTAR | DOWNTO | ELSE | ELSIF | END | ENTITY | EQ | EXCLAMATION | EXIT | FILE | FOR | FUNCTION | GE | GENERATE | GENERIC | GROUP | GT | GUARDED | IF | IMPURE | IN | INERTIAL | INOUT | IS | LABEL | LBRACKET | LE | LIBRARY | LINKAGE | LITERAL | LOOP | LPAREN | LT | MAP | MINUS | MOD | MUL | NAND | NEQ | NEW | NEXT | NOR | NOT | NULLTOK | OF | ON | OPEN | OR | OTHERS | OUT | PACKAGE | PLUS | PORT | POSTPONED | PROCEDURE | PROCESS | PURE | RANGETOK | RBRACKET | RECORD | REGISTER | REJECT | REM | REPORT | RETURN | ROL | ROR | RPAREN | SELECT | SEMI | SEVERITY | SHARED | SIGNAL | SLA | SLL | SRA | SRL | SUBTYPE | THEN | TO | TRANSPORT | TYPE | UNAFFECTED | UNITS | UNTIL | USE | VARASGN | VARIABLE | WAIT | WHEN | WHILE | WITH | XNOR | XOR | WHITESPACE | COMMENT | BASIC_IDENTIFIER | EXTENDED_IDENTIFIER | FLOAT_POINT_LITERAL | APOSTROPHE | STRING_LITERAL | BIT_STRING_LITERAL_BINARY | BIT_STRING_LITERAL_OCTAL | BIT_STRING_LITERAL_HEX | BINANRY_BASED_INTEGER | OCTAL_BASED_INTEGER | HEXA_BASED_INTEGER | DEC_BASED_INTEGER | EXPONENT )
		int alt30=139;
		try { DebugEnterDecision(30, false);
		try
		{
			alt30 = dfa30.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(30); }
		switch (alt30)
		{
		case 1:
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:10: ABS
			{
			DebugLocation(1, 10);
			mABS(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:14: ACCESS
			{
			DebugLocation(1, 14);
			mACCESS(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:21: AFTER
			{
			DebugLocation(1, 21);
			mAFTER(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:27: ALIAS
			{
			DebugLocation(1, 27);
			mALIAS(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:33: ALL
			{
			DebugLocation(1, 33);
			mALL(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:37: AMPERSAND
			{
			DebugLocation(1, 37);
			mAMPERSAND(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:47: AND
			{
			DebugLocation(1, 47);
			mAND(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:51: ARCHITECTURE
			{
			DebugLocation(1, 51);
			mARCHITECTURE(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:64: ARRAY
			{
			DebugLocation(1, 64);
			mARRAY(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:70: ARROW
			{
			DebugLocation(1, 70);
			mARROW(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:76: ASSERT
			{
			DebugLocation(1, 76);
			mASSERT(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:83: ATTRIBUTE
			{
			DebugLocation(1, 83);
			mATTRIBUTE(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:93: BACKSLASH
			{
			DebugLocation(1, 93);
			mBACKSLASH(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:103: BAR
			{
			DebugLocation(1, 103);
			mBAR(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:107: BEGIN
			{
			DebugLocation(1, 107);
			mBEGIN(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:113: BLOCK
			{
			DebugLocation(1, 113);
			mBLOCK(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:119: BODY
			{
			DebugLocation(1, 119);
			mBODY(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:124: BOX
			{
			DebugLocation(1, 124);
			mBOX(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:128: BUFFER
			{
			DebugLocation(1, 128);
			mBUFFER(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:135: BUS
			{
			DebugLocation(1, 135);
			mBUS(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:139: CASE
			{
			DebugLocation(1, 139);
			mCASE(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:144: COLON
			{
			DebugLocation(1, 144);
			mCOLON(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:150: COMMA
			{
			DebugLocation(1, 150);
			mCOMMA(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:156: COMPONENT
			{
			DebugLocation(1, 156);
			mCOMPONENT(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:166: CONFIGURATION
			{
			DebugLocation(1, 166);
			mCONFIGURATION(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:180: CONSTANT
			{
			DebugLocation(1, 180);
			mCONSTANT(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:189: DBLQUOTE
			{
			DebugLocation(1, 189);
			mDBLQUOTE(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:198: DISCONNECT
			{
			DebugLocation(1, 198);
			mDISCONNECT(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:209: DIV
			{
			DebugLocation(1, 209);
			mDIV(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:213: DOT
			{
			DebugLocation(1, 213);
			mDOT(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:217: DOUBLESTAR
			{
			DebugLocation(1, 217);
			mDOUBLESTAR(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:228: DOWNTO
			{
			DebugLocation(1, 228);
			mDOWNTO(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:235: ELSE
			{
			DebugLocation(1, 235);
			mELSE(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:240: ELSIF
			{
			DebugLocation(1, 240);
			mELSIF(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:246: END
			{
			DebugLocation(1, 246);
			mEND(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:250: ENTITY
			{
			DebugLocation(1, 250);
			mENTITY(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:257: EQ
			{
			DebugLocation(1, 257);
			mEQ(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:260: EXCLAMATION
			{
			DebugLocation(1, 260);
			mEXCLAMATION(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:272: EXIT
			{
			DebugLocation(1, 272);
			mEXIT(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:277: FILE
			{
			DebugLocation(1, 277);
			mFILE(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:282: FOR
			{
			DebugLocation(1, 282);
			mFOR(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:286: FUNCTION
			{
			DebugLocation(1, 286);
			mFUNCTION(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:295: GE
			{
			DebugLocation(1, 295);
			mGE(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:298: GENERATE
			{
			DebugLocation(1, 298);
			mGENERATE(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:307: GENERIC
			{
			DebugLocation(1, 307);
			mGENERIC(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:315: GROUP
			{
			DebugLocation(1, 315);
			mGROUP(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:321: GT
			{
			DebugLocation(1, 321);
			mGT(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:324: GUARDED
			{
			DebugLocation(1, 324);
			mGUARDED(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:332: IF
			{
			DebugLocation(1, 332);
			mIF(); if (state.failed) return;

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:335: IMPURE
			{
			DebugLocation(1, 335);
			mIMPURE(); if (state.failed) return;

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:342: IN
			{
			DebugLocation(1, 342);
			mIN(); if (state.failed) return;

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:345: INERTIAL
			{
			DebugLocation(1, 345);
			mINERTIAL(); if (state.failed) return;

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:354: INOUT
			{
			DebugLocation(1, 354);
			mINOUT(); if (state.failed) return;

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:360: IS
			{
			DebugLocation(1, 360);
			mIS(); if (state.failed) return;

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:363: LABEL
			{
			DebugLocation(1, 363);
			mLABEL(); if (state.failed) return;

			}
			break;
		case 56:
			DebugEnterAlt(56);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:369: LBRACKET
			{
			DebugLocation(1, 369);
			mLBRACKET(); if (state.failed) return;

			}
			break;
		case 57:
			DebugEnterAlt(57);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:378: LE
			{
			DebugLocation(1, 378);
			mLE(); if (state.failed) return;

			}
			break;
		case 58:
			DebugEnterAlt(58);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:381: LIBRARY
			{
			DebugLocation(1, 381);
			mLIBRARY(); if (state.failed) return;

			}
			break;
		case 59:
			DebugEnterAlt(59);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:389: LINKAGE
			{
			DebugLocation(1, 389);
			mLINKAGE(); if (state.failed) return;

			}
			break;
		case 60:
			DebugEnterAlt(60);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:397: LITERAL
			{
			DebugLocation(1, 397);
			mLITERAL(); if (state.failed) return;

			}
			break;
		case 61:
			DebugEnterAlt(61);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:405: LOOP
			{
			DebugLocation(1, 405);
			mLOOP(); if (state.failed) return;

			}
			break;
		case 62:
			DebugEnterAlt(62);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:410: LPAREN
			{
			DebugLocation(1, 410);
			mLPAREN(); if (state.failed) return;

			}
			break;
		case 63:
			DebugEnterAlt(63);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:417: LT
			{
			DebugLocation(1, 417);
			mLT(); if (state.failed) return;

			}
			break;
		case 64:
			DebugEnterAlt(64);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:420: MAP
			{
			DebugLocation(1, 420);
			mMAP(); if (state.failed) return;

			}
			break;
		case 65:
			DebugEnterAlt(65);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:424: MINUS
			{
			DebugLocation(1, 424);
			mMINUS(); if (state.failed) return;

			}
			break;
		case 66:
			DebugEnterAlt(66);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:430: MOD
			{
			DebugLocation(1, 430);
			mMOD(); if (state.failed) return;

			}
			break;
		case 67:
			DebugEnterAlt(67);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:434: MUL
			{
			DebugLocation(1, 434);
			mMUL(); if (state.failed) return;

			}
			break;
		case 68:
			DebugEnterAlt(68);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:438: NAND
			{
			DebugLocation(1, 438);
			mNAND(); if (state.failed) return;

			}
			break;
		case 69:
			DebugEnterAlt(69);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:443: NEQ
			{
			DebugLocation(1, 443);
			mNEQ(); if (state.failed) return;

			}
			break;
		case 70:
			DebugEnterAlt(70);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:447: NEW
			{
			DebugLocation(1, 447);
			mNEW(); if (state.failed) return;

			}
			break;
		case 71:
			DebugEnterAlt(71);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:451: NEXT
			{
			DebugLocation(1, 451);
			mNEXT(); if (state.failed) return;

			}
			break;
		case 72:
			DebugEnterAlt(72);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:456: NOR
			{
			DebugLocation(1, 456);
			mNOR(); if (state.failed) return;

			}
			break;
		case 73:
			DebugEnterAlt(73);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:460: NOT
			{
			DebugLocation(1, 460);
			mNOT(); if (state.failed) return;

			}
			break;
		case 74:
			DebugEnterAlt(74);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:464: NULLTOK
			{
			DebugLocation(1, 464);
			mNULLTOK(); if (state.failed) return;

			}
			break;
		case 75:
			DebugEnterAlt(75);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:472: OF
			{
			DebugLocation(1, 472);
			mOF(); if (state.failed) return;

			}
			break;
		case 76:
			DebugEnterAlt(76);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:475: ON
			{
			DebugLocation(1, 475);
			mON(); if (state.failed) return;

			}
			break;
		case 77:
			DebugEnterAlt(77);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:478: OPEN
			{
			DebugLocation(1, 478);
			mOPEN(); if (state.failed) return;

			}
			break;
		case 78:
			DebugEnterAlt(78);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:483: OR
			{
			DebugLocation(1, 483);
			mOR(); if (state.failed) return;

			}
			break;
		case 79:
			DebugEnterAlt(79);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:486: OTHERS
			{
			DebugLocation(1, 486);
			mOTHERS(); if (state.failed) return;

			}
			break;
		case 80:
			DebugEnterAlt(80);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:493: OUT
			{
			DebugLocation(1, 493);
			mOUT(); if (state.failed) return;

			}
			break;
		case 81:
			DebugEnterAlt(81);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:497: PACKAGE
			{
			DebugLocation(1, 497);
			mPACKAGE(); if (state.failed) return;

			}
			break;
		case 82:
			DebugEnterAlt(82);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:505: PLUS
			{
			DebugLocation(1, 505);
			mPLUS(); if (state.failed) return;

			}
			break;
		case 83:
			DebugEnterAlt(83);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:510: PORT
			{
			DebugLocation(1, 510);
			mPORT(); if (state.failed) return;

			}
			break;
		case 84:
			DebugEnterAlt(84);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:515: POSTPONED
			{
			DebugLocation(1, 515);
			mPOSTPONED(); if (state.failed) return;

			}
			break;
		case 85:
			DebugEnterAlt(85);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:525: PROCEDURE
			{
			DebugLocation(1, 525);
			mPROCEDURE(); if (state.failed) return;

			}
			break;
		case 86:
			DebugEnterAlt(86);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:535: PROCESS
			{
			DebugLocation(1, 535);
			mPROCESS(); if (state.failed) return;

			}
			break;
		case 87:
			DebugEnterAlt(87);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:543: PURE
			{
			DebugLocation(1, 543);
			mPURE(); if (state.failed) return;

			}
			break;
		case 88:
			DebugEnterAlt(88);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:548: RANGETOK
			{
			DebugLocation(1, 548);
			mRANGETOK(); if (state.failed) return;

			}
			break;
		case 89:
			DebugEnterAlt(89);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:557: RBRACKET
			{
			DebugLocation(1, 557);
			mRBRACKET(); if (state.failed) return;

			}
			break;
		case 90:
			DebugEnterAlt(90);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:566: RECORD
			{
			DebugLocation(1, 566);
			mRECORD(); if (state.failed) return;

			}
			break;
		case 91:
			DebugEnterAlt(91);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:573: REGISTER
			{
			DebugLocation(1, 573);
			mREGISTER(); if (state.failed) return;

			}
			break;
		case 92:
			DebugEnterAlt(92);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:582: REJECT
			{
			DebugLocation(1, 582);
			mREJECT(); if (state.failed) return;

			}
			break;
		case 93:
			DebugEnterAlt(93);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:589: REM
			{
			DebugLocation(1, 589);
			mREM(); if (state.failed) return;

			}
			break;
		case 94:
			DebugEnterAlt(94);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:593: REPORT
			{
			DebugLocation(1, 593);
			mREPORT(); if (state.failed) return;

			}
			break;
		case 95:
			DebugEnterAlt(95);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:600: RETURN
			{
			DebugLocation(1, 600);
			mRETURN(); if (state.failed) return;

			}
			break;
		case 96:
			DebugEnterAlt(96);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:607: ROL
			{
			DebugLocation(1, 607);
			mROL(); if (state.failed) return;

			}
			break;
		case 97:
			DebugEnterAlt(97);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:611: ROR
			{
			DebugLocation(1, 611);
			mROR(); if (state.failed) return;

			}
			break;
		case 98:
			DebugEnterAlt(98);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:615: RPAREN
			{
			DebugLocation(1, 615);
			mRPAREN(); if (state.failed) return;

			}
			break;
		case 99:
			DebugEnterAlt(99);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:622: SELECT
			{
			DebugLocation(1, 622);
			mSELECT(); if (state.failed) return;

			}
			break;
		case 100:
			DebugEnterAlt(100);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:629: SEMI
			{
			DebugLocation(1, 629);
			mSEMI(); if (state.failed) return;

			}
			break;
		case 101:
			DebugEnterAlt(101);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:634: SEVERITY
			{
			DebugLocation(1, 634);
			mSEVERITY(); if (state.failed) return;

			}
			break;
		case 102:
			DebugEnterAlt(102);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:643: SHARED
			{
			DebugLocation(1, 643);
			mSHARED(); if (state.failed) return;

			}
			break;
		case 103:
			DebugEnterAlt(103);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:650: SIGNAL
			{
			DebugLocation(1, 650);
			mSIGNAL(); if (state.failed) return;

			}
			break;
		case 104:
			DebugEnterAlt(104);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:657: SLA
			{
			DebugLocation(1, 657);
			mSLA(); if (state.failed) return;

			}
			break;
		case 105:
			DebugEnterAlt(105);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:661: SLL
			{
			DebugLocation(1, 661);
			mSLL(); if (state.failed) return;

			}
			break;
		case 106:
			DebugEnterAlt(106);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:665: SRA
			{
			DebugLocation(1, 665);
			mSRA(); if (state.failed) return;

			}
			break;
		case 107:
			DebugEnterAlt(107);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:669: SRL
			{
			DebugLocation(1, 669);
			mSRL(); if (state.failed) return;

			}
			break;
		case 108:
			DebugEnterAlt(108);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:673: SUBTYPE
			{
			DebugLocation(1, 673);
			mSUBTYPE(); if (state.failed) return;

			}
			break;
		case 109:
			DebugEnterAlt(109);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:681: THEN
			{
			DebugLocation(1, 681);
			mTHEN(); if (state.failed) return;

			}
			break;
		case 110:
			DebugEnterAlt(110);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:686: TO
			{
			DebugLocation(1, 686);
			mTO(); if (state.failed) return;

			}
			break;
		case 111:
			DebugEnterAlt(111);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:689: TRANSPORT
			{
			DebugLocation(1, 689);
			mTRANSPORT(); if (state.failed) return;

			}
			break;
		case 112:
			DebugEnterAlt(112);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:699: TYPE
			{
			DebugLocation(1, 699);
			mTYPE(); if (state.failed) return;

			}
			break;
		case 113:
			DebugEnterAlt(113);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:704: UNAFFECTED
			{
			DebugLocation(1, 704);
			mUNAFFECTED(); if (state.failed) return;

			}
			break;
		case 114:
			DebugEnterAlt(114);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:715: UNITS
			{
			DebugLocation(1, 715);
			mUNITS(); if (state.failed) return;

			}
			break;
		case 115:
			DebugEnterAlt(115);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:721: UNTIL
			{
			DebugLocation(1, 721);
			mUNTIL(); if (state.failed) return;

			}
			break;
		case 116:
			DebugEnterAlt(116);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:727: USE
			{
			DebugLocation(1, 727);
			mUSE(); if (state.failed) return;

			}
			break;
		case 117:
			DebugEnterAlt(117);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:731: VARASGN
			{
			DebugLocation(1, 731);
			mVARASGN(); if (state.failed) return;

			}
			break;
		case 118:
			DebugEnterAlt(118);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:739: VARIABLE
			{
			DebugLocation(1, 739);
			mVARIABLE(); if (state.failed) return;

			}
			break;
		case 119:
			DebugEnterAlt(119);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:748: WAIT
			{
			DebugLocation(1, 748);
			mWAIT(); if (state.failed) return;

			}
			break;
		case 120:
			DebugEnterAlt(120);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:753: WHEN
			{
			DebugLocation(1, 753);
			mWHEN(); if (state.failed) return;

			}
			break;
		case 121:
			DebugEnterAlt(121);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:758: WHILE
			{
			DebugLocation(1, 758);
			mWHILE(); if (state.failed) return;

			}
			break;
		case 122:
			DebugEnterAlt(122);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:764: WITH
			{
			DebugLocation(1, 764);
			mWITH(); if (state.failed) return;

			}
			break;
		case 123:
			DebugEnterAlt(123);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:769: XNOR
			{
			DebugLocation(1, 769);
			mXNOR(); if (state.failed) return;

			}
			break;
		case 124:
			DebugEnterAlt(124);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:774: XOR
			{
			DebugLocation(1, 774);
			mXOR(); if (state.failed) return;

			}
			break;
		case 125:
			DebugEnterAlt(125);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:778: WHITESPACE
			{
			DebugLocation(1, 778);
			mWHITESPACE(); if (state.failed) return;

			}
			break;
		case 126:
			DebugEnterAlt(126);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:789: COMMENT
			{
			DebugLocation(1, 789);
			mCOMMENT(); if (state.failed) return;

			}
			break;
		case 127:
			DebugEnterAlt(127);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:797: BASIC_IDENTIFIER
			{
			DebugLocation(1, 797);
			mBASIC_IDENTIFIER(); if (state.failed) return;

			}
			break;
		case 128:
			DebugEnterAlt(128);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:814: EXTENDED_IDENTIFIER
			{
			DebugLocation(1, 814);
			mEXTENDED_IDENTIFIER(); if (state.failed) return;

			}
			break;
		case 129:
			DebugEnterAlt(129);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:834: FLOAT_POINT_LITERAL
			{
			DebugLocation(1, 834);
			mFLOAT_POINT_LITERAL(); if (state.failed) return;

			}
			break;
		case 130:
			DebugEnterAlt(130);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:854: APOSTROPHE
			{
			DebugLocation(1, 854);
			mAPOSTROPHE(); if (state.failed) return;

			}
			break;
		case 131:
			DebugEnterAlt(131);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:865: STRING_LITERAL
			{
			DebugLocation(1, 865);
			mSTRING_LITERAL(); if (state.failed) return;

			}
			break;
		case 132:
			DebugEnterAlt(132);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:880: BIT_STRING_LITERAL_BINARY
			{
			DebugLocation(1, 880);
			mBIT_STRING_LITERAL_BINARY(); if (state.failed) return;

			}
			break;
		case 133:
			DebugEnterAlt(133);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:906: BIT_STRING_LITERAL_OCTAL
			{
			DebugLocation(1, 906);
			mBIT_STRING_LITERAL_OCTAL(); if (state.failed) return;

			}
			break;
		case 134:
			DebugEnterAlt(134);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:931: BIT_STRING_LITERAL_HEX
			{
			DebugLocation(1, 931);
			mBIT_STRING_LITERAL_HEX(); if (state.failed) return;

			}
			break;
		case 135:
			DebugEnterAlt(135);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:954: BINANRY_BASED_INTEGER
			{
			DebugLocation(1, 954);
			mBINANRY_BASED_INTEGER(); if (state.failed) return;

			}
			break;
		case 136:
			DebugEnterAlt(136);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:976: OCTAL_BASED_INTEGER
			{
			DebugLocation(1, 976);
			mOCTAL_BASED_INTEGER(); if (state.failed) return;

			}
			break;
		case 137:
			DebugEnterAlt(137);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:996: HEXA_BASED_INTEGER
			{
			DebugLocation(1, 996);
			mHEXA_BASED_INTEGER(); if (state.failed) return;

			}
			break;
		case 138:
			DebugEnterAlt(138);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:1015: DEC_BASED_INTEGER
			{
			DebugLocation(1, 1015);
			mDEC_BASED_INTEGER(); if (state.failed) return;

			}
			break;
		case 139:
			DebugEnterAlt(139);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1:1033: EXPONENT
			{
			DebugLocation(1, 1033);
			mEXPONENT(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_VhdlAntlr_fragment();
	partial void LeaveRule_synpred1_VhdlAntlr_fragment();

	// $ANTLR start synpred1_VhdlAntlr
	public void synpred1_VhdlAntlr_fragment()
	{
		EnterRule_synpred1_VhdlAntlr_fragment();
		EnterRule("synpred1_VhdlAntlr_fragment", 152);
		TraceIn("synpred1_VhdlAntlr_fragment", 152);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1773:21: ( ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\'' )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1773:22: ( '\\\"' | '\\\\' | '%' | GRAPHIC_CHARACTER ) '\\''
			{
			DebugLocation(1773, 22);
			if ((input.LA(1)>=' ' && input.LA(1)<='~')||(input.LA(1)>='\u00A0' && input.LA(1)<='\u00FF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(1773, 64);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_VhdlAntlr_fragment", 152);
			LeaveRule("synpred1_VhdlAntlr_fragment", 152);
			LeaveRule_synpred1_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred1_VhdlAntlr

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA30 dfa30;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa30 = new DFA30(this);
	}

	private class DFA30 : DFA
	{
		private const string DFA30_eotS =
			"\x1\xFFFF\x1\x32\x1\xFFFF\x1\x3C\x1\x3D\x1\xFFFF\x1\x32\x1\x46\x1\x32"+
			"\x1\x4A\x1\xFFFF\x1\x4B\x1\x32\x1\x4F\x1\xFFFF\x1\x51\x1\x32\x1\xFFFF"+
			"\x1\x32\x1\x5C\x3\x32\x2\xFFFF\x1\x32\x1\x6A\x3\x32\x1\xFFFF\x1\x32\x2"+
			"\xFFFF\x1\x32\x1\xFFFF\x5\x32\x1\xFFFF\x1\x32\x2\x91\x2\xFFFF\x3\x91"+
			"\x1\xFFFF\x8\x32\x4\xFFFF\x4\x32\x4\xFFFF\x2\x32\x3\xFFFF\x2\x32\x4\xFFFF"+
			"\x4\x32\x2\xFFFF\x3\x32\x2\xFFFF\x3\x32\x1\xB5\x1\x32\x1\xB9\x1\xBA\x5"+
			"\x32\x2\xFFFF\x4\x32\x1\xC8\x1\xC9\x1\x32\x1\xCB\x2\x32\x1\xFFFF\xE\x32"+
			"\x1\xE6\xA\x32\x4\xFFFF\x1\x91\x1\xFFFF\x1\x91\x1\xF5\x3\x32\x1\xF9\x1"+
			"\xFA\x8\x32\x1\x103\x6\x32\x1\x10C\x4\x32\x1\x110\x4\x32\x1\xFFFF\x3"+
			"\x32\x2\xFFFF\x5\x32\x1\x11D\x1\x11E\x1\x32\x1\x120\x1\x32\x1\x122\x1"+
			"\x123\x1\x32\x2\xFFFF\x1\x32\x1\xFFFF\x1\x32\x1\x127\x9\x32\x1\x131\x2"+
			"\x32\x1\x134\x1\x135\x4\x32\x1\x13A\x1\x13B\x1\x13C\x1\x13D\x2\x32\x1"+
			"\xFFFF\x5\x32\x1\x145\x6\x32\x1\x14C\x2\xFFFF\x3\x32\x2\xFFFF\x6\x32"+
			"\x1\x156\x1\x32\x1\xFFFF\x1\x158\x5\x32\x1\x15E\x1\x32\x1\xFFFF\x1\x32"+
			"\x1\x161\x1\x162\x1\xFFFF\xB\x32\x1\x16E\x2\xFFFF\x1\x16F\x1\xFFFF\x1"+
			"\x170\x2\xFFFF\x1\x171\x1\x172\x1\x32\x1\xFFFF\x1\x32\x1\x175\x2\x32"+
			"\x1\x178\x4\x32\x1\xFFFF\x2\x32\x2\xFFFF\x4\x32\x4\xFFFF\x1\x32\x1\x184"+
			"\x1\x32\x1\x186\x3\x32\x1\xFFFF\x1\x32\x1\x18B\x1\x18C\x1\x32\x1\x18E"+
			"\x1\x18F\x1\xFFFF\x1\x32\x1\x191\x1\x192\x1\x32\x1\x194\x2\x32\x1\x197"+
			"\x1\x198\x1\xFFFF\x1\x32\x1\xFFFF\x5\x32\x1\xFFFF\x1\x19F\x1\x32\x2\xFFFF"+
			"\x2\x32\x1\x1A4\x3\x32\x1\x1A8\x1\x1A9\x3\x32\x5\xFFFF\x2\x32\x1\xFFFF"+
			"\x2\x32\x1\xFFFF\x1\x1B2\xA\x32\x1\xFFFF\x1\x32\x1\xFFFF\x1\x32\x1\x1BF"+
			"\x1\x1C0\x1\x32\x2\xFFFF\x1\x1C2\x2\xFFFF\x1\x1C3\x2\xFFFF\x1\x32\x1"+
			"\xFFFF\x1\x1C5\x1\x32\x2\xFFFF\x1\x1C7\x4\x32\x1\x1CC\x1\xFFFF\x1\x1CD"+
			"\x3\x32\x1\xFFFF\x1\x32\x1\x1D2\x1\x32\x2\xFFFF\x3\x32\x1\x1D7\x4\x32"+
			"\x1\xFFFF\x1\x1DC\x1\x32\x1\x1DE\x1\x1DF\x1\x1E0\x1\x1E1\x1\x32\x1\x1E3"+
			"\x1\x1E4\x3\x32\x2\xFFFF\x1\x32\x2\xFFFF\x1\x32\x1\xFFFF\x1\x32\x1\xFFFF"+
			"\x4\x32\x2\xFFFF\x2\x32\x1\x1F1\x1\x1F2\x1\xFFFF\x1\x32\x1\x1F4\x1\x1F5"+
			"\x1\x1F6\x1\xFFFF\x1\x1F7\x2\x32\x1\x1FA\x1\xFFFF\x1\x32\x4\xFFFF\x1"+
			"\x32\x2\xFFFF\x1\x1FD\x7\x32\x1\x205\x1\x32\x1\x207\x1\x208\x2\xFFFF"+
			"\x1\x209\x4\xFFFF\x2\x32\x1\xFFFF\x1\x20C\x1\x20D\x1\xFFFF\x2\x32\x1"+
			"\x210\x1\x32\x1\x212\x1\x213\x1\x32\x1\xFFFF\x1\x32\x3\xFFFF\x1\x216"+
			"\x1\x217\x2\xFFFF\x1\x218\x1\x32\x1\xFFFF\x1\x32\x2\xFFFF\x1\x32\x1\x21C"+
			"\x3\xFFFF\x1\x21D\x2\x32\x2\xFFFF\x1\x220\x1\x32\x1\xFFFF\x1\x222\x1"+
			"\xFFFF";
		private const string DFA30_eofS =
			"\x223\xFFFF";
		private const string DFA30_minS =
			"\x1\x9\x1\x62\x1\xFFFF\x1\x3E\x1\x20\x1\xFFFF\x1\x22\x1\x3D\x1\x61\x1"+
			"\x3D\x1\xFFFF\x1\x20\x1\x69\x1\x3D\x1\xFFFF\x1\x2A\x1\x2B\x1\xFFFF\x1"+
			"\x69\x1\x3D\x1\x65\x1\x66\x1\x61\x2\xFFFF\x1\x61\x1\x2D\x1\x61\x1\x22"+
			"\x1\x61\x1\xFFFF\x1\x61\x2\xFFFF\x1\x65\x1\xFFFF\x1\x68\x1\x6E\x2\x61"+
			"\x1\x22\x1\xFFFF\x1\x2B\x1\x23\x1\x2E\x2\xFFFF\x1\x23\x2\x2E\x1\xFFFF"+
			"\x1\x73\x1\x63\x1\x74\x1\x69\x1\x64\x1\x63\x1\x73\x1\x74\x4\xFFFF\x1"+
			"\x67\x1\x6F\x1\x64\x1\x66\x4\xFFFF\x1\x73\x1\x6D\x3\xFFFF\x1\x73\x1\x77"+
			"\x4\xFFFF\x1\x73\x1\x64\x1\x69\x1\x30\x2\xFFFF\x1\x6C\x1\x72\x1\x6E\x2"+
			"\xFFFF\x1\x6E\x1\x6F\x1\x61\x1\x30\x1\x70\x2\x30\x2\x62\x1\x6F\x1\x70"+
			"\x1\x64\x2\xFFFF\x1\x6E\x1\x77\x1\x72\x1\x6C\x2\x30\x1\x65\x1\x30\x1"+
			"\x68\x1\x74\x1\xFFFF\x1\x63\x1\x72\x1\x6F\x1\x72\x1\x6E\x1\x63\x2\x6C"+
			"\x1\x61\x1\x67\x2\x61\x1\x62\x1\x65\x1\x30\x1\x61\x1\x70\x1\x61\x1\x65"+
			"\x1\x72\x1\x69\x1\x65\x1\x74\x1\x6F\x1\x72\x4\xFFFF\x1\x2E\x1\xFFFF\x1"+
			"\x23\x1\x30\x2\x65\x1\x61\x2\x30\x1\x68\x1\x61\x1\x65\x1\x72\x1\x69\x1"+
			"\x63\x1\x79\x1\x66\x1\x30\x1\x65\x1\x70\x1\x66\x1\x63\x1\x6E\x1\x65\x1"+
			"\x30\x1\x69\x1\x74\x1\x30\x1\x65\x1\x30\x1\x63\x1\x65\x1\x75\x1\x72\x1"+
			"\xFFFF\x1\x75\x1\x72\x1\x75\x2\xFFFF\x1\x65\x1\x72\x1\x6B\x1\x65\x1\x70"+
			"\x2\x30\x1\x64\x1\x30\x1\x74\x2\x30\x1\x6C\x2\xFFFF\x1\x6E\x1\xFFFF\x1"+
			"\x65\x1\x30\x1\x6B\x2\x74\x1\x63\x1\x65\x1\x67\x1\x6F\x1\x69\x1\x65\x1"+
			"\x30\x1\x6F\x1\x75\x2\x30\x2\x65\x1\x72\x1\x6E\x4\x30\x1\x74\x1\x6E\x1"+
			"\xFFFF\x1\x6E\x1\x65\x1\x66\x1\x74\x1\x69\x1\x30\x1\x69\x1\x74\x1\x6E"+
			"\x1\x6C\x1\x68\x1\x72\x1\x30\x2\xFFFF\x1\x73\x1\x72\x1\x73\x2\xFFFF\x1"+
			"\x69\x1\x79\x1\x72\x1\x69\x1\x6E\x1\x6B\x1\x30\x1\x65\x1\xFFFF\x1\x30"+
			"\x1\x6F\x1\x69\x1\x74\x1\x6F\x1\x74\x1\x30\x1\x66\x1\xFFFF\x1\x74\x2"+
			"\x30\x1\xFFFF\x1\x74\x1\x72\x1\x70\x1\x64\x1\x72\x2\x74\x1\x6C\x2\x61"+
			"\x1\x72\x1\x30\x2\xFFFF\x1\x30\x1\xFFFF\x1\x30\x2\xFFFF\x2\x30\x1\x72"+
			"\x1\xFFFF\x1\x61\x1\x30\x1\x70\x1\x65\x1\x30\x1\x65\x1\x72\x1\x73\x1"+
			"\x63\x1\xFFFF\x2\x72\x2\xFFFF\x1\x63\x1\x72\x1\x65\x1\x61\x4\xFFFF\x1"+
			"\x79\x1\x30\x1\x73\x1\x30\x1\x66\x1\x73\x1\x6C\x1\xFFFF\x1\x61\x2\x30"+
			"\x1\x65\x2\x30\x1\xFFFF\x1\x73\x2\x30\x1\x74\x1\x30\x1\x74\x1\x62\x2"+
			"\x30\x1\xFFFF\x1\x72\x1\xFFFF\x1\x6E\x1\x67\x1\x61\x1\x6E\x1\x6F\x1\xFFFF"+
			"\x1\x30\x1\x79\x2\xFFFF\x1\x69\x1\x61\x1\x30\x2\x65\x1\x69\x2\x30\x1"+
			"\x72\x1\x67\x1\x61\x5\xFFFF\x1\x73\x1\x67\x1\xFFFF\x1\x6F\x1\x64\x1\xFFFF"+
			"\x1\x30\x1\x64\x3\x74\x1\x6E\x1\x74\x1\x69\x1\x64\x1\x6C\x1\x70\x1\xFFFF"+
			"\x1\x70\x1\xFFFF\x1\x65\x2\x30\x1\x62\x2\xFFFF\x1\x30\x2\xFFFF\x1\x30"+
			"\x2\xFFFF\x1\x65\x1\xFFFF\x1\x30\x1\x75\x2\xFFFF\x1\x30\x1\x65\x1\x75"+
			"\x2\x6E\x1\x30\x1\xFFFF\x1\x30\x1\x6F\x1\x74\x1\x63\x1\xFFFF\x1\x64\x1"+
			"\x30\x1\x61\x2\xFFFF\x1\x79\x1\x65\x1\x6C\x1\x30\x1\x65\x1\x6E\x1\x75"+
			"\x1\x73\x1\xFFFF\x1\x30\x1\x65\x4\x30\x1\x74\x2\x30\x1\x65\x1\x6F\x1"+
			"\x63\x2\xFFFF\x1\x6C\x2\xFFFF\x1\x63\x1\xFFFF\x1\x74\x1\xFFFF\x1\x6E"+
			"\x1\x72\x1\x74\x1\x65\x2\xFFFF\x1\x6E\x1\x65\x2\x30\x1\xFFFF\x1\x6C\x3"+
			"\x30\x1\xFFFF\x1\x30\x1\x65\x1\x72\x1\x30\x1\xFFFF\x1\x72\x4\xFFFF\x1"+
			"\x79\x2\xFFFF\x1\x30\x1\x72\x1\x74\x1\x65\x1\x74\x1\x65\x1\x74\x1\x61"+
			"\x1\x30\x1\x63\x2\x30\x2\xFFFF\x1\x30\x4\xFFFF\x1\x64\x1\x65\x1\xFFFF"+
			"\x2\x30\x1\xFFFF\x1\x74\x1\x65\x1\x30\x1\x75\x2\x30\x1\x74\x1\xFFFF\x1"+
			"\x74\x3\xFFFF\x2\x30\x2\xFFFF\x1\x30\x1\x64\x1\xFFFF\x1\x72\x2\xFFFF"+
			"\x1\x69\x1\x30\x3\xFFFF\x1\x30\x1\x65\x1\x6F\x2\xFFFF\x1\x30\x1\x6E\x1"+
			"\xFFFF\x1\x30\x1\xFFFF";
		private const string DFA30_maxS =
			"\x1\xFF\x1\x74\x1\xFFFF\x1\x3E\x1\xFF\x1\xFFFF\x1\x75\x1\x3E\x1\x6F\x1"+
			"\x3D\x1\xFFFF\x1\xFF\x1\x6F\x1\x3D\x1\xFFFF\x1\x2A\x1\x78\x1\xFFFF\x1"+
			"\x75\x1\x3D\x1\x75\x1\x73\x1\x6F\x2\xFFFF\x1\x6F\x1\x2D\x3\x75\x1\xFFFF"+
			"\x1\x6F\x2\xFFFF\x1\x75\x1\xFFFF\x1\x79\x1\x73\x1\x61\x1\x69\x1\x6F\x1"+
			"\xFFFF\x1\x39\x1\x5F\x1\x2E\x2\xFFFF\x3\x5F\x1\xFFFF\x1\x73\x1\x63\x1"+
			"\x74\x1\x6C\x1\x64\x1\x72\x1\x73\x1\x74\x4\xFFFF\x1\x67\x1\x6F\x1\x64"+
			"\x1\x73\x4\xFFFF\x1\x73\x1\x6E\x3\xFFFF\x1\x73\x1\x77\x4\xFFFF\x1\x73"+
			"\x1\x74\x1\x69\x1\x5F\x2\xFFFF\x1\x6C\x1\x72\x1\x6E\x2\xFFFF\x1\x6E\x1"+
			"\x6F\x1\x61\x1\xFF\x1\x70\x2\xFF\x1\x62\x1\x74\x1\x6F\x1\x70\x1\x64\x2"+
			"\xFFFF\x1\x6E\x1\x78\x1\x74\x1\x6C\x2\xFF\x1\x65\x1\xFF\x1\x68\x1\x74"+
			"\x1\xFFFF\x1\x63\x1\x73\x1\x6F\x1\x72\x1\x6E\x1\x74\x1\x72\x1\x76\x1"+
			"\x61\x1\x67\x2\x6C\x1\x62\x1\x65\x1\xFF\x1\x61\x1\x70\x1\x74\x1\x65\x1"+
			"\x72\x2\x69\x1\x74\x1\x6F\x1\x72\x4\xFFFF\x1\x5F\x1\xFFFF\x1\x5F\x1\xFF"+
			"\x2\x65\x1\x61\x2\xFF\x1\x68\x1\x61\x1\x65\x1\x72\x1\x69\x1\x63\x1\x79"+
			"\x1\x66\x1\xFF\x1\x65\x1\x70\x1\x73\x1\x63\x1\x6E\x1\x69\x1\xFF\x1\x69"+
			"\x1\x74\x1\x5F\x1\x65\x1\xFF\x1\x63\x1\x65\x1\x75\x1\x72\x1\xFFFF\x1"+
			"\x75\x1\x72\x1\x75\x2\xFFFF\x1\x65\x1\x72\x1\x6B\x1\x65\x1\x70\x2\xFF"+
			"\x1\x64\x1\xFF\x1\x74\x2\xFF\x1\x6C\x2\xFFFF\x1\x6E\x1\xFFFF\x1\x65\x1"+
			"\xFF\x1\x6B\x2\x74\x1\x63\x1\x65\x1\x67\x1\x6F\x1\x69\x1\x65\x1\xFF\x1"+
			"\x6F\x1\x75\x2\xFF\x2\x65\x1\x72\x1\x6E\x4\xFF\x1\x74\x1\x6E\x1\xFFFF"+
			"\x1\x6E\x1\x65\x1\x66\x1\x74\x1\x69\x1\xFF\x1\x69\x1\x74\x1\x6E\x1\x6C"+
			"\x1\x68\x1\x72\x1\xFF\x2\xFFFF\x1\x73\x1\x72\x1\x73\x2\xFFFF\x1\x69\x1"+
			"\x79\x1\x72\x1\x69\x1\x6E\x1\x6B\x1\xFF\x1\x65\x1\xFFFF\x1\xFF\x1\x6F"+
			"\x1\x69\x1\x74\x1\x6F\x1\x74\x1\xFF\x1\x66\x1\xFFFF\x1\x74\x2\xFF\x1"+
			"\xFFFF\x1\x74\x1\x72\x1\x70\x1\x64\x1\x72\x2\x74\x1\x6C\x2\x61\x1\x72"+
			"\x1\xFF\x2\xFFFF\x1\xFF\x1\xFFFF\x1\xFF\x2\xFFFF\x2\xFF\x1\x72\x1\xFFFF"+
			"\x1\x61\x1\xFF\x1\x70\x1\x65\x1\xFF\x1\x65\x1\x72\x1\x73\x1\x63\x1\xFFFF"+
			"\x2\x72\x2\xFFFF\x1\x63\x1\x72\x1\x65\x1\x61\x4\xFFFF\x1\x79\x1\xFF\x1"+
			"\x73\x1\xFF\x1\x66\x1\x73\x1\x6C\x1\xFFFF\x1\x61\x2\xFF\x1\x65\x2\xFF"+
			"\x1\xFFFF\x1\x73\x2\xFF\x1\x74\x1\xFF\x1\x74\x1\x62\x2\xFF\x1\xFFFF\x1"+
			"\x72\x1\xFFFF\x1\x6E\x1\x67\x1\x61\x1\x6E\x1\x6F\x1\xFFFF\x1\xFF\x1\x79"+
			"\x2\xFFFF\x2\x69\x1\xFF\x2\x65\x1\x69\x2\xFF\x1\x72\x1\x67\x1\x61\x5"+
			"\xFFFF\x1\x73\x1\x67\x1\xFFFF\x1\x6F\x1\x73\x1\xFFFF\x1\xFF\x1\x64\x3"+
			"\x74\x1\x6E\x1\x74\x1\x69\x1\x64\x1\x6C\x1\x70\x1\xFFFF\x1\x70\x1\xFFFF"+
			"\x1\x65\x2\xFF\x1\x62\x2\xFFFF\x1\xFF\x2\xFFFF\x1\xFF\x2\xFFFF\x1\x65"+
			"\x1\xFFFF\x1\xFF\x1\x75\x2\xFFFF\x1\xFF\x1\x65\x1\x75\x2\x6E\x1\xFF\x1"+
			"\xFFFF\x1\xFF\x1\x6F\x1\x74\x1\x63\x1\xFFFF\x1\x64\x1\xFF\x1\x61\x2\xFFFF"+
			"\x1\x79\x1\x65\x1\x6C\x1\xFF\x1\x65\x1\x6E\x1\x75\x1\x73\x1\xFFFF\x1"+
			"\xFF\x1\x65\x4\xFF\x1\x74\x2\xFF\x1\x65\x1\x6F\x1\x63\x2\xFFFF\x1\x6C"+
			"\x2\xFFFF\x1\x63\x1\xFFFF\x1\x74\x1\xFFFF\x1\x6E\x1\x72\x1\x74\x1\x65"+
			"\x2\xFFFF\x1\x6E\x1\x65\x2\xFF\x1\xFFFF\x1\x6C\x3\xFF\x1\xFFFF\x1\xFF"+
			"\x1\x65\x1\x72\x1\xFF\x1\xFFFF\x1\x72\x4\xFFFF\x1\x79\x2\xFFFF\x1\xFF"+
			"\x1\x72\x1\x74\x1\x65\x1\x74\x1\x65\x1\x74\x1\x61\x1\xFF\x1\x63\x2\xFF"+
			"\x2\xFFFF\x1\xFF\x4\xFFFF\x1\x64\x1\x65\x1\xFFFF\x2\xFF\x1\xFFFF\x1\x74"+
			"\x1\x65\x1\xFF\x1\x75\x2\xFF\x1\x74\x1\xFFFF\x1\x74\x3\xFFFF\x2\xFF\x2"+
			"\xFFFF\x1\xFF\x1\x64\x1\xFFFF\x1\x72\x2\xFFFF\x1\x69\x1\xFF\x3\xFFFF"+
			"\x1\xFF\x1\x65\x1\x6F\x2\xFFFF\x1\xFF\x1\x6E\x1\xFFFF\x1\xFF\x1\xFFFF";
		private const string DFA30_acceptS =
			"\x2\xFFFF\x1\x6\x2\xFFFF\x1\xE\x4\xFFFF\x1\x17\x3\xFFFF\x1\x1E\x2\xFFFF"+
			"\x1\x26\x5\xFFFF\x1\x38\x1\x3E\x5\xFFFF\x1\x52\x1\xFFFF\x1\x59\x1\x62"+
			"\x1\xFFFF\x1\x64\x5\xFFFF\x1\x7D\x3\xFFFF\x1\x82\x1\x83\x3\xFFFF\x1\x7F"+
			"\x8\xFFFF\x1\xA\x1\x25\x1\xD\x1\x80\x4\xFFFF\x1\x84\x1\x12\x1\x39\x1"+
			"\x3F\x2\xFFFF\x1\x75\x1\x16\x1\x1B\x2\xFFFF\x1\x45\x1\x1D\x1\x1F\x1\x43"+
			"\x4\xFFFF\x1\x8B\x1\x7F\x3\xFFFF\x1\x2B\x1\x2F\xC\xFFFF\x1\x7E\x1\x41"+
			"\xA\xFFFF\x1\x85\x19\xFFFF\x1\x86\x1\x87\x1\x8A\x1\x81\x1\xFFFF\x1\x88"+
			"\x20\xFFFF\x1\x31\x3\xFFFF\x1\x33\x1\x36\xD\xFFFF\x1\x4B\x1\x4C\x1\xFFFF"+
			"\x1\x4E\x1A\xFFFF\x1\x6E\xD\xFFFF\x1\x89\x1\x1\x3\xFFFF\x1\x5\x1\x7\x8"+
			"\xFFFF\x1\x14\x8\xFFFF\x1\x23\x3\xFFFF\x1\x29\xC\xFFFF\x1\x40\x1\x42"+
			"\x1\xFFFF\x1\x46\x1\xFFFF\x1\x48\x1\x49\x3\xFFFF\x1\x50\x9\xFFFF\x1\x5D"+
			"\x2\xFFFF\x1\x60\x1\x61\x4\xFFFF\x1\x68\x1\x69\x1\x6A\x1\x6B\x7\xFFFF"+
			"\x1\x74\x6\xFFFF\x1\x7C\x9\xFFFF\x1\x11\x1\xFFFF\x1\x15\x5\xFFFF\x1\x21"+
			"\x2\xFFFF\x1\x27\x1\x28\xB\xFFFF\x1\x3D\x1\x44\x1\x47\x1\x4A\x1\x4D\x2"+
			"\xFFFF\x1\x53\x2\xFFFF\x1\x57\xB\xFFFF\x1\x6D\x1\xFFFF\x1\x70\x4\xFFFF"+
			"\x1\x77\x1\x78\x1\xFFFF\x1\x7A\x1\x7B\x1\xFFFF\x1\x3\x1\x4\x1\xFFFF\x1"+
			"\x9\x2\xFFFF\x1\xF\x1\x10\x6\xFFFF\x1\x22\x4\xFFFF\x1\x2E\x3\xFFFF\x1"+
			"\x35\x1\x37\x8\xFFFF\x1\x58\xC\xFFFF\x1\x72\x1\x73\x1\xFFFF\x1\x79\x1"+
			"\x2\x1\xFFFF\x1\xB\x1\xFFFF\x1\x13\x4\xFFFF\x1\x20\x1\x24\x4\xFFFF\x1"+
			"\x32\x4\xFFFF\x1\x4F\x4\xFFFF\x1\x5A\x1\xFFFF\x1\x5C\x1\x5E\x1\x5F\x1"+
			"\x63\x1\xFFFF\x1\x66\x1\x67\xC\xFFFF\x1\x2D\x1\x30\x1\xFFFF\x1\x3A\x1"+
			"\x3B\x1\x3C\x1\x51\x2\xFFFF\x1\x56\x2\xFFFF\x1\x6C\x7\xFFFF\x1\x1A\x1"+
			"\xFFFF\x1\x2A\x1\x2C\x1\x34\x2\xFFFF\x1\x5B\x1\x65\x2\xFFFF\x1\x76\x1"+
			"\xFFFF\x1\xC\x1\x18\x2\xFFFF\x1\x54\x1\x55\x1\x6F\x3\xFFFF\x1\x1C\x1"+
			"\x71\x2\xFFFF\x1\x8\x1\xFFFF\x1\x19";
		private const string DFA30_specialS =
			"\x223\xFFFF}>";
		private static readonly string[] DFA30_transitionS =
			{
				"\x2\x29\x2\xFFFF\x1\x29\x12\xFFFF\x1\x29\x1\x11\x1\xB\x2\xFFFF\x1\x2E"+
				"\x1\x2\x1\x2D\x1\x18\x1\x21\x1\xF\x1\x1E\x1\xA\x1\x1A\x1\xE\x1\xD\x1"+
				"\x2C\x1\x30\x1\x2B\x5\x31\x1\x2F\x1\x31\x1\x9\x1\x23\x1\x7\x1\x3\x1"+
				"\x13\x2\xFFFF\x4\x32\x1\x2A\x15\x32\x1\x17\x1\x4\x1\x20\x3\xFFFF\x1"+
				"\x1\x1\x6\x1\x8\x1\xC\x1\x10\x1\x12\x1\x14\x1\x32\x1\x15\x2\x32\x1\x16"+
				"\x1\x19\x1\x1B\x1\x1C\x1\x1D\x1\x32\x1\x1F\x1\x22\x1\x24\x1\x25\x1\x26"+
				"\x1\x27\x1\x28\x2\x32\x1\xFFFF\x1\x5\x43\xFFFF\x17\x32\x1\xFFFF\x1F"+
				"\x32\x1\xFFFF\x8\x32",
				"\x1\x33\x1\x34\x2\xFFFF\x1\x35\x5\xFFFF\x1\x36\x1\xFFFF\x1\x37\x3\xFFFF"+
				"\x1\x38\x1\x39\x1\x3A",
				"",
				"\x1\x3B",
				"\x5F\x3E\x21\xFFFF\x60\x3E",
				"",
				"\x1\x43\x2\xFFFF\x1\x43\x3F\xFFFF\x1\x3F\x6\xFFFF\x1\x40\x2\xFFFF\x1"+
				"\x41\x5\xFFFF\x1\x42",
				"\x1\x45\x1\x44",
				"\x1\x47\xD\xFFFF\x1\x48",
				"\x1\x49",
				"",
				"\x5F\x2E\x21\xFFFF\x60\x2E",
				"\x1\x4C\x5\xFFFF\x1\x4D",
				"\x1\x4E",
				"",
				"\x1\x50",
				"\x1\x56\x1\xFFFF\x1\x56\x2\xFFFF\x1\x57\x9\x55\x32\xFFFF\x1\x52\x1"+
				"\xFFFF\x1\x53\x9\xFFFF\x1\x54",
				"",
				"\x1\x58\x5\xFFFF\x1\x59\x5\xFFFF\x1\x5A",
				"\x1\x5B",
				"\x1\x5D\xC\xFFFF\x1\x5E\x2\xFFFF\x1\x5F",
				"\x1\x60\x6\xFFFF\x1\x61\x1\x62\x4\xFFFF\x1\x63",
				"\x1\x64\x7\xFFFF\x1\x65\x5\xFFFF\x1\x66",
				"",
				"",
				"\x1\x67\xD\xFFFF\x1\x68",
				"\x1\x69",
				"\x1\x6B\x3\xFFFF\x1\x6C\x9\xFFFF\x1\x6D\x5\xFFFF\x1\x6E",
				"\x1\x75\x2\xFFFF\x1\x75\x40\xFFFF\x1\x6F\x7\xFFFF\x1\x70\x1\xFFFF\x1"+
				"\x71\x1\xFFFF\x1\x72\x1\xFFFF\x1\x73\x1\x74",
				"\x1\x76\xD\xFFFF\x1\x77\x2\xFFFF\x1\x78\x2\xFFFF\x1\x79",
				"",
				"\x1\x7A\x3\xFFFF\x1\x7B\x9\xFFFF\x1\x7C",
				"",
				"",
				"\x1\x7D\x2\xFFFF\x1\x7E\x1\x7F\x2\xFFFF\x1\x80\x5\xFFFF\x1\x81\x2\xFFFF"+
				"\x1\x82",
				"",
				"\x1\x83\x6\xFFFF\x1\x84\x2\xFFFF\x1\x85\x6\xFFFF\x1\x86",
				"\x1\x87\x4\xFFFF\x1\x88",
				"\x1\x89",
				"\x1\x8A\x6\xFFFF\x1\x8B\x1\x8C",
				"\x1\x8F\x2\xFFFF\x1\x8F\x48\xFFFF\x1\x8D\x1\x8E",
				"",
				"\x1\x56\x1\xFFFF\x1\x56\x2\xFFFF\x1\x57\x9\x55",
				"\x1\x90\xA\xFFFF\x1\x92\x1\xFFFF\xA\x93\x25\xFFFF\x1\x93",
				"\x1\x92",
				"",
				"",
				"\x1\x94\xA\xFFFF\x1\x92\x1\xFFFF\xA\x93\x25\xFFFF\x1\x93",
				"\x1\x92\x1\xFFFF\x6\x93\x1\x95\x3\x93\x25\xFFFF\x1\x93",
				"\x1\x92\x1\xFFFF\xA\x93\x25\xFFFF\x1\x93",
				"",
				"\x1\x96",
				"\x1\x97",
				"\x1\x98",
				"\x1\x99\x2\xFFFF\x1\x9A",
				"\x1\x9B",
				"\x1\x9C\xE\xFFFF\x1\x9D",
				"\x1\x9E",
				"\x1\x9F",
				"",
				"",
				"",
				"",
				"\x1\xA0",
				"\x1\xA1",
				"\x1\xA2",
				"\x1\xA3\xC\xFFFF\x1\xA4",
				"",
				"",
				"",
				"",
				"\x1\xA5",
				"\x1\xA6\x1\xA7",
				"",
				"",
				"",
				"\x1\xA8",
				"\x1\xA9",
				"",
				"",
				"",
				"",
				"\x1\xAA",
				"\x1\xAB\xF\xFFFF\x1\xAC",
				"\x1\xAD",
				"\xA\xAE\x25\xFFFF\x1\xAE",
				"",
				"",
				"\x1\xAF",
				"\x1\xB0",
				"\x1\xB1",
				"",
				"",
				"\x1\xB2",
				"\x1\xB3",
				"\x1\xB4",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xB6",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x4\x32\x1\xB7\x9"+
				"\x32\x1\xB8\xB\x32\x45\xFFFF\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xBB",
				"\x1\xBC\xB\xFFFF\x1\xBD\x5\xFFFF\x1\xBE",
				"\x1\xBF",
				"\x1\xC0",
				"\x1\xC1",
				"",
				"",
				"\x1\xC2",
				"\x1\xC3\x1\xC4",
				"\x1\xC5\x1\xFFFF\x1\xC6",
				"\x1\xC7",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xCA",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xCC",
				"\x1\xCD",
				"",
				"\x1\xCE",
				"\x1\xCF\x1\xD0",
				"\x1\xD1",
				"\x1\xD2",
				"\x1\xD3",
				"\x1\xD4\x3\xFFFF\x1\xD5\x2\xFFFF\x1\xD6\x2\xFFFF\x1\xD7\x2\xFFFF\x1"+
				"\xD8\x3\xFFFF\x1\xD9",
				"\x1\xDA\x5\xFFFF\x1\xDB",
				"\x1\xDC\x9\xFFFF\x1\xDD",
				"\x1\xDE",
				"\x1\xDF",
				"\x1\xE0\xA\xFFFF\x1\xE1",
				"\x1\xE2\xA\xFFFF\x1\xE3",
				"\x1\xE4",
				"\x1\xE5",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xE7",
				"\x1\xE8",
				"\x1\xE9\x7\xFFFF\x1\xEA\xA\xFFFF\x1\xEB",
				"\x1\xEC",
				"\x1\xED",
				"\x1\xEE",
				"\x1\xEF\x3\xFFFF\x1\xF0",
				"\x1\xF1",
				"\x1\xF2",
				"\x1\xF3",
				"",
				"",
				"",
				"",
				"\x1\x92\x1\xFFFF\xA\x93\x25\xFFFF\x1\x93",
				"",
				"\x1\xF4\xA\xFFFF\x1\x92\x1\xFFFF\xA\x93\x25\xFFFF\x1\x93",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xF6",
				"\x1\xF7",
				"\x1\xF8",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\xFB",
				"\x1\xFC",
				"\x1\xFD",
				"\x1\xFE",
				"\x1\xFF",
				"\x1\x100",
				"\x1\x101",
				"\x1\x102",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x104",
				"\x1\x105",
				"\x1\x106\xC\xFFFF\x1\x107",
				"\x1\x108",
				"\x1\x109",
				"\x1\x10A\x3\xFFFF\x1\x10B",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x10D",
				"\x1\x10E",
				"\xA\xAE\x25\xFFFF\x1\xAE",
				"\x1\x10F",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x111",
				"\x1\x112",
				"\x1\x113",
				"\x1\x114",
				"",
				"\x1\x115",
				"\x1\x116",
				"\x1\x117",
				"",
				"",
				"\x1\x118",
				"\x1\x119",
				"\x1\x11A",
				"\x1\x11B",
				"\x1\x11C",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x11F",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x121",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x124",
				"",
				"",
				"\x1\x125",
				"",
				"\x1\x126",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x128",
				"\x1\x129",
				"\x1\x12A",
				"\x1\x12B",
				"\x1\x12C",
				"\x1\x12D",
				"\x1\x12E",
				"\x1\x12F",
				"\x1\x130",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x132",
				"\x1\x133",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x136",
				"\x1\x137",
				"\x1\x138",
				"\x1\x139",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x13E",
				"\x1\x13F",
				"",
				"\x1\x140",
				"\x1\x141",
				"\x1\x142",
				"\x1\x143",
				"\x1\x144",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x146",
				"\x1\x147",
				"\x1\x148",
				"\x1\x149",
				"\x1\x14A",
				"\x1\x14B",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\x1\x14D",
				"\x1\x14E",
				"\x1\x14F",
				"",
				"",
				"\x1\x150",
				"\x1\x151",
				"\x1\x152",
				"\x1\x153",
				"\x1\x154",
				"\x1\x155",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x157",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x159",
				"\x1\x15A",
				"\x1\x15B",
				"\x1\x15C",
				"\x1\x15D",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x15F",
				"",
				"\x1\x160",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x163",
				"\x1\x164",
				"\x1\x165",
				"\x1\x166",
				"\x1\x167",
				"\x1\x168",
				"\x1\x169",
				"\x1\x16A",
				"\x1\x16B",
				"\x1\x16C",
				"\x1\x16D",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x173",
				"",
				"\x1\x174",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x176",
				"\x1\x177",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x179",
				"\x1\x17A",
				"\x1\x17B",
				"\x1\x17C",
				"",
				"\x1\x17D",
				"\x1\x17E",
				"",
				"",
				"\x1\x17F",
				"\x1\x180",
				"\x1\x181",
				"\x1\x182",
				"",
				"",
				"",
				"",
				"\x1\x183",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x185",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x187",
				"\x1\x188",
				"\x1\x189",
				"",
				"\x1\x18A",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x18D",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x190",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x193",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x195",
				"\x1\x196",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x199",
				"",
				"\x1\x19A",
				"\x1\x19B",
				"\x1\x19C",
				"\x1\x19D",
				"\x1\x19E",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1A0",
				"",
				"",
				"\x1\x1A1",
				"\x1\x1A2\x7\xFFFF\x1\x1A3",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1A5",
				"\x1\x1A6",
				"\x1\x1A7",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1AA",
				"\x1\x1AB",
				"\x1\x1AC",
				"",
				"",
				"",
				"",
				"",
				"\x1\x1AD",
				"\x1\x1AE",
				"",
				"\x1\x1AF",
				"\x1\x1B0\xE\xFFFF\x1\x1B1",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1B3",
				"\x1\x1B4",
				"\x1\x1B5",
				"\x1\x1B6",
				"\x1\x1B7",
				"\x1\x1B8",
				"\x1\x1B9",
				"\x1\x1BA",
				"\x1\x1BB",
				"\x1\x1BC",
				"",
				"\x1\x1BD",
				"",
				"\x1\x1BE",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1C1",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\x1\x1C4",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1C6",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1C8",
				"\x1\x1C9",
				"\x1\x1CA",
				"\x1\x1CB",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1CE",
				"\x1\x1CF",
				"\x1\x1D0",
				"",
				"\x1\x1D1",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1D3",
				"",
				"",
				"\x1\x1D4",
				"\x1\x1D5",
				"\x1\x1D6",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1D8",
				"\x1\x1D9",
				"\x1\x1DA",
				"\x1\x1DB",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1DD",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1E2",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1E5",
				"\x1\x1E6",
				"\x1\x1E7",
				"",
				"",
				"\x1\x1E8",
				"",
				"",
				"\x1\x1E9",
				"",
				"\x1\x1EA",
				"",
				"\x1\x1EB",
				"\x1\x1EC",
				"\x1\x1ED",
				"\x1\x1EE",
				"",
				"",
				"\x1\x1EF",
				"\x1\x1F0",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x1F3",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1F8",
				"\x1\x1F9",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x1FB",
				"",
				"",
				"",
				"",
				"\x1\x1FC",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x1FE",
				"\x1\x1FF",
				"\x1\x200",
				"\x1\x201",
				"\x1\x202",
				"\x1\x203",
				"\x1\x204",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x206",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"",
				"",
				"\x1\x20A",
				"\x1\x20B",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"\x1\x20E",
				"\x1\x20F",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x211",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x214",
				"",
				"\x1\x215",
				"",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x219",
				"",
				"\x1\x21A",
				"",
				"",
				"\x1\x21B",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x21E",
				"\x1\x21F",
				"",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				"\x1\x221",
				"",
				"\xA\x32\x7\xFFFF\x1A\x32\x4\xFFFF\x1\x32\x1\xFFFF\x1A\x32\x45\xFFFF"+
				"\x17\x32\x1\xFFFF\x1F\x32\x1\xFFFF\x8\x32",
				""
			};

		private static readonly short[] DFA30_eot = DFA.UnpackEncodedString(DFA30_eotS);
		private static readonly short[] DFA30_eof = DFA.UnpackEncodedString(DFA30_eofS);
		private static readonly char[] DFA30_min = DFA.UnpackEncodedStringToUnsignedChars(DFA30_minS);
		private static readonly char[] DFA30_max = DFA.UnpackEncodedStringToUnsignedChars(DFA30_maxS);
		private static readonly short[] DFA30_accept = DFA.UnpackEncodedString(DFA30_acceptS);
		private static readonly short[] DFA30_special = DFA.UnpackEncodedString(DFA30_specialS);
		private static readonly short[][] DFA30_transition;

		static DFA30()
		{
			int numStates = DFA30_transitionS.Length;
			DFA30_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA30_transition[i] = DFA.UnpackEncodedString(DFA30_transitionS[i]);
			}
		}

		public DFA30( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 30;
			this.eot = DFA30_eot;
			this.eof = DFA30_eof;
			this.min = DFA30_min;
			this.max = DFA30_max;
			this.accept = DFA30_accept;
			this.special = DFA30_special;
			this.transition = DFA30_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( ABS | ACCESS | AFTER | ALIAS | ALL | AMPERSAND | AND | ARCHITECTURE | ARRAY | ARROW | ASSERT | ATTRIBUTE | BACKSLASH | BAR | BEGIN | BLOCK | BODY | BOX | BUFFER | BUS | CASE | COLON | COMMA | COMPONENT | CONFIGURATION | CONSTANT | DBLQUOTE | DISCONNECT | DIV | DOT | DOUBLESTAR | DOWNTO | ELSE | ELSIF | END | ENTITY | EQ | EXCLAMATION | EXIT | FILE | FOR | FUNCTION | GE | GENERATE | GENERIC | GROUP | GT | GUARDED | IF | IMPURE | IN | INERTIAL | INOUT | IS | LABEL | LBRACKET | LE | LIBRARY | LINKAGE | LITERAL | LOOP | LPAREN | LT | MAP | MINUS | MOD | MUL | NAND | NEQ | NEW | NEXT | NOR | NOT | NULLTOK | OF | ON | OPEN | OR | OTHERS | OUT | PACKAGE | PLUS | PORT | POSTPONED | PROCEDURE | PROCESS | PURE | RANGETOK | RBRACKET | RECORD | REGISTER | REJECT | REM | REPORT | RETURN | ROL | ROR | RPAREN | SELECT | SEMI | SEVERITY | SHARED | SIGNAL | SLA | SLL | SRA | SRL | SUBTYPE | THEN | TO | TRANSPORT | TYPE | UNAFFECTED | UNITS | UNTIL | USE | VARASGN | VARIABLE | WAIT | WHEN | WHILE | WITH | XNOR | XOR | WHITESPACE | COMMENT | BASIC_IDENTIFIER | EXTENDED_IDENTIFIER | FLOAT_POINT_LITERAL | APOSTROPHE | STRING_LITERAL | BIT_STRING_LITERAL_BINARY | BIT_STRING_LITERAL_OCTAL | BIT_STRING_LITERAL_HEX | BINANRY_BASED_INTEGER | OCTAL_BASED_INTEGER | HEXA_BASED_INTEGER | DEC_BASED_INTEGER | EXPONENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}
