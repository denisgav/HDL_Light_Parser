//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g 2014-10-06 20:43:55

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using VHDLParser.antlr;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class VhdlAntlrParser : AbstractVhdlAntlrParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABS", "ACCESS", "AFTER", "AGGREGATE", "ALIAS", "ALL", "AMPERSAND", "AND", "APOSTROPHE", "ARCHITECTURE", "ARRAY", "ARROW", "ASSERT", "ASSOCIATION_LIST", "ATTRIBUTE", "ATTRIBUTE_DECLARATION", "ATTRIBUTE_SPECIFICATION", "BACKSLASH", "BAR", "BASED_LITERAL", "BASIC_IDENTIFIER", "BEGIN", "BINANRY_BASED_INTEGER", "BINDING_INDICATION", "BIT_STRING_LITERAL_BINARY", "BIT_STRING_LITERAL_HEX", "BIT_STRING_LITERAL_OCTAL", "BLOCK", "BLOCK_CONFIGURATION", "BLOCK_STATEMENT", "BODY", "BOX", "BUFFER", "BUS", "CASE", "CHARACTER_LITERAL", "CHOICES", "COLON", "COMMA", "COMMENT", "COMPONENT", "COMPONENT_CONFIGURATION", "COMPONENT_INSTANCE", "COMPONENT_INSTANTIATION_STATEMENT", "CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT", "CONDITIONAL_WAVEFORMS", "CONFIGURATION", "CONFIGURATION_SPECIFICATION", "CONSTANT", "CONSTRAINED_ARRAY_DEFINITION", "DBLQUOTE", "DEC_BASED_INTEGER", "DIGIT", "DISCONNECT", "DISCRETE_RANGE", "DIV", "DOT", "DOUBLESTAR", "DOWNTO", "ELSE", "ELSIF", "END", "ENTITY", "ENTITY_STATEMENT", "ENUMERATION_TYPE_DEFINITION", "EQ", "EXCLAMATION", "EXIT", "EXPONENT", "EXPRESSION", "EXTENDED_IDENTIFIER", "FILE", "FILE_TYPE_DEFINITION", "FLOAT_POINT_LITERAL", "FOR", "FULL_TYPE_DECLARATION", "FUNCTION", "GE", "GENERATE", "GENERIC", "GENERIC_MAP", "GRAPHIC_CHARACTER", "GROUP", "GROUP_DECLARATION", "GROUP_TEMPLATE_DECLARATION", "GT", "GUARDED", "HEXA_BASED_INTEGER", "IF", "IMPURE", "IN", "INCOMPLETE_TYPE_DECLARATION", "INDEX_CONSTRAINT", "INERTIAL", "INOUT", "INSTANTIATION_LIST", "INTEGER_OR_FLOAT_TYPE_DEFINITION", "INTERFACE_CONSTANT_DECLARATION", "INTERFACE_FILE_DECLARATION", "INTERFACE_SIGNAL_DECLARATION", "INTERFACE_VARIABLE_DECLARATION", "IS", "LABEL", "LABEL_STATEMENT", "LBRACKET", "LE", "LETTER", "LETTER_OR_DIGIT", "LIBRARY", "LINKAGE", "LITERAL", "LOOP", "LOWER_CASE_LETTER", "LPAREN", "LT", "MAP", "MINUS", "MOD", "MUL", "NAME", "NAME_ATTRIBUTE_PART", "NAME_INDEXED_OR_SLICE_PART", "NAME_INDEXED_PART", "NAME_SELECTED_PART", "NAME_SLICE_PART", "NAND", "NEQ", "NEW", "NEXT", "NOR", "NOT", "NULLTOK", "OCTAL_BASED_INTEGER", "OF", "ON", "OPEN", "OR", "OTHERS", "OTHER_SPECIAL_CHARACTER", "OUT", "PACKAGE", "PACKAGE_BODY", "PHYSICAL_LITERAL", "PHYSICAL_TYPE_DEFINITION", "PLUS", "PORT", "PORT_MAP", "POSTPONED", "PROCEDURE", "PROCEDURE_CALL", "PROCESS", "PURE", "QUALIFIED_EXPRESSION", "RANGETOK", "RBRACKET", "RECORD", "RECORD_TYPE_DEFINITION", "REGISTER", "REJECT", "REM", "REPORT", "RESOLVED", "RETURN", "ROL", "ROR", "RPAREN", "SELECT", "SELECTED_SIGNAL_ASSIGNMENT_STATEMENT", "SEMI", "SEVERITY", "SHARED", "SIGNAL", "SIGNAL_ASSIGNMENT_STATEMENT", "SIGNAL_LIST", "SIGNATURE", "SLA", "SLL", "SPACE_CHARACTER", "SPECIAL_CHARACTER", "SRA", "SRL", "STRING_LITERAL", "SUBPROGRAM_BODY", "SUBPROGRAM_DECLARATION", "SUBTYPE", "SUBTYPE_INDICATION", "THEN", "TO", "TRANSPORT", "TYPE", "UNAFFECTED", "UNCONDITIONAL_LOOP", "UNCONSTRAINED_ARRAY_DEFINITION", "UNITS", "UNTIL", "UPPER_CASE_LETTER", "USE", "VARASGN", "VARIABLE", "VARIABLE_ASSIGNMENT_STATEMENT", "WAIT", "WAVEFORM", "WAVEFORM_ELEMENT", "WHEN", "WHILE", "WHITESPACE", "WITH", "XNOR", "XOR"
	};
	public const int EOF=-1;
	public const int ABS=4;
	public const int ACCESS=5;
	public const int AFTER=6;
	public const int AGGREGATE=7;
	public const int ALIAS=8;
	public const int ALL=9;
	public const int AMPERSAND=10;
	public const int AND=11;
	public const int APOSTROPHE=12;
	public const int ARCHITECTURE=13;
	public const int ARRAY=14;
	public const int ARROW=15;
	public const int ASSERT=16;
	public const int ASSOCIATION_LIST=17;
	public const int ATTRIBUTE=18;
	public const int ATTRIBUTE_DECLARATION=19;
	public const int ATTRIBUTE_SPECIFICATION=20;
	public const int BACKSLASH=21;
	public const int BAR=22;
	public const int BASED_LITERAL=23;
	public const int BASIC_IDENTIFIER=24;
	public const int BEGIN=25;
	public const int BINANRY_BASED_INTEGER=26;
	public const int BINDING_INDICATION=27;
	public const int BIT_STRING_LITERAL_BINARY=28;
	public const int BIT_STRING_LITERAL_HEX=29;
	public const int BIT_STRING_LITERAL_OCTAL=30;
	public const int BLOCK=31;
	public const int BLOCK_CONFIGURATION=32;
	public const int BLOCK_STATEMENT=33;
	public const int BODY=34;
	public const int BOX=35;
	public const int BUFFER=36;
	public const int BUS=37;
	public const int CASE=38;
	public const int CHARACTER_LITERAL=39;
	public const int CHOICES=40;
	public const int COLON=41;
	public const int COMMA=42;
	public const int COMMENT=43;
	public const int COMPONENT=44;
	public const int COMPONENT_CONFIGURATION=45;
	public const int COMPONENT_INSTANCE=46;
	public const int COMPONENT_INSTANTIATION_STATEMENT=47;
	public const int CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT=48;
	public const int CONDITIONAL_WAVEFORMS=49;
	public const int CONFIGURATION=50;
	public const int CONFIGURATION_SPECIFICATION=51;
	public const int CONSTANT=52;
	public const int CONSTRAINED_ARRAY_DEFINITION=53;
	public const int DBLQUOTE=54;
	public const int DEC_BASED_INTEGER=55;
	public const int DIGIT=56;
	public const int DISCONNECT=57;
	public const int DISCRETE_RANGE=58;
	public const int DIV=59;
	public const int DOT=60;
	public const int DOUBLESTAR=61;
	public const int DOWNTO=62;
	public const int ELSE=63;
	public const int ELSIF=64;
	public const int END=65;
	public const int ENTITY=66;
	public const int ENTITY_STATEMENT=67;
	public const int ENUMERATION_TYPE_DEFINITION=68;
	public const int EQ=69;
	public const int EXCLAMATION=70;
	public const int EXIT=71;
	public const int EXPONENT=72;
	public const int EXPRESSION=73;
	public const int EXTENDED_IDENTIFIER=74;
	public const int FILE=75;
	public const int FILE_TYPE_DEFINITION=76;
	public const int FLOAT_POINT_LITERAL=77;
	public const int FOR=78;
	public const int FULL_TYPE_DECLARATION=79;
	public const int FUNCTION=80;
	public const int GE=81;
	public const int GENERATE=82;
	public const int GENERIC=83;
	public const int GENERIC_MAP=84;
	public const int GRAPHIC_CHARACTER=85;
	public const int GROUP=86;
	public const int GROUP_DECLARATION=87;
	public const int GROUP_TEMPLATE_DECLARATION=88;
	public const int GT=89;
	public const int GUARDED=90;
	public const int HEXA_BASED_INTEGER=91;
	public const int IF=92;
	public const int IMPURE=93;
	public const int IN=94;
	public const int INCOMPLETE_TYPE_DECLARATION=95;
	public const int INDEX_CONSTRAINT=96;
	public const int INERTIAL=97;
	public const int INOUT=98;
	public const int INSTANTIATION_LIST=99;
	public const int INTEGER_OR_FLOAT_TYPE_DEFINITION=100;
	public const int INTERFACE_CONSTANT_DECLARATION=101;
	public const int INTERFACE_FILE_DECLARATION=102;
	public const int INTERFACE_SIGNAL_DECLARATION=103;
	public const int INTERFACE_VARIABLE_DECLARATION=104;
	public const int IS=105;
	public const int LABEL=106;
	public const int LABEL_STATEMENT=107;
	public const int LBRACKET=108;
	public const int LE=109;
	public const int LETTER=110;
	public const int LETTER_OR_DIGIT=111;
	public const int LIBRARY=112;
	public const int LINKAGE=113;
	public const int LITERAL=114;
	public const int LOOP=115;
	public const int LOWER_CASE_LETTER=116;
	public const int LPAREN=117;
	public const int LT=118;
	public const int MAP=119;
	public const int MINUS=120;
	public const int MOD=121;
	public const int MUL=122;
	public const int NAME=123;
	public const int NAME_ATTRIBUTE_PART=124;
	public const int NAME_INDEXED_OR_SLICE_PART=125;
	public const int NAME_INDEXED_PART=126;
	public const int NAME_SELECTED_PART=127;
	public const int NAME_SLICE_PART=128;
	public const int NAND=129;
	public const int NEQ=130;
	public const int NEW=131;
	public const int NEXT=132;
	public const int NOR=133;
	public const int NOT=134;
	public const int NULLTOK=135;
	public const int OCTAL_BASED_INTEGER=136;
	public const int OF=137;
	public const int ON=138;
	public const int OPEN=139;
	public const int OR=140;
	public const int OTHERS=141;
	public const int OTHER_SPECIAL_CHARACTER=142;
	public const int OUT=143;
	public const int PACKAGE=144;
	public const int PACKAGE_BODY=145;
	public const int PHYSICAL_LITERAL=146;
	public const int PHYSICAL_TYPE_DEFINITION=147;
	public const int PLUS=148;
	public const int PORT=149;
	public const int PORT_MAP=150;
	public const int POSTPONED=151;
	public const int PROCEDURE=152;
	public const int PROCEDURE_CALL=153;
	public const int PROCESS=154;
	public const int PURE=155;
	public const int QUALIFIED_EXPRESSION=156;
	public const int RANGETOK=157;
	public const int RBRACKET=158;
	public const int RECORD=159;
	public const int RECORD_TYPE_DEFINITION=160;
	public const int REGISTER=161;
	public const int REJECT=162;
	public const int REM=163;
	public const int REPORT=164;
	public const int RESOLVED=165;
	public const int RETURN=166;
	public const int ROL=167;
	public const int ROR=168;
	public const int RPAREN=169;
	public const int SELECT=170;
	public const int SELECTED_SIGNAL_ASSIGNMENT_STATEMENT=171;
	public const int SEMI=172;
	public const int SEVERITY=173;
	public const int SHARED=174;
	public const int SIGNAL=175;
	public const int SIGNAL_ASSIGNMENT_STATEMENT=176;
	public const int SIGNAL_LIST=177;
	public const int SIGNATURE=178;
	public const int SLA=179;
	public const int SLL=180;
	public const int SPACE_CHARACTER=181;
	public const int SPECIAL_CHARACTER=182;
	public const int SRA=183;
	public const int SRL=184;
	public const int STRING_LITERAL=185;
	public const int SUBPROGRAM_BODY=186;
	public const int SUBPROGRAM_DECLARATION=187;
	public const int SUBTYPE=188;
	public const int SUBTYPE_INDICATION=189;
	public const int THEN=190;
	public const int TO=191;
	public const int TRANSPORT=192;
	public const int TYPE=193;
	public const int UNAFFECTED=194;
	public const int UNCONDITIONAL_LOOP=195;
	public const int UNCONSTRAINED_ARRAY_DEFINITION=196;
	public const int UNITS=197;
	public const int UNTIL=198;
	public const int UPPER_CASE_LETTER=199;
	public const int USE=200;
	public const int VARASGN=201;
	public const int VARIABLE=202;
	public const int VARIABLE_ASSIGNMENT_STATEMENT=203;
	public const int WAIT=204;
	public const int WAVEFORM=205;
	public const int WAVEFORM_ELEMENT=206;
	public const int WHEN=207;
	public const int WHILE=208;
	public const int WHITESPACE=209;
	public const int WITH=210;
	public const int XNOR=211;
	public const int XOR=212;

	public VhdlAntlrParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public VhdlAntlrParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[233+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return VhdlAntlrParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_abstract_literal();
	partial void LeaveRule_abstract_literal();

	// $ANTLR start "abstract_literal"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:244:1: abstract_literal : ( BINANRY_BASED_INTEGER | OCTAL_BASED_INTEGER | HEXA_BASED_INTEGER | DEC_BASED_INTEGER );
	[GrammarRule("abstract_literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> abstract_literal()
	{
		EnterRule_abstract_literal();
		EnterRule("abstract_literal", 1);
		TraceIn("abstract_literal", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int abstract_literal_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set1 = default(IToken);

		CommonTree set1_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "abstract_literal");
		DebugLocation(244, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:245:5: ( BINANRY_BASED_INTEGER | OCTAL_BASED_INTEGER | HEXA_BASED_INTEGER | DEC_BASED_INTEGER )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(245, 5);

			set1=(IToken)input.LT(1);
			if (input.LA(1)==BINANRY_BASED_INTEGER||input.LA(1)==DEC_BASED_INTEGER||input.LA(1)==HEXA_BASED_INTEGER||input.LA(1)==OCTAL_BASED_INTEGER)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set1));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("abstract_literal", 1);
			LeaveRule("abstract_literal", 1);
			LeaveRule_abstract_literal();
			if (state.backtracking > 0) { Memoize(input, 1, abstract_literal_StartIndex); }

		}
		DebugLocation(249, 4);
		} finally { DebugExitRule(GrammarFileName, "abstract_literal"); }
		return retval;

	}
	// $ANTLR end "abstract_literal"

	partial void EnterRule_access_type_definition();
	partial void LeaveRule_access_type_definition();

	// $ANTLR start "access_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:251:1: access_type_definition : ACCESS subtype_indication -> ^( ACCESS subtype_indication ) ;
	[GrammarRule("access_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> access_type_definition()
	{
		EnterRule_access_type_definition();
		EnterRule("access_type_definition", 2);
		TraceIn("access_type_definition", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int access_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ACCESS2 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication3 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ACCESS2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ACCESS=new RewriteRuleITokenStream(adaptor,"token ACCESS");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		try { DebugEnterRule(GrammarFileName, "access_type_definition");
		DebugLocation(251, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:252:5: ( ACCESS subtype_indication -> ^( ACCESS subtype_indication ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:252:9: ACCESS subtype_indication
			{
			DebugLocation(252, 9);
			ACCESS2=(IToken)Match(input,ACCESS,Follow._ACCESS_in_access_type_definition2954); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ACCESS.Add(ACCESS2);

			DebugLocation(252, 16);
			PushFollow(Follow._subtype_indication_in_access_type_definition2956);
			subtype_indication3=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication3.Tree);


			{
			// AST REWRITE
			// elements: ACCESS, subtype_indication
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 253:9: -> ^( ACCESS subtype_indication )
			{
				DebugLocation(253, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:253:12: ^( ACCESS subtype_indication )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(253, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ACCESS.NextNode(), root_1);

				DebugLocation(253, 22);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("access_type_definition", 2);
			LeaveRule("access_type_definition", 2);
			LeaveRule_access_type_definition();
			if (state.backtracking > 0) { Memoize(input, 2, access_type_definition_StartIndex); }

		}
		DebugLocation(254, 4);
		} finally { DebugExitRule(GrammarFileName, "access_type_definition"); }
		return retval;

	}
	// $ANTLR end "access_type_definition"

	partial void EnterRule_actual_part();
	partial void LeaveRule_actual_part();

	// $ANTLR start "actual_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:262:1: actual_part : ( expression | OPEN );
	[GrammarRule("actual_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> actual_part()
	{
		EnterRule_actual_part();
		EnterRule("actual_part", 3);
		TraceIn("actual_part", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int actual_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken OPEN5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression4 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree OPEN5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "actual_part");
		DebugLocation(262, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:263:5: ( expression | OPEN )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==ABS||LA1_0==BASIC_IDENTIFIER||LA1_0==BINANRY_BASED_INTEGER||(LA1_0>=BIT_STRING_LITERAL_BINARY && LA1_0<=BIT_STRING_LITERAL_OCTAL)||LA1_0==CHARACTER_LITERAL||LA1_0==DEC_BASED_INTEGER||LA1_0==EXTENDED_IDENTIFIER||LA1_0==FLOAT_POINT_LITERAL||LA1_0==HEXA_BASED_INTEGER||LA1_0==LPAREN||LA1_0==MINUS||LA1_0==NEW||(LA1_0>=NOT && LA1_0<=OCTAL_BASED_INTEGER)||LA1_0==PLUS||LA1_0==STRING_LITERAL))
			{
				alt1 = 1;
			}
			else if ((LA1_0==OPEN))
			{
				alt1 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:263:9: expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(263, 9);
				PushFollow(Follow._expression_in_actual_part2999);
				expression4=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression4.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:264:9: OPEN
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(264, 9);
				OPEN5=(IToken)Match(input,OPEN,Follow._OPEN_in_actual_part3009); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OPEN5_tree = (CommonTree)adaptor.Create(OPEN5);
				adaptor.AddChild(root_0, OPEN5_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("actual_part", 3);
			LeaveRule("actual_part", 3);
			LeaveRule_actual_part();
			if (state.backtracking > 0) { Memoize(input, 3, actual_part_StartIndex); }

		}
		DebugLocation(267, 4);
		} finally { DebugExitRule(GrammarFileName, "actual_part"); }
		return retval;

	}
	// $ANTLR end "actual_part"

	partial void EnterRule_adding_operator();
	partial void LeaveRule_adding_operator();

	// $ANTLR start "adding_operator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:269:1: adding_operator : ( PLUS | MINUS | AMPERSAND );
	[GrammarRule("adding_operator")]
	private AstParserRuleReturnScope<CommonTree, IToken> adding_operator()
	{
		EnterRule_adding_operator();
		EnterRule("adding_operator", 4);
		TraceIn("adding_operator", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int adding_operator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set6 = default(IToken);

		CommonTree set6_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "adding_operator");
		DebugLocation(269, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:270:5: ( PLUS | MINUS | AMPERSAND )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(270, 5);

			set6=(IToken)input.LT(1);
			if (input.LA(1)==AMPERSAND||input.LA(1)==MINUS||input.LA(1)==PLUS)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set6));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("adding_operator", 4);
			LeaveRule("adding_operator", 4);
			LeaveRule_adding_operator();
			if (state.backtracking > 0) { Memoize(input, 4, adding_operator_StartIndex); }

		}
		DebugLocation(273, 4);
		} finally { DebugExitRule(GrammarFileName, "adding_operator"); }
		return retval;

	}
	// $ANTLR end "adding_operator"

	partial void EnterRule_aggregate();
	partial void LeaveRule_aggregate();

	// $ANTLR start "aggregate"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:275:1: aggregate : LPAREN element_association ( COMMA element_association )* RPAREN -> ^( AGGREGATE ( element_association )+ ) ;
	[GrammarRule("aggregate")]
	private AstParserRuleReturnScope<CommonTree, IToken> aggregate()
	{
		EnterRule_aggregate();
		EnterRule("aggregate", 5);
		TraceIn("aggregate", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int aggregate_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN7 = default(IToken);
		IToken COMMA9 = default(IToken);
		IToken RPAREN11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> element_association8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element_association10 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN7_tree = default(CommonTree);
		CommonTree COMMA9_tree = default(CommonTree);
		CommonTree RPAREN11_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_element_association=new RewriteRuleSubtreeStream(adaptor,"rule element_association");
		try { DebugEnterRule(GrammarFileName, "aggregate");
		DebugLocation(275, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:276:5: ( LPAREN element_association ( COMMA element_association )* RPAREN -> ^( AGGREGATE ( element_association )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:276:9: LPAREN element_association ( COMMA element_association )* RPAREN
			{
			DebugLocation(276, 9);
			LPAREN7=(IToken)Match(input,LPAREN,Follow._LPAREN_in_aggregate3069); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN7);

			DebugLocation(276, 16);
			PushFollow(Follow._element_association_in_aggregate3071);
			element_association8=element_association();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_element_association.Add(element_association8.Tree);
			DebugLocation(276, 36);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:276:36: ( COMMA element_association )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==COMMA))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:276:38: COMMA element_association
					{
					DebugLocation(276, 38);
					COMMA9=(IToken)Match(input,COMMA,Follow._COMMA_in_aggregate3075); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA9);

					DebugLocation(276, 44);
					PushFollow(Follow._element_association_in_aggregate3077);
					element_association10=element_association();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_element_association.Add(element_association10.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(276, 67);
			RPAREN11=(IToken)Match(input,RPAREN,Follow._RPAREN_in_aggregate3082); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN11);



			{
			// AST REWRITE
			// elements: element_association
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 277:9: -> ^( AGGREGATE ( element_association )+ )
			{
				DebugLocation(277, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:277:12: ^( AGGREGATE ( element_association )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(277, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(AGGREGATE, "AGGREGATE"), root_1);

				DebugLocation(277, 25);
				if (!(stream_element_association.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_element_association.HasNext )
				{
					DebugLocation(277, 25);
					adaptor.AddChild(root_1, stream_element_association.NextTree());

				}
				stream_element_association.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregate", 5);
			LeaveRule("aggregate", 5);
			LeaveRule_aggregate();
			if (state.backtracking > 0) { Memoize(input, 5, aggregate_StartIndex); }

		}
		DebugLocation(278, 4);
		} finally { DebugExitRule(GrammarFileName, "aggregate"); }
		return retval;

	}
	// $ANTLR end "aggregate"

	partial void EnterRule_alias_declaration();
	partial void LeaveRule_alias_declaration();

	// $ANTLR start "alias_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:280:1: alias_declaration : ALIAS alias_designator ( COLON subtype_indication )? IS name ( signature )? SEMI -> ^( ALIAS alias_designator ( subtype_indication )? name ( signature )? ) ;
	[GrammarRule("alias_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> alias_declaration()
	{
		EnterRule_alias_declaration();
		EnterRule("alias_declaration", 6);
		TraceIn("alias_declaration", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int alias_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ALIAS12 = default(IToken);
		IToken COLON14 = default(IToken);
		IToken IS16 = default(IToken);
		IToken SEMI19 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> alias_designator13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication15 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signature18 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ALIAS12_tree = default(CommonTree);
		CommonTree COLON14_tree = default(CommonTree);
		CommonTree IS16_tree = default(CommonTree);
		CommonTree SEMI19_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_ALIAS=new RewriteRuleITokenStream(adaptor,"token ALIAS");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_alias_designator=new RewriteRuleSubtreeStream(adaptor,"rule alias_designator");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_signature=new RewriteRuleSubtreeStream(adaptor,"rule signature");
		try { DebugEnterRule(GrammarFileName, "alias_declaration");
		DebugLocation(280, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:5: ( ALIAS alias_designator ( COLON subtype_indication )? IS name ( signature )? SEMI -> ^( ALIAS alias_designator ( subtype_indication )? name ( signature )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:9: ALIAS alias_designator ( COLON subtype_indication )? IS name ( signature )? SEMI
			{
			DebugLocation(281, 9);
			ALIAS12=(IToken)Match(input,ALIAS,Follow._ALIAS_in_alias_declaration3120); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ALIAS.Add(ALIAS12);

			DebugLocation(281, 15);
			PushFollow(Follow._alias_designator_in_alias_declaration3122);
			alias_designator13=alias_designator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alias_designator.Add(alias_designator13.Tree);
			DebugLocation(281, 32);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:32: ( COLON subtype_indication )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==COLON))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:34: COLON subtype_indication
				{
				DebugLocation(281, 34);
				COLON14=(IToken)Match(input,COLON,Follow._COLON_in_alias_declaration3126); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON14);

				DebugLocation(281, 40);
				PushFollow(Follow._subtype_indication_in_alias_declaration3128);
				subtype_indication15=subtype_indication();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication15.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(281, 62);
			IS16=(IToken)Match(input,IS,Follow._IS_in_alias_declaration3133); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS16);

			DebugLocation(281, 65);
			PushFollow(Follow._name_in_alias_declaration3135);
			name17=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name17.Tree);
			DebugLocation(281, 70);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:70: ( signature )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==LBRACKET))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:281:70: signature
				{
				DebugLocation(281, 70);
				PushFollow(Follow._signature_in_alias_declaration3137);
				signature18=signature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_signature.Add(signature18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(281, 81);
			SEMI19=(IToken)Match(input,SEMI,Follow._SEMI_in_alias_declaration3140); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI19);



			{
			// AST REWRITE
			// elements: signature, ALIAS, alias_designator, subtype_indication, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 282:9: -> ^( ALIAS alias_designator ( subtype_indication )? name ( signature )? )
			{
				DebugLocation(282, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:282:12: ^( ALIAS alias_designator ( subtype_indication )? name ( signature )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(282, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ALIAS.NextNode(), root_1);

				DebugLocation(282, 21);
				adaptor.AddChild(root_1, stream_alias_designator.NextTree());
				DebugLocation(282, 38);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:282:38: ( subtype_indication )?
				if (stream_subtype_indication.HasNext)
				{
					DebugLocation(282, 38);
					adaptor.AddChild(root_1, stream_subtype_indication.NextTree());

				}
				stream_subtype_indication.Reset();
				DebugLocation(282, 58);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(282, 63);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:282:63: ( signature )?
				if (stream_signature.HasNext)
				{
					DebugLocation(282, 63);
					adaptor.AddChild(root_1, stream_signature.NextTree());

				}
				stream_signature.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alias_declaration", 6);
			LeaveRule("alias_declaration", 6);
			LeaveRule_alias_declaration();
			if (state.backtracking > 0) { Memoize(input, 6, alias_declaration_StartIndex); }

		}
		DebugLocation(283, 4);
		} finally { DebugExitRule(GrammarFileName, "alias_declaration"); }
		return retval;

	}
	// $ANTLR end "alias_declaration"

	partial void EnterRule_alias_designator();
	partial void LeaveRule_alias_designator();

	// $ANTLR start "alias_designator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:285:1: alias_designator : ( identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL );
	[GrammarRule("alias_designator")]
	private AstParserRuleReturnScope<CommonTree, IToken> alias_designator()
	{
		EnterRule_alias_designator();
		EnterRule("alias_designator", 7);
		TraceIn("alias_designator", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int alias_designator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken operator_symbol = default(IToken);
		IToken CHARACTER_LITERAL21 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree operator_symbol_tree = default(CommonTree);
		CommonTree CHARACTER_LITERAL21_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "alias_designator");
		DebugLocation(285, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:286:5: ( identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL )
			int alt5=3;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				alt5 = 1;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt5 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt5 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:286:9: identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(286, 9);
				PushFollow(Follow._identifier_in_alias_designator3185);
				identifier20=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier20.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:287:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(287, 9);
				CHARACTER_LITERAL21=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_alias_designator3195); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL21_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL21);
				adaptor.AddChild(root_0, CHARACTER_LITERAL21_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:288:9: operator_symbol= STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(288, 24);
				operator_symbol=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_alias_designator3207); if (state.failed) return retval;
				if (state.backtracking == 0) {
				operator_symbol_tree = (CommonTree)adaptor.Create(operator_symbol);
				adaptor.AddChild(root_0, operator_symbol_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alias_designator", 7);
			LeaveRule("alias_designator", 7);
			LeaveRule_alias_designator();
			if (state.backtracking > 0) { Memoize(input, 7, alias_designator_StartIndex); }

		}
		DebugLocation(289, 4);
		} finally { DebugExitRule(GrammarFileName, "alias_designator"); }
		return retval;

	}
	// $ANTLR end "alias_designator"

	partial void EnterRule_allocator();
	partial void LeaveRule_allocator();

	// $ANTLR start "allocator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:293:1: allocator : NEW n1= name_without_parens ( (n2= name_without_parens )? ( index_constraint )? -> ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) ) | qualified_expression -> ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) ) ) ;
	[GrammarRule("allocator")]
	private AstParserRuleReturnScope<CommonTree, IToken> allocator()
	{
		EnterRule_allocator();
		EnterRule("allocator", 8);
		TraceIn("allocator", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int allocator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken NEW22 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> n1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> n2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> index_constraint23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qualified_expression24 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEW22_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleSubtreeStream stream_qualified_expression=new RewriteRuleSubtreeStream(adaptor,"rule qualified_expression");
		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_index_constraint=new RewriteRuleSubtreeStream(adaptor,"rule index_constraint");
		try { DebugEnterRule(GrammarFileName, "allocator");
		DebugLocation(293, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:294:5: ( NEW n1= name_without_parens ( (n2= name_without_parens )? ( index_constraint )? -> ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) ) | qualified_expression -> ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) ) ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:294:9: NEW n1= name_without_parens ( (n2= name_without_parens )? ( index_constraint )? -> ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) ) | qualified_expression -> ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) ) )
			{
			DebugLocation(294, 9);
			NEW22=(IToken)Match(input,NEW,Follow._NEW_in_allocator3228); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEW.Add(NEW22);

			DebugLocation(294, 15);
			PushFollow(Follow._name_without_parens_in_allocator3232);
			n1=name_without_parens();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_without_parens.Add(n1.Tree);
			DebugLocation(295, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:295:9: ( (n2= name_without_parens )? ( index_constraint )? -> ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) ) | qualified_expression -> ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) ) )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==AFTER||(LA8_0>=AMPERSAND && LA8_0<=AND)||LA8_0==ARROW||LA8_0==BAR||LA8_0==BASIC_IDENTIFIER||LA8_0==BUS||LA8_0==COMMA||LA8_0==DIV||(LA8_0>=DOUBLESTAR && LA8_0<=ELSE)||(LA8_0>=EQ && LA8_0<=EXCLAMATION)||LA8_0==EXTENDED_IDENTIFIER||LA8_0==FOR||(LA8_0>=GE && LA8_0<=GENERATE)||LA8_0==GT||LA8_0==INERTIAL||LA8_0==IS||LA8_0==LE||LA8_0==LOOP||(LA8_0>=LPAREN && LA8_0<=LT)||(LA8_0>=MINUS && LA8_0<=MUL)||(LA8_0>=NAND && LA8_0<=NEQ)||LA8_0==NOR||(LA8_0>=OPEN && LA8_0<=OR)||LA8_0==PLUS||LA8_0==REGISTER||(LA8_0>=REM && LA8_0<=REPORT)||(LA8_0>=ROL && LA8_0<=SELECT)||(LA8_0>=SEMI && LA8_0<=SEVERITY)||(LA8_0>=SLA && LA8_0<=SLL)||(LA8_0>=SRA && LA8_0<=STRING_LITERAL)||(LA8_0>=THEN && LA8_0<=TO)||LA8_0==UNITS||LA8_0==VARASGN||LA8_0==WHEN||(LA8_0>=XNOR && LA8_0<=XOR)))
			{
				alt8 = 1;
			}
			else if ((LA8_0==APOSTROPHE))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:296:17: (n2= name_without_parens )? ( index_constraint )?
				{
				DebugLocation(296, 19);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:296:19: (n2= name_without_parens )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==BASIC_IDENTIFIER||LA6_0==EXTENDED_IDENTIFIER||LA6_0==STRING_LITERAL))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:296:19: n2= name_without_parens
					{
					DebugLocation(296, 19);
					PushFollow(Follow._name_without_parens_in_allocator3262);
					n2=name_without_parens();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name_without_parens.Add(n2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(6); }

				DebugLocation(296, 41);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:296:41: ( index_constraint )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==LPAREN))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:296:41: index_constraint
					{
					DebugLocation(296, 41);
					PushFollow(Follow._index_constraint_in_allocator3265);
					index_constraint23=index_constraint();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_index_constraint.Add(index_constraint23.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(7); }



				{
				// AST REWRITE
				// elements: NEW, n2, n1, index_constraint
				// token labels: 
				// rule labels: n1, retval, n2
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_n1=new RewriteRuleSubtreeStream(adaptor,"rule n1",n1!=null?n1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_n2=new RewriteRuleSubtreeStream(adaptor,"rule n2",n2!=null?n2.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 298:17: -> ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) )
				{
					DebugLocation(298, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:298:20: ^( NEW ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(298, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_NEW.NextNode(), root_1);

					DebugLocation(298, 27);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:298:27: ^( SUBTYPE_INDICATION ( $n2)? $n1 ( index_constraint )? )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(298, 30);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SUBTYPE_INDICATION, "SUBTYPE_INDICATION"), root_2);

					DebugLocation(298, 50);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:298:50: ( $n2)?
					if (stream_n2.HasNext)
					{
						DebugLocation(298, 50);
						adaptor.AddChild(root_2, stream_n2.NextTree());

					}
					stream_n2.Reset();
					DebugLocation(298, 55);
					adaptor.AddChild(root_2, stream_n1.NextTree());
					DebugLocation(298, 58);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:298:58: ( index_constraint )?
					if (stream_index_constraint.HasNext)
					{
						DebugLocation(298, 58);
						adaptor.AddChild(root_2, stream_index_constraint.NextTree());

					}
					stream_index_constraint.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:299:17: qualified_expression
				{
				DebugLocation(299, 17);
				PushFollow(Follow._qualified_expression_in_allocator3341);
				qualified_expression24=qualified_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_qualified_expression.Add(qualified_expression24.Tree);


				{
				// AST REWRITE
				// elements: n1, qualified_expression, NEW
				// token labels: 
				// rule labels: n1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_n1=new RewriteRuleSubtreeStream(adaptor,"rule n1",n1!=null?n1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 300:17: -> ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) )
				{
					DebugLocation(300, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:300:20: ^( NEW ^( QUALIFIED_EXPRESSION $n1 qualified_expression ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(300, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_NEW.NextNode(), root_1);

					DebugLocation(300, 27);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:300:27: ^( QUALIFIED_EXPRESSION $n1 qualified_expression )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(300, 30);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(QUALIFIED_EXPRESSION, "QUALIFIED_EXPRESSION"), root_2);

					DebugLocation(300, 52);
					adaptor.AddChild(root_2, stream_n1.NextTree());
					DebugLocation(300, 55);
					adaptor.AddChild(root_2, stream_qualified_expression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("allocator", 8);
			LeaveRule("allocator", 8);
			LeaveRule_allocator();
			if (state.backtracking > 0) { Memoize(input, 8, allocator_StartIndex); }

		}
		DebugLocation(302, 4);
		} finally { DebugExitRule(GrammarFileName, "allocator"); }
		return retval;

	}
	// $ANTLR end "allocator"

	partial void EnterRule_architecture_body();
	partial void LeaveRule_architecture_body();

	// $ANTLR start "architecture_body"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:306:1: architecture_body : ARCHITECTURE identifier OF entity= name IS (adp= architecture_declarative_part )? BEGIN (asp= architecture_statement_part )? END ( ARCHITECTURE )? ( end_identifier )? SEMI -> ^( ARCHITECTURE identifier $entity ( $adp)? ( $asp)? ( end_identifier )? ) ;
	[GrammarRule("architecture_body")]
	private AstParserRuleReturnScope<CommonTree, IToken> architecture_body()
	{
		EnterRule_architecture_body();
		EnterRule("architecture_body", 9);
		TraceIn("architecture_body", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int architecture_body_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ARCHITECTURE25 = default(IToken);
		IToken OF27 = default(IToken);
		IToken IS28 = default(IToken);
		IToken BEGIN29 = default(IToken);
		IToken END30 = default(IToken);
		IToken ARCHITECTURE31 = default(IToken);
		IToken SEMI33 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> adp = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> asp = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier26 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier32 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ARCHITECTURE25_tree = default(CommonTree);
		CommonTree OF27_tree = default(CommonTree);
		CommonTree IS28_tree = default(CommonTree);
		CommonTree BEGIN29_tree = default(CommonTree);
		CommonTree END30_tree = default(CommonTree);
		CommonTree ARCHITECTURE31_tree = default(CommonTree);
		CommonTree SEMI33_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ARCHITECTURE=new RewriteRuleITokenStream(adaptor,"token ARCHITECTURE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_architecture_statement_part=new RewriteRuleSubtreeStream(adaptor,"rule architecture_statement_part");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_architecture_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule architecture_declarative_part");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "architecture_body");
		DebugLocation(306, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:307:5: ( ARCHITECTURE identifier OF entity= name IS (adp= architecture_declarative_part )? BEGIN (asp= architecture_statement_part )? END ( ARCHITECTURE )? ( end_identifier )? SEMI -> ^( ARCHITECTURE identifier $entity ( $adp)? ( $asp)? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:307:9: ARCHITECTURE identifier OF entity= name IS (adp= architecture_declarative_part )? BEGIN (asp= architecture_statement_part )? END ( ARCHITECTURE )? ( end_identifier )? SEMI
			{
			DebugLocation(307, 9);
			ARCHITECTURE25=(IToken)Match(input,ARCHITECTURE,Follow._ARCHITECTURE_in_architecture_body3407); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ARCHITECTURE.Add(ARCHITECTURE25);

			DebugLocation(307, 22);
			PushFollow(Follow._identifier_in_architecture_body3409);
			identifier26=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier26.Tree);
			DebugLocation(307, 33);
			OF27=(IToken)Match(input,OF,Follow._OF_in_architecture_body3411); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF27);

			DebugLocation(307, 42);
			PushFollow(Follow._name_in_architecture_body3415);
			entity=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(entity.Tree);
			DebugLocation(307, 48);
			IS28=(IToken)Match(input,IS,Follow._IS_in_architecture_body3417); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS28);

			DebugLocation(308, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:308:12: (adp= architecture_declarative_part )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==ALIAS||LA9_0==ATTRIBUTE||LA9_0==COMPONENT||LA9_0==CONSTANT||LA9_0==DISCONNECT||LA9_0==FILE||LA9_0==FOR||LA9_0==FUNCTION||LA9_0==GROUP||LA9_0==IMPURE||LA9_0==PROCEDURE||LA9_0==PURE||(LA9_0>=SHARED && LA9_0<=SIGNAL)||LA9_0==SUBTYPE||LA9_0==TYPE||LA9_0==USE||LA9_0==VARIABLE))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:308:12: adp= architecture_declarative_part
				{
				DebugLocation(308, 12);
				PushFollow(Follow._architecture_declarative_part_in_architecture_body3429);
				adp=architecture_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_architecture_declarative_part.Add(adp.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(309, 9);
			BEGIN29=(IToken)Match(input,BEGIN,Follow._BEGIN_in_architecture_body3440); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BEGIN.Add(BEGIN29);

			DebugLocation(310, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:310:12: (asp= architecture_statement_part )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==ASSERT||LA10_0==BASIC_IDENTIFIER||LA10_0==EXTENDED_IDENTIFIER||LA10_0==LPAREN||LA10_0==POSTPONED||LA10_0==PROCESS||LA10_0==STRING_LITERAL||LA10_0==WITH))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:310:12: asp= architecture_statement_part
				{
				DebugLocation(310, 12);
				PushFollow(Follow._architecture_statement_part_in_architecture_body3452);
				asp=architecture_statement_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_architecture_statement_part.Add(asp.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(311, 9);
			END30=(IToken)Match(input,END,Follow._END_in_architecture_body3463); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END30);

			DebugLocation(311, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:311:13: ( ARCHITECTURE )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==ARCHITECTURE))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:311:13: ARCHITECTURE
				{
				DebugLocation(311, 13);
				ARCHITECTURE31=(IToken)Match(input,ARCHITECTURE,Follow._ARCHITECTURE_in_architecture_body3465); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARCHITECTURE.Add(ARCHITECTURE31);


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(311, 27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:311:27: ( end_identifier )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==BASIC_IDENTIFIER||LA12_0==EXTENDED_IDENTIFIER))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:311:27: end_identifier
				{
				DebugLocation(311, 27);
				PushFollow(Follow._end_identifier_in_architecture_body3468);
				end_identifier32=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier32.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(311, 43);
			SEMI33=(IToken)Match(input,SEMI,Follow._SEMI_in_architecture_body3471); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI33);



			{
			// AST REWRITE
			// elements: identifier, entity, ARCHITECTURE, end_identifier, asp, adp
			// token labels: 
			// rule labels: adp, retval, entity, asp
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_adp=new RewriteRuleSubtreeStream(adaptor,"rule adp",adp!=null?adp.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_entity=new RewriteRuleSubtreeStream(adaptor,"rule entity",entity!=null?entity.Tree:null);
			RewriteRuleSubtreeStream stream_asp=new RewriteRuleSubtreeStream(adaptor,"rule asp",asp!=null?asp.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 312:9: -> ^( ARCHITECTURE identifier $entity ( $adp)? ( $asp)? ( end_identifier )? )
			{
				DebugLocation(312, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:312:12: ^( ARCHITECTURE identifier $entity ( $adp)? ( $asp)? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(312, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ARCHITECTURE.NextNode(), root_1);

				DebugLocation(312, 28);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(312, 40);
				adaptor.AddChild(root_1, stream_entity.NextTree());
				DebugLocation(312, 48);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:312:48: ( $adp)?
				if (stream_adp.HasNext)
				{
					DebugLocation(312, 48);
					adaptor.AddChild(root_1, stream_adp.NextTree());

				}
				stream_adp.Reset();
				DebugLocation(312, 54);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:312:54: ( $asp)?
				if (stream_asp.HasNext)
				{
					DebugLocation(312, 54);
					adaptor.AddChild(root_1, stream_asp.NextTree());

				}
				stream_asp.Reset();
				DebugLocation(312, 59);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:312:59: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(312, 59);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("architecture_body", 9);
			LeaveRule("architecture_body", 9);
			LeaveRule_architecture_body();
			if (state.backtracking > 0) { Memoize(input, 9, architecture_body_StartIndex); }

		}
		DebugLocation(313, 4);
		} finally { DebugExitRule(GrammarFileName, "architecture_body"); }
		return retval;

	}
	// $ANTLR end "architecture_body"

	partial void EnterRule_architecture_declarative_part();
	partial void LeaveRule_architecture_declarative_part();

	// $ANTLR start "architecture_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:314:1: architecture_declarative_part : ( block_declarative_item )+ ;
	[GrammarRule("architecture_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> architecture_declarative_part()
	{
		EnterRule_architecture_declarative_part();
		EnterRule("architecture_declarative_part", 10);
		TraceIn("architecture_declarative_part", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int architecture_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block_declarative_item34 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "architecture_declarative_part");
		DebugLocation(314, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:315:2: ( ( block_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:315:6: ( block_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(315, 6);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:315:6: ( block_declarative_item )+
			int cnt13=0;
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==ALIAS||LA13_0==ATTRIBUTE||LA13_0==COMPONENT||LA13_0==CONSTANT||LA13_0==DISCONNECT||LA13_0==FILE||LA13_0==FOR||LA13_0==FUNCTION||LA13_0==GROUP||LA13_0==IMPURE||LA13_0==PROCEDURE||LA13_0==PURE||(LA13_0>=SHARED && LA13_0<=SIGNAL)||LA13_0==SUBTYPE||LA13_0==TYPE||LA13_0==USE||LA13_0==VARIABLE))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:315:6: block_declarative_item
					{
					DebugLocation(315, 6);
					PushFollow(Follow._block_declarative_item_in_architecture_declarative_part3518);
					block_declarative_item34=block_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, block_declarative_item34.Tree);

					}
					break;

				default:
					if (cnt13 >= 1)
						goto loop13;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee13 = new EarlyExitException( 13, input );
					DebugRecognitionException(eee13);
					throw eee13;
				}
				cnt13++;
			}
			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("architecture_declarative_part", 10);
			LeaveRule("architecture_declarative_part", 10);
			LeaveRule_architecture_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 10, architecture_declarative_part_StartIndex); }

		}
		DebugLocation(316, 1);
		} finally { DebugExitRule(GrammarFileName, "architecture_declarative_part"); }
		return retval;

	}
	// $ANTLR end "architecture_declarative_part"

	partial void EnterRule_architecture_statement_part();
	partial void LeaveRule_architecture_statement_part();

	// $ANTLR start "architecture_statement_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:318:1: architecture_statement_part : ( concurrent_statement )+ ;
	[GrammarRule("architecture_statement_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> architecture_statement_part()
	{
		EnterRule_architecture_statement_part();
		EnterRule("architecture_statement_part", 11);
		TraceIn("architecture_statement_part", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int architecture_statement_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "architecture_statement_part");
		DebugLocation(318, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:319:2: ( ( concurrent_statement )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:319:6: ( concurrent_statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(319, 6);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:319:6: ( concurrent_statement )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ASSERT||LA14_0==BASIC_IDENTIFIER||LA14_0==EXTENDED_IDENTIFIER||LA14_0==LPAREN||LA14_0==POSTPONED||LA14_0==PROCESS||LA14_0==STRING_LITERAL||LA14_0==WITH))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:319:6: concurrent_statement
					{
					DebugLocation(319, 6);
					PushFollow(Follow._concurrent_statement_in_architecture_statement_part3532);
					concurrent_statement35=concurrent_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_statement35.Tree);

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("architecture_statement_part", 11);
			LeaveRule("architecture_statement_part", 11);
			LeaveRule_architecture_statement_part();
			if (state.backtracking > 0) { Memoize(input, 11, architecture_statement_part_StartIndex); }

		}
		DebugLocation(320, 1);
		} finally { DebugExitRule(GrammarFileName, "architecture_statement_part"); }
		return retval;

	}
	// $ANTLR end "architecture_statement_part"

	partial void EnterRule_array_type_definition();
	partial void LeaveRule_array_type_definition();

	// $ANTLR start "array_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:323:1: array_type_definition : ARRAY ! ( ( LPAREN index_subtype_definition )=> unconstrained_array_definition | constrained_array_definition ) ;
	[GrammarRule("array_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> array_type_definition()
	{
		EnterRule_array_type_definition();
		EnterRule("array_type_definition", 12);
		TraceIn("array_type_definition", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int array_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ARRAY36 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unconstrained_array_definition37 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constrained_array_definition38 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ARRAY36_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "array_type_definition");
		DebugLocation(323, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:324:5: ( ARRAY ! ( ( LPAREN index_subtype_definition )=> unconstrained_array_definition | constrained_array_definition ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:324:9: ARRAY ! ( ( LPAREN index_subtype_definition )=> unconstrained_array_definition | constrained_array_definition )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(324, 14);
			ARRAY36=(IToken)Match(input,ARRAY,Follow._ARRAY_in_array_type_definition3550); if (state.failed) return retval;
			DebugLocation(325, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:325:9: ( ( LPAREN index_subtype_definition )=> unconstrained_array_definition | constrained_array_definition )
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==LPAREN))
			{
				int LA15_1 = input.LA(2);

				if ((EvaluatePredicate(synpred1_VhdlAntlr_fragment)))
				{
					alt15 = 1;
				}
				else if ((true))
				{
					alt15 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:326:17: ( LPAREN index_subtype_definition )=> unconstrained_array_definition
				{
				DebugLocation(326, 53);
				PushFollow(Follow._unconstrained_array_definition_in_array_type_definition3586);
				unconstrained_array_definition37=unconstrained_array_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unconstrained_array_definition37.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:327:17: constrained_array_definition
				{
				DebugLocation(327, 17);
				PushFollow(Follow._constrained_array_definition_in_array_type_definition3604);
				constrained_array_definition38=constrained_array_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constrained_array_definition38.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_type_definition", 12);
			LeaveRule("array_type_definition", 12);
			LeaveRule_array_type_definition();
			if (state.backtracking > 0) { Memoize(input, 12, array_type_definition_StartIndex); }

		}
		DebugLocation(329, 4);
		} finally { DebugExitRule(GrammarFileName, "array_type_definition"); }
		return retval;

	}
	// $ANTLR end "array_type_definition"

	partial void EnterRule_assertion();
	partial void LeaveRule_assertion();

	// $ANTLR start "assertion"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:331:1: assertion : ASSERT condition ( REPORT report= expression )? ( SEVERITY severity= expression )? -> ^( ASSERT condition ^( REPORT[] ( $report)? ) ^( SEVERITY[] ( $severity)? ) ) ;
	[GrammarRule("assertion")]
	private AstParserRuleReturnScope<CommonTree, IToken> assertion()
	{
		EnterRule_assertion();
		EnterRule("assertion", 13);
		TraceIn("assertion", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assertion_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ASSERT39 = default(IToken);
		IToken REPORT41 = default(IToken);
		IToken SEVERITY42 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> report = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> severity = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition40 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ASSERT39_tree = default(CommonTree);
		CommonTree REPORT41_tree = default(CommonTree);
		CommonTree SEVERITY42_tree = default(CommonTree);
		RewriteRuleITokenStream stream_REPORT=new RewriteRuleITokenStream(adaptor,"token REPORT");
		RewriteRuleITokenStream stream_SEVERITY=new RewriteRuleITokenStream(adaptor,"token SEVERITY");
		RewriteRuleITokenStream stream_ASSERT=new RewriteRuleITokenStream(adaptor,"token ASSERT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "assertion");
		DebugLocation(331, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:5: ( ASSERT condition ( REPORT report= expression )? ( SEVERITY severity= expression )? -> ^( ASSERT condition ^( REPORT[] ( $report)? ) ^( SEVERITY[] ( $severity)? ) ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:9: ASSERT condition ( REPORT report= expression )? ( SEVERITY severity= expression )?
			{
			DebugLocation(332, 9);
			ASSERT39=(IToken)Match(input,ASSERT,Follow._ASSERT_in_assertion3633); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSERT.Add(ASSERT39);

			DebugLocation(332, 16);
			PushFollow(Follow._condition_in_assertion3635);
			condition40=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition40.Tree);
			DebugLocation(332, 26);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:26: ( REPORT report= expression )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==REPORT))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:28: REPORT report= expression
				{
				DebugLocation(332, 28);
				REPORT41=(IToken)Match(input,REPORT,Follow._REPORT_in_assertion3639); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_REPORT.Add(REPORT41);

				DebugLocation(332, 41);
				PushFollow(Follow._expression_in_assertion3643);
				report=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(report.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(332, 56);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:56: ( SEVERITY severity= expression )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==SEVERITY))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:332:58: SEVERITY severity= expression
				{
				DebugLocation(332, 58);
				SEVERITY42=(IToken)Match(input,SEVERITY,Follow._SEVERITY_in_assertion3650); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEVERITY.Add(SEVERITY42);

				DebugLocation(332, 75);
				PushFollow(Follow._expression_in_assertion3654);
				severity=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(severity.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: report, REPORT, ASSERT, severity, SEVERITY, condition
			// token labels: 
			// rule labels: retval, report, severity
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_report=new RewriteRuleSubtreeStream(adaptor,"rule report",report!=null?report.Tree:null);
			RewriteRuleSubtreeStream stream_severity=new RewriteRuleSubtreeStream(adaptor,"rule severity",severity!=null?severity.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 333:9: -> ^( ASSERT condition ^( REPORT[] ( $report)? ) ^( SEVERITY[] ( $severity)? ) )
			{
				DebugLocation(333, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:333:12: ^( ASSERT condition ^( REPORT[] ( $report)? ) ^( SEVERITY[] ( $severity)? ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(333, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSERT.NextNode(), root_1);

				DebugLocation(333, 22);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(333, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:333:32: ^( REPORT[] ( $report)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(333, 35);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REPORT, "REPORT"), root_2);

				DebugLocation(333, 45);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:333:45: ( $report)?
				if (stream_report.HasNext)
				{
					DebugLocation(333, 45);
					adaptor.AddChild(root_2, stream_report.NextTree());

				}
				stream_report.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(333, 55);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:333:55: ^( SEVERITY[] ( $severity)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(333, 58);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SEVERITY, "SEVERITY"), root_2);

				DebugLocation(333, 70);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:333:70: ( $severity)?
				if (stream_severity.HasNext)
				{
					DebugLocation(333, 70);
					adaptor.AddChild(root_2, stream_severity.NextTree());

				}
				stream_severity.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assertion", 13);
			LeaveRule("assertion", 13);
			LeaveRule_assertion();
			if (state.backtracking > 0) { Memoize(input, 13, assertion_StartIndex); }

		}
		DebugLocation(334, 4);
		} finally { DebugExitRule(GrammarFileName, "assertion"); }
		return retval;

	}
	// $ANTLR end "assertion"

	partial void EnterRule_assertion_statement();
	partial void LeaveRule_assertion_statement();

	// $ANTLR start "assertion_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:336:1: assertion_statement : assertion SEMI -> assertion ;
	[GrammarRule("assertion_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> assertion_statement()
	{
		EnterRule_assertion_statement();
		EnterRule("assertion_statement", 14);
		TraceIn("assertion_statement", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assertion_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI44 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assertion43 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI44_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		try { DebugEnterRule(GrammarFileName, "assertion_statement");
		DebugLocation(336, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:337:5: ( assertion SEMI -> assertion )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:337:9: assertion SEMI
			{
			DebugLocation(337, 9);
			PushFollow(Follow._assertion_in_assertion_statement3716);
			assertion43=assertion();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assertion.Add(assertion43.Tree);
			DebugLocation(337, 19);
			SEMI44=(IToken)Match(input,SEMI,Follow._SEMI_in_assertion_statement3718); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI44);



			{
			// AST REWRITE
			// elements: assertion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 338:9: -> assertion
			{
				DebugLocation(338, 12);
				adaptor.AddChild(root_0, stream_assertion.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assertion_statement", 14);
			LeaveRule("assertion_statement", 14);
			LeaveRule_assertion_statement();
			if (state.backtracking > 0) { Memoize(input, 14, assertion_statement_StartIndex); }

		}
		DebugLocation(339, 4);
		} finally { DebugExitRule(GrammarFileName, "assertion_statement"); }
		return retval;

	}
	// $ANTLR end "assertion_statement"

	partial void EnterRule_association_element();
	partial void LeaveRule_association_element();

	// $ANTLR start "association_element"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:341:1: association_element : ( ( formal_part ARROW )=> formal_part ARROW )? actual_part -> ( formal_part )? actual_part ;
	[GrammarRule("association_element")]
	private AstParserRuleReturnScope<CommonTree, IToken> association_element()
	{
		EnterRule_association_element();
		EnterRule("association_element", 15);
		TraceIn("association_element", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int association_element_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ARROW46 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> formal_part45 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> actual_part47 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ARROW46_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ARROW=new RewriteRuleITokenStream(adaptor,"token ARROW");
		RewriteRuleSubtreeStream stream_actual_part=new RewriteRuleSubtreeStream(adaptor,"rule actual_part");
		RewriteRuleSubtreeStream stream_formal_part=new RewriteRuleSubtreeStream(adaptor,"rule formal_part");
		try { DebugEnterRule(GrammarFileName, "association_element");
		DebugLocation(341, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:5: ( ( ( formal_part ARROW )=> formal_part ARROW )? actual_part -> ( formal_part )? actual_part )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:9: ( ( formal_part ARROW )=> formal_part ARROW )? actual_part
			{
			DebugLocation(342, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:9: ( ( formal_part ARROW )=> formal_part ARROW )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==BASIC_IDENTIFIER||LA18_0==EXTENDED_IDENTIFIER))
			{
				int LA18_1 = input.LA(2);

				if ((EvaluatePredicate(synpred2_VhdlAntlr_fragment)))
				{
					alt18 = 1;
				}
			}
			else if ((LA18_0==STRING_LITERAL))
			{
				int LA18_2 = input.LA(2);

				if ((EvaluatePredicate(synpred2_VhdlAntlr_fragment)))
				{
					alt18 = 1;
				}
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:11: ( formal_part ARROW )=> formal_part ARROW
				{
				DebugLocation(342, 33);
				PushFollow(Follow._formal_part_in_association_element3758);
				formal_part45=formal_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_formal_part.Add(formal_part45.Tree);
				DebugLocation(342, 45);
				ARROW46=(IToken)Match(input,ARROW,Follow._ARROW_in_association_element3760); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARROW.Add(ARROW46);


				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(342, 54);
			PushFollow(Follow._actual_part_in_association_element3765);
			actual_part47=actual_part();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_actual_part.Add(actual_part47.Tree);


			{
			// AST REWRITE
			// elements: actual_part, formal_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 343:9: -> ( formal_part )? actual_part
			{
				DebugLocation(343, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:343:12: ( formal_part )?
				if (stream_formal_part.HasNext)
				{
					DebugLocation(343, 12);
					adaptor.AddChild(root_0, stream_formal_part.NextTree());

				}
				stream_formal_part.Reset();
				DebugLocation(343, 25);
				adaptor.AddChild(root_0, stream_actual_part.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("association_element", 15);
			LeaveRule("association_element", 15);
			LeaveRule_association_element();
			if (state.backtracking > 0) { Memoize(input, 15, association_element_StartIndex); }

		}
		DebugLocation(344, 4);
		} finally { DebugExitRule(GrammarFileName, "association_element"); }
		return retval;

	}
	// $ANTLR end "association_element"

	partial void EnterRule_association_list();
	partial void LeaveRule_association_list();

	// $ANTLR start "association_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:346:1: association_list : association_element ( COMMA association_element )* -> ^( ASSOCIATION_LIST ( association_element )+ ) ;
	[GrammarRule("association_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> association_list()
	{
		EnterRule_association_list();
		EnterRule("association_list", 16);
		TraceIn("association_list", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int association_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> association_element48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> association_element50 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA49_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_association_element=new RewriteRuleSubtreeStream(adaptor,"rule association_element");
		try { DebugEnterRule(GrammarFileName, "association_list");
		DebugLocation(346, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:347:5: ( association_element ( COMMA association_element )* -> ^( ASSOCIATION_LIST ( association_element )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:347:9: association_element ( COMMA association_element )*
			{
			DebugLocation(347, 9);
			PushFollow(Follow._association_element_in_association_list3799);
			association_element48=association_element();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_association_element.Add(association_element48.Tree);
			DebugLocation(347, 29);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:347:29: ( COMMA association_element )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==COMMA))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:347:31: COMMA association_element
					{
					DebugLocation(347, 31);
					COMMA49=(IToken)Match(input,COMMA,Follow._COMMA_in_association_list3803); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA49);

					DebugLocation(347, 37);
					PushFollow(Follow._association_element_in_association_list3805);
					association_element50=association_element();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_association_element.Add(association_element50.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: association_element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 348:9: -> ^( ASSOCIATION_LIST ( association_element )+ )
			{
				DebugLocation(348, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:348:12: ^( ASSOCIATION_LIST ( association_element )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(348, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ASSOCIATION_LIST, "ASSOCIATION_LIST"), root_1);

				DebugLocation(348, 32);
				if (!(stream_association_element.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_association_element.HasNext )
				{
					DebugLocation(348, 32);
					adaptor.AddChild(root_1, stream_association_element.NextTree());

				}
				stream_association_element.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("association_list", 16);
			LeaveRule("association_list", 16);
			LeaveRule_association_list();
			if (state.backtracking > 0) { Memoize(input, 16, association_list_StartIndex); }

		}
		DebugLocation(349, 4);
		} finally { DebugExitRule(GrammarFileName, "association_list"); }
		return retval;

	}
	// $ANTLR end "association_list"

	partial void EnterRule_attribute_declaration();
	partial void LeaveRule_attribute_declaration();

	// $ANTLR start "attribute_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:351:1: attribute_declaration : ATTRIBUTE identifier COLON type_mark= name SEMI -> ^( ATTRIBUTE_DECLARATION identifier $type_mark) ;
	[GrammarRule("attribute_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration()
	{
		EnterRule_attribute_declaration();
		EnterRule("attribute_declaration", 17);
		TraceIn("attribute_declaration", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int attribute_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ATTRIBUTE51 = default(IToken);
		IToken COLON53 = default(IToken);
		IToken SEMI54 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier52 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ATTRIBUTE51_tree = default(CommonTree);
		CommonTree COLON53_tree = default(CommonTree);
		CommonTree SEMI54_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_ATTRIBUTE=new RewriteRuleITokenStream(adaptor,"token ATTRIBUTE");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "attribute_declaration");
		DebugLocation(351, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:352:5: ( ATTRIBUTE identifier COLON type_mark= name SEMI -> ^( ATTRIBUTE_DECLARATION identifier $type_mark) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:352:9: ATTRIBUTE identifier COLON type_mark= name SEMI
			{
			DebugLocation(352, 9);
			ATTRIBUTE51=(IToken)Match(input,ATTRIBUTE,Follow._ATTRIBUTE_in_attribute_declaration3846); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ATTRIBUTE.Add(ATTRIBUTE51);

			DebugLocation(352, 19);
			PushFollow(Follow._identifier_in_attribute_declaration3848);
			identifier52=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier52.Tree);
			DebugLocation(352, 30);
			COLON53=(IToken)Match(input,COLON,Follow._COLON_in_attribute_declaration3850); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON53);

			DebugLocation(352, 45);
			PushFollow(Follow._name_in_attribute_declaration3854);
			type_mark=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(type_mark.Tree);
			DebugLocation(352, 51);
			SEMI54=(IToken)Match(input,SEMI,Follow._SEMI_in_attribute_declaration3856); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI54);



			{
			// AST REWRITE
			// elements: identifier, type_mark
			// token labels: 
			// rule labels: retval, type_mark
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_type_mark=new RewriteRuleSubtreeStream(adaptor,"rule type_mark",type_mark!=null?type_mark.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 353:9: -> ^( ATTRIBUTE_DECLARATION identifier $type_mark)
			{
				DebugLocation(353, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:353:12: ^( ATTRIBUTE_DECLARATION identifier $type_mark)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(353, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ATTRIBUTE_DECLARATION, "ATTRIBUTE_DECLARATION"), root_1);

				DebugLocation(353, 37);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(353, 49);
				adaptor.AddChild(root_1, stream_type_mark.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute_declaration", 17);
			LeaveRule("attribute_declaration", 17);
			LeaveRule_attribute_declaration();
			if (state.backtracking > 0) { Memoize(input, 17, attribute_declaration_StartIndex); }

		}
		DebugLocation(354, 4);
		} finally { DebugExitRule(GrammarFileName, "attribute_declaration"); }
		return retval;

	}
	// $ANTLR end "attribute_declaration"

	partial void EnterRule_attribute_designator();
	partial void LeaveRule_attribute_designator();

	// $ANTLR start "attribute_designator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:357:1: attribute_designator : (attribute_simple_name= identifier | RANGETOK -> BASIC_IDENTIFIER[$RANGETOK] );
	[GrammarRule("attribute_designator")]
	private AstParserRuleReturnScope<CommonTree, IToken> attribute_designator()
	{
		EnterRule_attribute_designator();
		EnterRule("attribute_designator", 18);
		TraceIn("attribute_designator", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int attribute_designator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken RANGETOK55 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_simple_name = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RANGETOK55_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RANGETOK=new RewriteRuleITokenStream(adaptor,"token RANGETOK");
		try { DebugEnterRule(GrammarFileName, "attribute_designator");
		DebugLocation(357, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:358:5: (attribute_simple_name= identifier | RANGETOK -> BASIC_IDENTIFIER[$RANGETOK] )
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==BASIC_IDENTIFIER||LA20_0==EXTENDED_IDENTIFIER))
			{
				alt20 = 1;
			}
			else if ((LA20_0==RANGETOK))
			{
				alt20 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:358:9: attribute_simple_name= identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(358, 30);
				PushFollow(Follow._identifier_in_attribute_designator3899);
				attribute_simple_name=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_simple_name.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:359:9: RANGETOK
				{
				DebugLocation(359, 9);
				RANGETOK55=(IToken)Match(input,RANGETOK,Follow._RANGETOK_in_attribute_designator3909); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RANGETOK.Add(RANGETOK55);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 359:18: -> BASIC_IDENTIFIER[$RANGETOK]
				{
					DebugLocation(359, 21);
					adaptor.AddChild(root_0, (CommonTree)adaptor.Create(BASIC_IDENTIFIER, RANGETOK55));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute_designator", 18);
			LeaveRule("attribute_designator", 18);
			LeaveRule_attribute_designator();
			if (state.backtracking > 0) { Memoize(input, 18, attribute_designator_StartIndex); }

		}
		DebugLocation(360, 4);
		} finally { DebugExitRule(GrammarFileName, "attribute_designator"); }
		return retval;

	}
	// $ANTLR end "attribute_designator"

	partial void EnterRule_attribute_specification();
	partial void LeaveRule_attribute_specification();

	// $ANTLR start "attribute_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:362:1: attribute_specification : ATTRIBUTE attribute_designator OF entity_specification IS expression SEMI -> ^( ATTRIBUTE_SPECIFICATION attribute_designator entity_specification expression ) ;
	[GrammarRule("attribute_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> attribute_specification()
	{
		EnterRule_attribute_specification();
		EnterRule("attribute_specification", 19);
		TraceIn("attribute_specification", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int attribute_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ATTRIBUTE56 = default(IToken);
		IToken OF58 = default(IToken);
		IToken IS60 = default(IToken);
		IToken SEMI62 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_designator57 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_specification59 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression61 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ATTRIBUTE56_tree = default(CommonTree);
		CommonTree OF58_tree = default(CommonTree);
		CommonTree IS60_tree = default(CommonTree);
		CommonTree SEMI62_tree = default(CommonTree);
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_ATTRIBUTE=new RewriteRuleITokenStream(adaptor,"token ATTRIBUTE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_entity_specification=new RewriteRuleSubtreeStream(adaptor,"rule entity_specification");
		RewriteRuleSubtreeStream stream_attribute_designator=new RewriteRuleSubtreeStream(adaptor,"rule attribute_designator");
		try { DebugEnterRule(GrammarFileName, "attribute_specification");
		DebugLocation(362, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:363:5: ( ATTRIBUTE attribute_designator OF entity_specification IS expression SEMI -> ^( ATTRIBUTE_SPECIFICATION attribute_designator entity_specification expression ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:363:9: ATTRIBUTE attribute_designator OF entity_specification IS expression SEMI
			{
			DebugLocation(363, 9);
			ATTRIBUTE56=(IToken)Match(input,ATTRIBUTE,Follow._ATTRIBUTE_in_attribute_specification3933); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ATTRIBUTE.Add(ATTRIBUTE56);

			DebugLocation(363, 19);
			PushFollow(Follow._attribute_designator_in_attribute_specification3935);
			attribute_designator57=attribute_designator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_attribute_designator.Add(attribute_designator57.Tree);
			DebugLocation(363, 40);
			OF58=(IToken)Match(input,OF,Follow._OF_in_attribute_specification3937); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF58);

			DebugLocation(363, 43);
			PushFollow(Follow._entity_specification_in_attribute_specification3939);
			entity_specification59=entity_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_specification.Add(entity_specification59.Tree);
			DebugLocation(363, 64);
			IS60=(IToken)Match(input,IS,Follow._IS_in_attribute_specification3941); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS60);

			DebugLocation(363, 67);
			PushFollow(Follow._expression_in_attribute_specification3943);
			expression61=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression61.Tree);
			DebugLocation(363, 78);
			SEMI62=(IToken)Match(input,SEMI,Follow._SEMI_in_attribute_specification3945); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI62);



			{
			// AST REWRITE
			// elements: attribute_designator, entity_specification, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 364:9: -> ^( ATTRIBUTE_SPECIFICATION attribute_designator entity_specification expression )
			{
				DebugLocation(364, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:364:12: ^( ATTRIBUTE_SPECIFICATION attribute_designator entity_specification expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(364, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ATTRIBUTE_SPECIFICATION, "ATTRIBUTE_SPECIFICATION"), root_1);

				DebugLocation(364, 39);
				adaptor.AddChild(root_1, stream_attribute_designator.NextTree());
				DebugLocation(364, 60);
				adaptor.AddChild(root_1, stream_entity_specification.NextTree());
				DebugLocation(364, 81);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute_specification", 19);
			LeaveRule("attribute_specification", 19);
			LeaveRule_attribute_specification();
			if (state.backtracking > 0) { Memoize(input, 19, attribute_specification_StartIndex); }

		}
		DebugLocation(365, 4);
		} finally { DebugExitRule(GrammarFileName, "attribute_specification"); }
		return retval;

	}
	// $ANTLR end "attribute_specification"

	partial void EnterRule_binding_indication();
	partial void LeaveRule_binding_indication();

	// $ANTLR start "binding_indication"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:367:1: binding_indication : ( USE entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )? -> ( entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )? ;
	[GrammarRule("binding_indication")]
	private AstParserRuleReturnScope<CommonTree, IToken> binding_indication()
	{
		EnterRule_binding_indication();
		EnterRule("binding_indication", 20);
		TraceIn("binding_indication", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int binding_indication_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken USE63 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity_aspect64 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> generic_map_aspect65 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> port_map_aspect66 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree USE63_tree = default(CommonTree);
		RewriteRuleITokenStream stream_USE=new RewriteRuleITokenStream(adaptor,"token USE");
		RewriteRuleSubtreeStream stream_generic_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule generic_map_aspect");
		RewriteRuleSubtreeStream stream_entity_aspect=new RewriteRuleSubtreeStream(adaptor,"rule entity_aspect");
		RewriteRuleSubtreeStream stream_port_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule port_map_aspect");
		try { DebugEnterRule(GrammarFileName, "binding_indication");
		DebugLocation(367, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:5: ( ( USE entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )? -> ( entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:9: ( USE entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )?
			{
			DebugLocation(368, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:9: ( USE entity_aspect )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==USE))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:11: USE entity_aspect
				{
				DebugLocation(368, 11);
				USE63=(IToken)Match(input,USE,Follow._USE_in_binding_indication3988); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_USE.Add(USE63);

				DebugLocation(368, 15);
				PushFollow(Follow._entity_aspect_in_binding_indication3990);
				entity_aspect64=entity_aspect();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_entity_aspect.Add(entity_aspect64.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(368, 32);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:32: ( generic_map_aspect )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==GENERIC))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:32: generic_map_aspect
				{
				DebugLocation(368, 32);
				PushFollow(Follow._generic_map_aspect_in_binding_indication3995);
				generic_map_aspect65=generic_map_aspect();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_generic_map_aspect.Add(generic_map_aspect65.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(368, 52);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:52: ( port_map_aspect )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==PORT))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:368:52: port_map_aspect
				{
				DebugLocation(368, 52);
				PushFollow(Follow._port_map_aspect_in_binding_indication3998);
				port_map_aspect66=port_map_aspect();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_port_map_aspect.Add(port_map_aspect66.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: generic_map_aspect, port_map_aspect, entity_aspect
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 369:9: -> ( entity_aspect )? ( generic_map_aspect )? ( port_map_aspect )?
			{
				DebugLocation(369, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:369:12: ( entity_aspect )?
				if (stream_entity_aspect.HasNext)
				{
					DebugLocation(369, 12);
					adaptor.AddChild(root_0, stream_entity_aspect.NextTree());

				}
				stream_entity_aspect.Reset();
				DebugLocation(369, 27);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:369:27: ( generic_map_aspect )?
				if (stream_generic_map_aspect.HasNext)
				{
					DebugLocation(369, 27);
					adaptor.AddChild(root_0, stream_generic_map_aspect.NextTree());

				}
				stream_generic_map_aspect.Reset();
				DebugLocation(369, 47);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:369:47: ( port_map_aspect )?
				if (stream_port_map_aspect.HasNext)
				{
					DebugLocation(369, 47);
					adaptor.AddChild(root_0, stream_port_map_aspect.NextTree());

				}
				stream_port_map_aspect.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binding_indication", 20);
			LeaveRule("binding_indication", 20);
			LeaveRule_binding_indication();
			if (state.backtracking > 0) { Memoize(input, 20, binding_indication_StartIndex); }

		}
		DebugLocation(370, 4);
		} finally { DebugExitRule(GrammarFileName, "binding_indication"); }
		return retval;

	}
	// $ANTLR end "binding_indication"

	partial void EnterRule_block_configuration();
	partial void LeaveRule_block_configuration();

	// $ANTLR start "block_configuration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:372:1: block_configuration : FOR block_specification ( use_clause )* ( configuration_item )* END FOR SEMI -> ^( BLOCK_CONFIGURATION block_specification ( use_clause )* ( configuration_item )* ) ;
	[GrammarRule("block_configuration")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_configuration()
	{
		EnterRule_block_configuration();
		EnterRule("block_configuration", 21);
		TraceIn("block_configuration", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_configuration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FOR67 = default(IToken);
		IToken END71 = default(IToken);
		IToken FOR72 = default(IToken);
		IToken SEMI73 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> block_specification68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause69 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> configuration_item70 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR67_tree = default(CommonTree);
		CommonTree END71_tree = default(CommonTree);
		CommonTree FOR72_tree = default(CommonTree);
		CommonTree SEMI73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_use_clause=new RewriteRuleSubtreeStream(adaptor,"rule use_clause");
		RewriteRuleSubtreeStream stream_block_specification=new RewriteRuleSubtreeStream(adaptor,"rule block_specification");
		RewriteRuleSubtreeStream stream_configuration_item=new RewriteRuleSubtreeStream(adaptor,"rule configuration_item");
		try { DebugEnterRule(GrammarFileName, "block_configuration");
		DebugLocation(372, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:373:5: ( FOR block_specification ( use_clause )* ( configuration_item )* END FOR SEMI -> ^( BLOCK_CONFIGURATION block_specification ( use_clause )* ( configuration_item )* ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:373:9: FOR block_specification ( use_clause )* ( configuration_item )* END FOR SEMI
			{
			DebugLocation(373, 9);
			FOR67=(IToken)Match(input,FOR,Follow._FOR_in_block_configuration4037); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR67);

			DebugLocation(373, 13);
			PushFollow(Follow._block_specification_in_block_configuration4039);
			block_specification68=block_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block_specification.Add(block_specification68.Tree);
			DebugLocation(374, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:374:9: ( use_clause )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==USE))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:374:9: use_clause
					{
					DebugLocation(374, 9);
					PushFollow(Follow._use_clause_in_block_configuration4049);
					use_clause69=use_clause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_use_clause.Add(use_clause69.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(375, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:375:9: ( configuration_item )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==FOR))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:375:9: configuration_item
					{
					DebugLocation(375, 9);
					PushFollow(Follow._configuration_item_in_block_configuration4060);
					configuration_item70=configuration_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_configuration_item.Add(configuration_item70.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }

			DebugLocation(376, 9);
			END71=(IToken)Match(input,END,Follow._END_in_block_configuration4071); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END71);

			DebugLocation(376, 13);
			FOR72=(IToken)Match(input,FOR,Follow._FOR_in_block_configuration4073); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR72);

			DebugLocation(376, 17);
			SEMI73=(IToken)Match(input,SEMI,Follow._SEMI_in_block_configuration4075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI73);



			{
			// AST REWRITE
			// elements: use_clause, block_specification, configuration_item
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 377:9: -> ^( BLOCK_CONFIGURATION block_specification ( use_clause )* ( configuration_item )* )
			{
				DebugLocation(377, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:377:12: ^( BLOCK_CONFIGURATION block_specification ( use_clause )* ( configuration_item )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(377, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCK_CONFIGURATION, "BLOCK_CONFIGURATION"), root_1);

				DebugLocation(377, 35);
				adaptor.AddChild(root_1, stream_block_specification.NextTree());
				DebugLocation(377, 55);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:377:55: ( use_clause )*
				while ( stream_use_clause.HasNext )
				{
					DebugLocation(377, 55);
					adaptor.AddChild(root_1, stream_use_clause.NextTree());

				}
				stream_use_clause.Reset();
				DebugLocation(377, 67);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:377:67: ( configuration_item )*
				while ( stream_configuration_item.HasNext )
				{
					DebugLocation(377, 67);
					adaptor.AddChild(root_1, stream_configuration_item.NextTree());

				}
				stream_configuration_item.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_configuration", 21);
			LeaveRule("block_configuration", 21);
			LeaveRule_block_configuration();
			if (state.backtracking > 0) { Memoize(input, 21, block_configuration_StartIndex); }

		}
		DebugLocation(378, 4);
		} finally { DebugExitRule(GrammarFileName, "block_configuration"); }
		return retval;

	}
	// $ANTLR end "block_configuration"

	partial void EnterRule_block_declarative_item();
	partial void LeaveRule_block_declarative_item();

	// $ANTLR start "block_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:380:1: block_declarative_item : ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | component_declaration | attribute_declaration | attribute_specification | configuration_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("block_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_declarative_item()
	{
		EnterRule_block_declarative_item();
		EnterRule("block_declarative_item", 22);
		TraceIn("block_declarative_item", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shared_variable_declaration = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration74 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration75 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration76 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration77 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signal_declaration78 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration79 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration80 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> component_declaration81 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration82 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification83 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> configuration_specification84 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> disconnection_specification85 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause86 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration87 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration88 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "block_declarative_item");
		DebugLocation(380, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:381:5: ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | component_declaration | attribute_declaration | attribute_specification | configuration_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration )
			int alt26=16;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt26 = 1;
				}
				break;
			case TYPE:
				{
				alt26 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt26 = 3;
				}
				break;
			case CONSTANT:
				{
				alt26 = 4;
				}
				break;
			case SIGNAL:
				{
				alt26 = 5;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt26 = 6;
				}
				break;
			case FILE:
				{
				alt26 = 7;
				}
				break;
			case ALIAS:
				{
				alt26 = 8;
				}
				break;
			case COMPONENT:
				{
				alt26 = 9;
				}
				break;
			case ATTRIBUTE:
				{
				int LA26_10 = input.LA(2);

				if ((LA26_10==BASIC_IDENTIFIER||LA26_10==EXTENDED_IDENTIFIER))
				{
					int LA26_15 = input.LA(3);

					if ((LA26_15==COLON))
					{
						alt26 = 10;
					}
					else if ((LA26_15==OF))
					{
						alt26 = 11;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 15, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA26_10==RANGETOK))
				{
					alt26 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 26, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FOR:
				{
				alt26 = 12;
				}
				break;
			case DISCONNECT:
				{
				alt26 = 13;
				}
				break;
			case USE:
				{
				alt26 = 14;
				}
				break;
			case GROUP:
				{
				int LA26_14 = input.LA(2);

				if ((LA26_14==BASIC_IDENTIFIER||LA26_14==EXTENDED_IDENTIFIER))
				{
					int LA26_17 = input.LA(3);

					if ((LA26_17==IS))
					{
						alt26 = 15;
					}
					else if ((LA26_17==COLON))
					{
						alt26 = 16;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 17, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 26, 14, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:381:9: subprogram_body_or_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(381, 9);
				PushFollow(Follow._subprogram_body_or_declaration_in_block_declarative_item4118);
				subprogram_body_or_declaration74=subprogram_body_or_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_body_or_declaration74.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:382:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(382, 9);
				PushFollow(Follow._type_declaration_in_block_declarative_item4128);
				type_declaration75=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration75.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:383:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(383, 9);
				PushFollow(Follow._subtype_declaration_in_block_declarative_item4138);
				subtype_declaration76=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration76.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:384:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(384, 9);
				PushFollow(Follow._constant_declaration_in_block_declarative_item4148);
				constant_declaration77=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration77.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:385:9: signal_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(385, 9);
				PushFollow(Follow._signal_declaration_in_block_declarative_item4158);
				signal_declaration78=signal_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, signal_declaration78.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:386:9: shared_variable_declaration= variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(386, 36);
				PushFollow(Follow._variable_declaration_in_block_declarative_item4170);
				shared_variable_declaration=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, shared_variable_declaration.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:387:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(387, 9);
				PushFollow(Follow._file_declaration_in_block_declarative_item4180);
				file_declaration79=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration79.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:388:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(388, 9);
				PushFollow(Follow._alias_declaration_in_block_declarative_item4190);
				alias_declaration80=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration80.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:389:9: component_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(389, 9);
				PushFollow(Follow._component_declaration_in_block_declarative_item4200);
				component_declaration81=component_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, component_declaration81.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:390:9: attribute_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(390, 9);
				PushFollow(Follow._attribute_declaration_in_block_declarative_item4210);
				attribute_declaration82=attribute_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_declaration82.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:391:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(391, 9);
				PushFollow(Follow._attribute_specification_in_block_declarative_item4220);
				attribute_specification83=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification83.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:392:9: configuration_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(392, 9);
				PushFollow(Follow._configuration_specification_in_block_declarative_item4230);
				configuration_specification84=configuration_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, configuration_specification84.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:393:9: disconnection_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(393, 9);
				PushFollow(Follow._disconnection_specification_in_block_declarative_item4240);
				disconnection_specification85=disconnection_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disconnection_specification85.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:394:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(394, 9);
				PushFollow(Follow._use_clause_in_block_declarative_item4250);
				use_clause86=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause86.Tree);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:395:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(395, 9);
				PushFollow(Follow._group_template_declaration_in_block_declarative_item4260);
				group_template_declaration87=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration87.Tree);

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:396:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(396, 9);
				PushFollow(Follow._group_declaration_in_block_declarative_item4270);
				group_declaration88=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration88.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_declarative_item", 22);
			LeaveRule("block_declarative_item", 22);
			LeaveRule_block_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 22, block_declarative_item_StartIndex); }

		}
		DebugLocation(397, 4);
		} finally { DebugExitRule(GrammarFileName, "block_declarative_item"); }
		return retval;

	}
	// $ANTLR end "block_declarative_item"

	partial void EnterRule_block_declarative_part();
	partial void LeaveRule_block_declarative_part();

	// $ANTLR start "block_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:399:1: block_declarative_part : ( block_declarative_item )+ ;
	[GrammarRule("block_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_declarative_part()
	{
		EnterRule_block_declarative_part();
		EnterRule("block_declarative_part", 23);
		TraceIn("block_declarative_part", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block_declarative_item89 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "block_declarative_part");
		DebugLocation(399, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:400:5: ( ( block_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:400:9: ( block_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(400, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:400:9: ( block_declarative_item )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==ALIAS||LA27_0==ATTRIBUTE||LA27_0==COMPONENT||LA27_0==CONSTANT||LA27_0==DISCONNECT||LA27_0==FILE||LA27_0==FOR||LA27_0==FUNCTION||LA27_0==GROUP||LA27_0==IMPURE||LA27_0==PROCEDURE||LA27_0==PURE||(LA27_0>=SHARED && LA27_0<=SIGNAL)||LA27_0==SUBTYPE||LA27_0==TYPE||LA27_0==USE||LA27_0==VARIABLE))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:400:9: block_declarative_item
					{
					DebugLocation(400, 9);
					PushFollow(Follow._block_declarative_item_in_block_declarative_part4289);
					block_declarative_item89=block_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, block_declarative_item89.Tree);

					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_declarative_part", 23);
			LeaveRule("block_declarative_part", 23);
			LeaveRule_block_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 23, block_declarative_part_StartIndex); }

		}
		DebugLocation(401, 4);
		} finally { DebugExitRule(GrammarFileName, "block_declarative_part"); }
		return retval;

	}
	// $ANTLR end "block_declarative_part"

	partial void EnterRule_block_header();
	partial void LeaveRule_block_header();

	// $ANTLR start "block_header"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:403:1: block_header : ( generic_clause ( generic_map_aspect SEMI )? )? ( port_clause ( port_map_aspect SEMI )? )? -> ( generic_clause )? ( generic_map_aspect )? ( port_clause )? ( port_map_aspect )? ;
	[GrammarRule("block_header")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_header()
	{
		EnterRule_block_header();
		EnterRule("block_header", 24);
		TraceIn("block_header", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_header_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI92 = default(IToken);
		IToken SEMI95 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> generic_clause90 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> generic_map_aspect91 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> port_clause93 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> port_map_aspect94 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI92_tree = default(CommonTree);
		CommonTree SEMI95_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_generic_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule generic_map_aspect");
		RewriteRuleSubtreeStream stream_generic_clause=new RewriteRuleSubtreeStream(adaptor,"rule generic_clause");
		RewriteRuleSubtreeStream stream_port_clause=new RewriteRuleSubtreeStream(adaptor,"rule port_clause");
		RewriteRuleSubtreeStream stream_port_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule port_map_aspect");
		try { DebugEnterRule(GrammarFileName, "block_header");
		DebugLocation(403, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:5: ( ( generic_clause ( generic_map_aspect SEMI )? )? ( port_clause ( port_map_aspect SEMI )? )? -> ( generic_clause )? ( generic_map_aspect )? ( port_clause )? ( port_map_aspect )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:9: ( generic_clause ( generic_map_aspect SEMI )? )? ( port_clause ( port_map_aspect SEMI )? )?
			{
			DebugLocation(404, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:9: ( generic_clause ( generic_map_aspect SEMI )? )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==GENERIC))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:11: generic_clause ( generic_map_aspect SEMI )?
				{
				DebugLocation(404, 11);
				PushFollow(Follow._generic_clause_in_block_header4311);
				generic_clause90=generic_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_generic_clause.Add(generic_clause90.Tree);
				DebugLocation(404, 26);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:26: ( generic_map_aspect SEMI )?
				int alt28=2;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==GENERIC))
				{
					alt28 = 1;
				}
				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:404:28: generic_map_aspect SEMI
					{
					DebugLocation(404, 28);
					PushFollow(Follow._generic_map_aspect_in_block_header4315);
					generic_map_aspect91=generic_map_aspect();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_generic_map_aspect.Add(generic_map_aspect91.Tree);
					DebugLocation(404, 47);
					SEMI92=(IToken)Match(input,SEMI,Follow._SEMI_in_block_header4317); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI92);


					}
					break;

				}
				} finally { DebugExitSubRule(28); }


				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(405, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:405:9: ( port_clause ( port_map_aspect SEMI )? )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_0 = input.LA(1);

			if ((LA31_0==PORT))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:405:11: port_clause ( port_map_aspect SEMI )?
				{
				DebugLocation(405, 11);
				PushFollow(Follow._port_clause_in_block_header4335);
				port_clause93=port_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_port_clause.Add(port_clause93.Tree);
				DebugLocation(405, 23);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:405:23: ( port_map_aspect SEMI )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==PORT))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:405:25: port_map_aspect SEMI
					{
					DebugLocation(405, 25);
					PushFollow(Follow._port_map_aspect_in_block_header4339);
					port_map_aspect94=port_map_aspect();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_port_map_aspect.Add(port_map_aspect94.Tree);
					DebugLocation(405, 41);
					SEMI95=(IToken)Match(input,SEMI,Follow._SEMI_in_block_header4341); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI95);


					}
					break;

				}
				} finally { DebugExitSubRule(30); }


				}
				break;

			}
			} finally { DebugExitSubRule(31); }



			{
			// AST REWRITE
			// elements: port_map_aspect, port_clause, generic_clause, generic_map_aspect
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 406:9: -> ( generic_clause )? ( generic_map_aspect )? ( port_clause )? ( port_map_aspect )?
			{
				DebugLocation(406, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:406:12: ( generic_clause )?
				if (stream_generic_clause.HasNext)
				{
					DebugLocation(406, 12);
					adaptor.AddChild(root_0, stream_generic_clause.NextTree());

				}
				stream_generic_clause.Reset();
				DebugLocation(406, 28);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:406:28: ( generic_map_aspect )?
				if (stream_generic_map_aspect.HasNext)
				{
					DebugLocation(406, 28);
					adaptor.AddChild(root_0, stream_generic_map_aspect.NextTree());

				}
				stream_generic_map_aspect.Reset();
				DebugLocation(406, 48);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:406:48: ( port_clause )?
				if (stream_port_clause.HasNext)
				{
					DebugLocation(406, 48);
					adaptor.AddChild(root_0, stream_port_clause.NextTree());

				}
				stream_port_clause.Reset();
				DebugLocation(406, 61);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:406:61: ( port_map_aspect )?
				if (stream_port_map_aspect.HasNext)
				{
					DebugLocation(406, 61);
					adaptor.AddChild(root_0, stream_port_map_aspect.NextTree());

				}
				stream_port_map_aspect.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_header", 24);
			LeaveRule("block_header", 24);
			LeaveRule_block_header();
			if (state.backtracking > 0) { Memoize(input, 24, block_header_StartIndex); }

		}
		DebugLocation(407, 4);
		} finally { DebugExitRule(GrammarFileName, "block_header"); }
		return retval;

	}
	// $ANTLR end "block_header"

	partial void EnterRule_block_specification();
	partial void LeaveRule_block_specification();

	// $ANTLR start "block_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:417:1: block_specification : name ;
	[GrammarRule("block_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_specification()
	{
		EnterRule_block_specification();
		EnterRule("block_specification", 25);
		TraceIn("block_specification", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name96 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "block_specification");
		DebugLocation(417, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:418:5: ( name )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:418:9: name
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(418, 9);
			PushFollow(Follow._name_in_block_specification4396);
			name96=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, name96.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_specification", 25);
			LeaveRule("block_specification", 25);
			LeaveRule_block_specification();
			if (state.backtracking > 0) { Memoize(input, 25, block_specification_StartIndex); }

		}
		DebugLocation(419, 4);
		} finally { DebugExitRule(GrammarFileName, "block_specification"); }
		return retval;

	}
	// $ANTLR end "block_specification"

	partial void EnterRule_block_statement();
	partial void LeaveRule_block_statement();

	// $ANTLR start "block_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:422:1: block_statement : BLOCK ( LPAREN guard_expression= expression RPAREN )? ( IS )? block_header (bdp= block_declarative_part )? BEGIN (bsp= block_statement_part )? END BLOCK ( end_identifier )? SEMI -> ^( BLOCK_STATEMENT ( $guard_expression)? ( IS )? ( block_header )? ( $bdp)? ( $bsp)? ( end_identifier )? ) ;
	[GrammarRule("block_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_statement()
	{
		EnterRule_block_statement();
		EnterRule("block_statement", 26);
		TraceIn("block_statement", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken BLOCK97 = default(IToken);
		IToken LPAREN98 = default(IToken);
		IToken RPAREN99 = default(IToken);
		IToken IS100 = default(IToken);
		IToken BEGIN102 = default(IToken);
		IToken END103 = default(IToken);
		IToken BLOCK104 = default(IToken);
		IToken SEMI106 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> guard_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bdp = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bsp = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> block_header101 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier105 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BLOCK97_tree = default(CommonTree);
		CommonTree LPAREN98_tree = default(CommonTree);
		CommonTree RPAREN99_tree = default(CommonTree);
		CommonTree IS100_tree = default(CommonTree);
		CommonTree BEGIN102_tree = default(CommonTree);
		CommonTree END103_tree = default(CommonTree);
		CommonTree BLOCK104_tree = default(CommonTree);
		CommonTree SEMI106_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_BLOCK=new RewriteRuleITokenStream(adaptor,"token BLOCK");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_block_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule block_declarative_part");
		RewriteRuleSubtreeStream stream_block_statement_part=new RewriteRuleSubtreeStream(adaptor,"rule block_statement_part");
		RewriteRuleSubtreeStream stream_block_header=new RewriteRuleSubtreeStream(adaptor,"rule block_header");
		try { DebugEnterRule(GrammarFileName, "block_statement");
		DebugLocation(422, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:5: ( BLOCK ( LPAREN guard_expression= expression RPAREN )? ( IS )? block_header (bdp= block_declarative_part )? BEGIN (bsp= block_statement_part )? END BLOCK ( end_identifier )? SEMI -> ^( BLOCK_STATEMENT ( $guard_expression)? ( IS )? ( block_header )? ( $bdp)? ( $bsp)? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:9: BLOCK ( LPAREN guard_expression= expression RPAREN )? ( IS )? block_header (bdp= block_declarative_part )? BEGIN (bsp= block_statement_part )? END BLOCK ( end_identifier )? SEMI
			{
			DebugLocation(423, 9);
			BLOCK97=(IToken)Match(input,BLOCK,Follow._BLOCK_in_block_statement4416); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BLOCK.Add(BLOCK97);

			DebugLocation(423, 15);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:15: ( LPAREN guard_expression= expression RPAREN )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_0 = input.LA(1);

			if ((LA32_0==LPAREN))
			{
				alt32 = 1;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:17: LPAREN guard_expression= expression RPAREN
				{
				DebugLocation(423, 17);
				LPAREN98=(IToken)Match(input,LPAREN,Follow._LPAREN_in_block_statement4420); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN98);

				DebugLocation(423, 40);
				PushFollow(Follow._expression_in_block_statement4424);
				guard_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(guard_expression.Tree);
				DebugLocation(423, 52);
				RPAREN99=(IToken)Match(input,RPAREN,Follow._RPAREN_in_block_statement4426); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN99);


				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(423, 62);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:62: ( IS )?
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_0 = input.LA(1);

			if ((LA33_0==IS))
			{
				alt33 = 1;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:423:62: IS
				{
				DebugLocation(423, 62);
				IS100=(IToken)Match(input,IS,Follow._IS_in_block_statement4431); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IS.Add(IS100);


				}
				break;

			}
			} finally { DebugExitSubRule(33); }

			DebugLocation(424, 9);
			PushFollow(Follow._block_header_in_block_statement4442);
			block_header101=block_header();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block_header.Add(block_header101.Tree);
			DebugLocation(425, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:425:12: (bdp= block_declarative_part )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_0 = input.LA(1);

			if ((LA34_0==ALIAS||LA34_0==ATTRIBUTE||LA34_0==COMPONENT||LA34_0==CONSTANT||LA34_0==DISCONNECT||LA34_0==FILE||LA34_0==FOR||LA34_0==FUNCTION||LA34_0==GROUP||LA34_0==IMPURE||LA34_0==PROCEDURE||LA34_0==PURE||(LA34_0>=SHARED && LA34_0<=SIGNAL)||LA34_0==SUBTYPE||LA34_0==TYPE||LA34_0==USE||LA34_0==VARIABLE))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:425:12: bdp= block_declarative_part
				{
				DebugLocation(425, 12);
				PushFollow(Follow._block_declarative_part_in_block_statement4454);
				bdp=block_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_block_declarative_part.Add(bdp.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(34); }

			DebugLocation(426, 9);
			BEGIN102=(IToken)Match(input,BEGIN,Follow._BEGIN_in_block_statement4465); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BEGIN.Add(BEGIN102);

			DebugLocation(427, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:427:12: (bsp= block_statement_part )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_0 = input.LA(1);

			if ((LA35_0==ASSERT||LA35_0==BASIC_IDENTIFIER||LA35_0==EXTENDED_IDENTIFIER||LA35_0==LPAREN||LA35_0==POSTPONED||LA35_0==PROCESS||LA35_0==STRING_LITERAL||LA35_0==WITH))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:427:12: bsp= block_statement_part
				{
				DebugLocation(427, 12);
				PushFollow(Follow._block_statement_part_in_block_statement4477);
				bsp=block_statement_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_block_statement_part.Add(bsp.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }

			DebugLocation(428, 9);
			END103=(IToken)Match(input,END,Follow._END_in_block_statement4488); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END103);

			DebugLocation(428, 13);
			BLOCK104=(IToken)Match(input,BLOCK,Follow._BLOCK_in_block_statement4490); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BLOCK.Add(BLOCK104);

			DebugLocation(428, 19);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:428:19: ( end_identifier )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_0 = input.LA(1);

			if ((LA36_0==BASIC_IDENTIFIER||LA36_0==EXTENDED_IDENTIFIER))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:428:19: end_identifier
				{
				DebugLocation(428, 19);
				PushFollow(Follow._end_identifier_in_block_statement4492);
				end_identifier105=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier105.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(428, 35);
			SEMI106=(IToken)Match(input,SEMI,Follow._SEMI_in_block_statement4495); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI106);



			{
			// AST REWRITE
			// elements: bsp, bdp, end_identifier, guard_expression, block_header, IS
			// token labels: 
			// rule labels: retval, guard_expression, bdp, bsp
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_guard_expression=new RewriteRuleSubtreeStream(adaptor,"rule guard_expression",guard_expression!=null?guard_expression.Tree:null);
			RewriteRuleSubtreeStream stream_bdp=new RewriteRuleSubtreeStream(adaptor,"rule bdp",bdp!=null?bdp.Tree:null);
			RewriteRuleSubtreeStream stream_bsp=new RewriteRuleSubtreeStream(adaptor,"rule bsp",bsp!=null?bsp.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 429:9: -> ^( BLOCK_STATEMENT ( $guard_expression)? ( IS )? ( block_header )? ( $bdp)? ( $bsp)? ( end_identifier )? )
			{
				DebugLocation(429, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:12: ^( BLOCK_STATEMENT ( $guard_expression)? ( IS )? ( block_header )? ( $bdp)? ( $bsp)? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(429, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCK_STATEMENT, "BLOCK_STATEMENT"), root_1);

				DebugLocation(429, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:32: ( $guard_expression)?
				if (stream_guard_expression.HasNext)
				{
					DebugLocation(429, 32);
					adaptor.AddChild(root_1, stream_guard_expression.NextTree());

				}
				stream_guard_expression.Reset();
				DebugLocation(429, 50);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:50: ( IS )?
				if (stream_IS.HasNext)
				{
					DebugLocation(429, 50);
					adaptor.AddChild(root_1, stream_IS.NextNode());

				}
				stream_IS.Reset();
				DebugLocation(429, 54);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:54: ( block_header )?
				if (stream_block_header.HasNext)
				{
					DebugLocation(429, 54);
					adaptor.AddChild(root_1, stream_block_header.NextTree());

				}
				stream_block_header.Reset();
				DebugLocation(429, 69);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:69: ( $bdp)?
				if (stream_bdp.HasNext)
				{
					DebugLocation(429, 69);
					adaptor.AddChild(root_1, stream_bdp.NextTree());

				}
				stream_bdp.Reset();
				DebugLocation(429, 75);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:75: ( $bsp)?
				if (stream_bsp.HasNext)
				{
					DebugLocation(429, 75);
					adaptor.AddChild(root_1, stream_bsp.NextTree());

				}
				stream_bsp.Reset();
				DebugLocation(429, 80);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:429:80: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(429, 80);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_statement", 26);
			LeaveRule("block_statement", 26);
			LeaveRule_block_statement();
			if (state.backtracking > 0) { Memoize(input, 26, block_statement_StartIndex); }

		}
		DebugLocation(430, 4);
		} finally { DebugExitRule(GrammarFileName, "block_statement"); }
		return retval;

	}
	// $ANTLR end "block_statement"

	partial void EnterRule_block_statement_part();
	partial void LeaveRule_block_statement_part();

	// $ANTLR start "block_statement_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:432:1: block_statement_part : ( concurrent_statement )+ ;
	[GrammarRule("block_statement_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> block_statement_part()
	{
		EnterRule_block_statement_part();
		EnterRule("block_statement_part", 27);
		TraceIn("block_statement_part", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int block_statement_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement107 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "block_statement_part");
		DebugLocation(432, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:433:5: ( ( concurrent_statement )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:433:9: ( concurrent_statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(433, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:433:9: ( concurrent_statement )+
			int cnt37=0;
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_0 = input.LA(1);

				if ((LA37_0==ASSERT||LA37_0==BASIC_IDENTIFIER||LA37_0==EXTENDED_IDENTIFIER||LA37_0==LPAREN||LA37_0==POSTPONED||LA37_0==PROCESS||LA37_0==STRING_LITERAL||LA37_0==WITH))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:433:9: concurrent_statement
					{
					DebugLocation(433, 9);
					PushFollow(Follow._concurrent_statement_in_block_statement_part4551);
					concurrent_statement107=concurrent_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_statement107.Tree);

					}
					break;

				default:
					if (cnt37 >= 1)
						goto loop37;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee37 = new EarlyExitException( 37, input );
					DebugRecognitionException(eee37);
					throw eee37;
				}
				cnt37++;
			}
			loop37:
				;

			} finally { DebugExitSubRule(37); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block_statement_part", 27);
			LeaveRule("block_statement_part", 27);
			LeaveRule_block_statement_part();
			if (state.backtracking > 0) { Memoize(input, 27, block_statement_part_StartIndex); }

		}
		DebugLocation(434, 4);
		} finally { DebugExitRule(GrammarFileName, "block_statement_part"); }
		return retval;

	}
	// $ANTLR end "block_statement_part"

	partial void EnterRule_case_statement();
	partial void LeaveRule_case_statement();

	// $ANTLR start "case_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:436:1: case_statement : CASE expression IS ( case_statement_alternative )+ END CASE ( end_identifier )? SEMI -> ^( CASE ( expression )? ( case_statement_alternative )+ ( end_identifier )? ) ;
	[GrammarRule("case_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> case_statement()
	{
		EnterRule_case_statement();
		EnterRule("case_statement", 28);
		TraceIn("case_statement", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int case_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CASE108 = default(IToken);
		IToken IS110 = default(IToken);
		IToken END112 = default(IToken);
		IToken CASE113 = default(IToken);
		IToken SEMI115 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression109 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> case_statement_alternative111 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier114 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CASE108_tree = default(CommonTree);
		CommonTree IS110_tree = default(CommonTree);
		CommonTree END112_tree = default(CommonTree);
		CommonTree CASE113_tree = default(CommonTree);
		CommonTree SEMI115_tree = default(CommonTree);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_case_statement_alternative=new RewriteRuleSubtreeStream(adaptor,"rule case_statement_alternative");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		try { DebugEnterRule(GrammarFileName, "case_statement");
		DebugLocation(436, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:437:5: ( CASE expression IS ( case_statement_alternative )+ END CASE ( end_identifier )? SEMI -> ^( CASE ( expression )? ( case_statement_alternative )+ ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:437:9: CASE expression IS ( case_statement_alternative )+ END CASE ( end_identifier )? SEMI
			{
			DebugLocation(437, 9);
			CASE108=(IToken)Match(input,CASE,Follow._CASE_in_case_statement4571); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CASE.Add(CASE108);

			DebugLocation(437, 14);
			PushFollow(Follow._expression_in_case_statement4573);
			expression109=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression109.Tree);
			DebugLocation(437, 25);
			IS110=(IToken)Match(input,IS,Follow._IS_in_case_statement4575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS110);

			DebugLocation(438, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:438:9: ( case_statement_alternative )+
			int cnt38=0;
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_0 = input.LA(1);

				if ((LA38_0==WHEN))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:438:9: case_statement_alternative
					{
					DebugLocation(438, 9);
					PushFollow(Follow._case_statement_alternative_in_case_statement4585);
					case_statement_alternative111=case_statement_alternative();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_case_statement_alternative.Add(case_statement_alternative111.Tree);

					}
					break;

				default:
					if (cnt38 >= 1)
						goto loop38;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee38 = new EarlyExitException( 38, input );
					DebugRecognitionException(eee38);
					throw eee38;
				}
				cnt38++;
			}
			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(439, 9);
			END112=(IToken)Match(input,END,Follow._END_in_case_statement4596); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END112);

			DebugLocation(439, 13);
			CASE113=(IToken)Match(input,CASE,Follow._CASE_in_case_statement4598); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CASE.Add(CASE113);

			DebugLocation(439, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:439:18: ( end_identifier )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_0 = input.LA(1);

			if ((LA39_0==BASIC_IDENTIFIER||LA39_0==EXTENDED_IDENTIFIER))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:439:18: end_identifier
				{
				DebugLocation(439, 18);
				PushFollow(Follow._end_identifier_in_case_statement4600);
				end_identifier114=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier114.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }

			DebugLocation(439, 34);
			SEMI115=(IToken)Match(input,SEMI,Follow._SEMI_in_case_statement4603); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI115);



			{
			// AST REWRITE
			// elements: expression, end_identifier, case_statement_alternative, CASE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 440:9: -> ^( CASE ( expression )? ( case_statement_alternative )+ ( end_identifier )? )
			{
				DebugLocation(440, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:440:12: ^( CASE ( expression )? ( case_statement_alternative )+ ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(440, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

				DebugLocation(440, 20);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:440:20: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(440, 20);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();
				DebugLocation(440, 32);
				if (!(stream_case_statement_alternative.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_case_statement_alternative.HasNext )
				{
					DebugLocation(440, 32);
					adaptor.AddChild(root_1, stream_case_statement_alternative.NextTree());

				}
				stream_case_statement_alternative.Reset();
				DebugLocation(440, 60);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:440:60: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(440, 60);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("case_statement", 28);
			LeaveRule("case_statement", 28);
			LeaveRule_case_statement();
			if (state.backtracking > 0) { Memoize(input, 28, case_statement_StartIndex); }

		}
		DebugLocation(441, 4);
		} finally { DebugExitRule(GrammarFileName, "case_statement"); }
		return retval;

	}
	// $ANTLR end "case_statement"

	partial void EnterRule_case_statement_alternative();
	partial void LeaveRule_case_statement_alternative();

	// $ANTLR start "case_statement_alternative"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:443:1: case_statement_alternative : WHEN choices ARROW sequence_of_statements -> choices ( sequence_of_statements )? ;
	[GrammarRule("case_statement_alternative")]
	private AstParserRuleReturnScope<CommonTree, IToken> case_statement_alternative()
	{
		EnterRule_case_statement_alternative();
		EnterRule("case_statement_alternative", 29);
		TraceIn("case_statement_alternative", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int case_statement_alternative_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WHEN116 = default(IToken);
		IToken ARROW118 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> choices117 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sequence_of_statements119 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHEN116_tree = default(CommonTree);
		CommonTree ARROW118_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ARROW=new RewriteRuleITokenStream(adaptor,"token ARROW");
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleSubtreeStream stream_choices=new RewriteRuleSubtreeStream(adaptor,"rule choices");
		RewriteRuleSubtreeStream stream_sequence_of_statements=new RewriteRuleSubtreeStream(adaptor,"rule sequence_of_statements");
		try { DebugEnterRule(GrammarFileName, "case_statement_alternative");
		DebugLocation(443, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:444:5: ( WHEN choices ARROW sequence_of_statements -> choices ( sequence_of_statements )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:444:9: WHEN choices ARROW sequence_of_statements
			{
			DebugLocation(444, 9);
			WHEN116=(IToken)Match(input,WHEN,Follow._WHEN_in_case_statement_alternative4647); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHEN.Add(WHEN116);

			DebugLocation(444, 14);
			PushFollow(Follow._choices_in_case_statement_alternative4649);
			choices117=choices();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_choices.Add(choices117.Tree);
			DebugLocation(444, 22);
			ARROW118=(IToken)Match(input,ARROW,Follow._ARROW_in_case_statement_alternative4651); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ARROW.Add(ARROW118);

			DebugLocation(444, 28);
			PushFollow(Follow._sequence_of_statements_in_case_statement_alternative4653);
			sequence_of_statements119=sequence_of_statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sequence_of_statements.Add(sequence_of_statements119.Tree);


			{
			// AST REWRITE
			// elements: sequence_of_statements, choices
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 445:9: -> choices ( sequence_of_statements )?
			{
				DebugLocation(445, 12);
				adaptor.AddChild(root_0, stream_choices.NextTree());
				DebugLocation(445, 20);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:445:20: ( sequence_of_statements )?
				if (stream_sequence_of_statements.HasNext)
				{
					DebugLocation(445, 20);
					adaptor.AddChild(root_0, stream_sequence_of_statements.NextTree());

				}
				stream_sequence_of_statements.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("case_statement_alternative", 29);
			LeaveRule("case_statement_alternative", 29);
			LeaveRule_case_statement_alternative();
			if (state.backtracking > 0) { Memoize(input, 29, case_statement_alternative_StartIndex); }

		}
		DebugLocation(446, 4);
		} finally { DebugExitRule(GrammarFileName, "case_statement_alternative"); }
		return retval;

	}
	// $ANTLR end "case_statement_alternative"

	partial void EnterRule_choice();
	partial void LeaveRule_choice();

	// $ANTLR start "choice"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:448:1: choice : ( simple_expression ( direction simple_expression -> ^( direction simple_expression simple_expression ) | -> simple_expression ) | OTHERS );
	[GrammarRule("choice")]
	private AstParserRuleReturnScope<CommonTree, IToken> choice()
	{
		EnterRule_choice();
		EnterRule("choice", 30);
		TraceIn("choice", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int choice_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken OTHERS123 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression120 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> direction121 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression122 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree OTHERS123_tree = default(CommonTree);
		RewriteRuleSubtreeStream stream_simple_expression=new RewriteRuleSubtreeStream(adaptor,"rule simple_expression");
		RewriteRuleSubtreeStream stream_direction=new RewriteRuleSubtreeStream(adaptor,"rule direction");
		try { DebugEnterRule(GrammarFileName, "choice");
		DebugLocation(448, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:449:5: ( simple_expression ( direction simple_expression -> ^( direction simple_expression simple_expression ) | -> simple_expression ) | OTHERS )
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_0 = input.LA(1);

			if ((LA41_0==ABS||LA41_0==BASIC_IDENTIFIER||LA41_0==BINANRY_BASED_INTEGER||(LA41_0>=BIT_STRING_LITERAL_BINARY && LA41_0<=BIT_STRING_LITERAL_OCTAL)||LA41_0==CHARACTER_LITERAL||LA41_0==DEC_BASED_INTEGER||LA41_0==EXTENDED_IDENTIFIER||LA41_0==FLOAT_POINT_LITERAL||LA41_0==HEXA_BASED_INTEGER||LA41_0==LPAREN||LA41_0==MINUS||LA41_0==NEW||(LA41_0>=NOT && LA41_0<=OCTAL_BASED_INTEGER)||LA41_0==PLUS||LA41_0==STRING_LITERAL))
			{
				alt41 = 1;
			}
			else if ((LA41_0==OTHERS))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:449:9: simple_expression ( direction simple_expression -> ^( direction simple_expression simple_expression ) | -> simple_expression )
				{
				DebugLocation(449, 9);
				PushFollow(Follow._simple_expression_in_choice4687);
				simple_expression120=simple_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_expression.Add(simple_expression120.Tree);
				DebugLocation(450, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:450:9: ( direction simple_expression -> ^( direction simple_expression simple_expression ) | -> simple_expression )
				int alt40=2;
				try { DebugEnterSubRule(40);
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==DOWNTO||LA40_0==TO))
				{
					alt40 = 1;
				}
				else if ((LA40_0==ARROW||LA40_0==BAR||LA40_0==COMMA||LA40_0==EXCLAMATION||LA40_0==SEMI))
				{
					alt40 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:451:17: direction simple_expression
					{
					DebugLocation(451, 17);
					PushFollow(Follow._direction_in_choice4716);
					direction121=direction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_direction.Add(direction121.Tree);
					DebugLocation(451, 27);
					PushFollow(Follow._simple_expression_in_choice4718);
					simple_expression122=simple_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_simple_expression.Add(simple_expression122.Tree);


					{
					// AST REWRITE
					// elements: simple_expression, simple_expression, direction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 452:17: -> ^( direction simple_expression simple_expression )
					{
						DebugLocation(452, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:452:20: ^( direction simple_expression simple_expression )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(452, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_direction.NextNode(), root_1);

						DebugLocation(452, 33);
						adaptor.AddChild(root_1, stream_simple_expression.NextTree());
						DebugLocation(452, 51);
						adaptor.AddChild(root_1, stream_simple_expression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:454:17: 
					{

					{
					// AST REWRITE
					// elements: simple_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 454:17: -> simple_expression
					{
						DebugLocation(454, 20);
						adaptor.AddChild(root_0, stream_simple_expression.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(40); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:459:9: OTHERS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(459, 9);
				OTHERS123=(IToken)Match(input,OTHERS,Follow._OTHERS_in_choice4803); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OTHERS123_tree = (CommonTree)adaptor.Create(OTHERS123);
				adaptor.AddChild(root_0, OTHERS123_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("choice", 30);
			LeaveRule("choice", 30);
			LeaveRule_choice();
			if (state.backtracking > 0) { Memoize(input, 30, choice_StartIndex); }

		}
		DebugLocation(462, 4);
		} finally { DebugExitRule(GrammarFileName, "choice"); }
		return retval;

	}
	// $ANTLR end "choice"

	partial void EnterRule_choices();
	partial void LeaveRule_choices();

	// $ANTLR start "choices"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:464:1: choices : choice ( ( BAR | EXCLAMATION ) choice )* -> ^( CHOICES ( choice )+ ) ;
	[GrammarRule("choices")]
	private AstParserRuleReturnScope<CommonTree, IToken> choices()
	{
		EnterRule_choices();
		EnterRule("choices", 31);
		TraceIn("choices", 31);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int choices_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken BAR125 = default(IToken);
		IToken EXCLAMATION126 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> choice124 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> choice127 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BAR125_tree = default(CommonTree);
		CommonTree EXCLAMATION126_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EXCLAMATION=new RewriteRuleITokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleITokenStream stream_BAR=new RewriteRuleITokenStream(adaptor,"token BAR");
		RewriteRuleSubtreeStream stream_choice=new RewriteRuleSubtreeStream(adaptor,"rule choice");
		try { DebugEnterRule(GrammarFileName, "choices");
		DebugLocation(464, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:5: ( choice ( ( BAR | EXCLAMATION ) choice )* -> ^( CHOICES ( choice )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:9: choice ( ( BAR | EXCLAMATION ) choice )*
			{
			DebugLocation(465, 9);
			PushFollow(Follow._choice_in_choices4824);
			choice124=choice();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_choice.Add(choice124.Tree);
			DebugLocation(465, 16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:16: ( ( BAR | EXCLAMATION ) choice )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_0 = input.LA(1);

				if ((LA43_0==BAR||LA43_0==EXCLAMATION))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:18: ( BAR | EXCLAMATION ) choice
					{
					DebugLocation(465, 18);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:18: ( BAR | EXCLAMATION )
					int alt42=2;
					try { DebugEnterSubRule(42);
					try { DebugEnterDecision(42, false);
					int LA42_0 = input.LA(1);

					if ((LA42_0==BAR))
					{
						alt42 = 1;
					}
					else if ((LA42_0==EXCLAMATION))
					{
						alt42 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(42); }
					switch (alt42)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:20: BAR
						{
						DebugLocation(465, 20);
						BAR125=(IToken)Match(input,BAR,Follow._BAR_in_choices4830); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_BAR.Add(BAR125);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:465:26: EXCLAMATION
						{
						DebugLocation(465, 26);
						EXCLAMATION126=(IToken)Match(input,EXCLAMATION,Follow._EXCLAMATION_in_choices4834); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_EXCLAMATION.Add(EXCLAMATION126);


						}
						break;

					}
					} finally { DebugExitSubRule(42); }

					DebugLocation(465, 40);
					PushFollow(Follow._choice_in_choices4838);
					choice127=choice();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_choice.Add(choice127.Tree);

					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }



			{
			// AST REWRITE
			// elements: choice
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 466:9: -> ^( CHOICES ( choice )+ )
			{
				DebugLocation(466, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:466:12: ^( CHOICES ( choice )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(466, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CHOICES, "CHOICES"), root_1);

				DebugLocation(466, 23);
				if (!(stream_choice.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_choice.HasNext )
				{
					DebugLocation(466, 23);
					adaptor.AddChild(root_1, stream_choice.NextTree());

				}
				stream_choice.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("choices", 31);
			LeaveRule("choices", 31);
			LeaveRule_choices();
			if (state.backtracking > 0) { Memoize(input, 31, choices_StartIndex); }

		}
		DebugLocation(467, 4);
		} finally { DebugExitRule(GrammarFileName, "choices"); }
		return retval;

	}
	// $ANTLR end "choices"

	partial void EnterRule_component_configuration();
	partial void LeaveRule_component_configuration();

	// $ANTLR start "component_configuration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:469:1: component_configuration : FOR cs= component_specification (bi= binding_indication SEMI )? (bc= block_configuration )? END FOR SEMI -> ^( COMPONENT_CONFIGURATION $cs ( $bi)? ( $bc)? ) ;
	[GrammarRule("component_configuration")]
	private AstParserRuleReturnScope<CommonTree, IToken> component_configuration()
	{
		EnterRule_component_configuration();
		EnterRule("component_configuration", 32);
		TraceIn("component_configuration", 32);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int component_configuration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FOR128 = default(IToken);
		IToken SEMI129 = default(IToken);
		IToken END130 = default(IToken);
		IToken FOR131 = default(IToken);
		IToken SEMI132 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> cs = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bi = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bc = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR128_tree = default(CommonTree);
		CommonTree SEMI129_tree = default(CommonTree);
		CommonTree END130_tree = default(CommonTree);
		CommonTree FOR131_tree = default(CommonTree);
		CommonTree SEMI132_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_component_specification=new RewriteRuleSubtreeStream(adaptor,"rule component_specification");
		RewriteRuleSubtreeStream stream_binding_indication=new RewriteRuleSubtreeStream(adaptor,"rule binding_indication");
		RewriteRuleSubtreeStream stream_block_configuration=new RewriteRuleSubtreeStream(adaptor,"rule block_configuration");
		try { DebugEnterRule(GrammarFileName, "component_configuration");
		DebugLocation(469, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:470:5: ( FOR cs= component_specification (bi= binding_indication SEMI )? (bc= block_configuration )? END FOR SEMI -> ^( COMPONENT_CONFIGURATION $cs ( $bi)? ( $bc)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:470:9: FOR cs= component_specification (bi= binding_indication SEMI )? (bc= block_configuration )? END FOR SEMI
			{
			DebugLocation(470, 9);
			FOR128=(IToken)Match(input,FOR,Follow._FOR_in_component_configuration4879); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR128);

			DebugLocation(470, 15);
			PushFollow(Follow._component_specification_in_component_configuration4883);
			cs=component_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_component_specification.Add(cs.Tree);
			DebugLocation(471, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:471:9: (bi= binding_indication SEMI )?
			int alt44=2;
			try { DebugEnterSubRule(44);
			try { DebugEnterDecision(44, false);
			int LA44_0 = input.LA(1);

			if ((LA44_0==GENERIC||LA44_0==PORT||LA44_0==SEMI||LA44_0==USE))
			{
				alt44 = 1;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:471:11: bi= binding_indication SEMI
				{
				DebugLocation(471, 13);
				PushFollow(Follow._binding_indication_in_component_configuration4897);
				bi=binding_indication();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_binding_indication.Add(bi.Tree);
				DebugLocation(471, 33);
				SEMI129=(IToken)Match(input,SEMI,Follow._SEMI_in_component_configuration4899); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMI.Add(SEMI129);


				}
				break;

			}
			} finally { DebugExitSubRule(44); }

			DebugLocation(472, 11);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:472:11: (bc= block_configuration )?
			int alt45=2;
			try { DebugEnterSubRule(45);
			try { DebugEnterDecision(45, false);
			int LA45_0 = input.LA(1);

			if ((LA45_0==FOR))
			{
				alt45 = 1;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:472:11: bc= block_configuration
				{
				DebugLocation(472, 11);
				PushFollow(Follow._block_configuration_in_component_configuration4914);
				bc=block_configuration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_block_configuration.Add(bc.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(45); }

			DebugLocation(473, 9);
			END130=(IToken)Match(input,END,Follow._END_in_component_configuration4925); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END130);

			DebugLocation(473, 13);
			FOR131=(IToken)Match(input,FOR,Follow._FOR_in_component_configuration4927); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR131);

			DebugLocation(473, 17);
			SEMI132=(IToken)Match(input,SEMI,Follow._SEMI_in_component_configuration4929); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI132);



			{
			// AST REWRITE
			// elements: cs, bi, bc
			// token labels: 
			// rule labels: retval, bi, bc, cs
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_bi=new RewriteRuleSubtreeStream(adaptor,"rule bi",bi!=null?bi.Tree:null);
			RewriteRuleSubtreeStream stream_bc=new RewriteRuleSubtreeStream(adaptor,"rule bc",bc!=null?bc.Tree:null);
			RewriteRuleSubtreeStream stream_cs=new RewriteRuleSubtreeStream(adaptor,"rule cs",cs!=null?cs.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 474:9: -> ^( COMPONENT_CONFIGURATION $cs ( $bi)? ( $bc)? )
			{
				DebugLocation(474, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:474:12: ^( COMPONENT_CONFIGURATION $cs ( $bi)? ( $bc)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(474, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMPONENT_CONFIGURATION, "COMPONENT_CONFIGURATION"), root_1);

				DebugLocation(474, 40);
				adaptor.AddChild(root_1, stream_cs.NextTree());
				DebugLocation(474, 44);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:474:44: ( $bi)?
				if (stream_bi.HasNext)
				{
					DebugLocation(474, 44);
					adaptor.AddChild(root_1, stream_bi.NextTree());

				}
				stream_bi.Reset();
				DebugLocation(474, 49);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:474:49: ( $bc)?
				if (stream_bc.HasNext)
				{
					DebugLocation(474, 49);
					adaptor.AddChild(root_1, stream_bc.NextTree());

				}
				stream_bc.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("component_configuration", 32);
			LeaveRule("component_configuration", 32);
			LeaveRule_component_configuration();
			if (state.backtracking > 0) { Memoize(input, 32, component_configuration_StartIndex); }

		}
		DebugLocation(475, 4);
		} finally { DebugExitRule(GrammarFileName, "component_configuration"); }
		return retval;

	}
	// $ANTLR end "component_configuration"

	partial void EnterRule_component_declaration();
	partial void LeaveRule_component_declaration();

	// $ANTLR start "component_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:478:1: component_declaration : COMPONENT identifier ( IS )? (local_generic_clause= generic_clause )? (local_port_clause= port_clause )? END COMPONENT ( end_identifier )? SEMI -> ^( COMPONENT identifier ( IS )? ( $local_generic_clause)? ( $local_port_clause)? ( end_identifier )? ) ;
	[GrammarRule("component_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> component_declaration()
	{
		EnterRule_component_declaration();
		EnterRule("component_declaration", 33);
		TraceIn("component_declaration", 33);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int component_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMPONENT133 = default(IToken);
		IToken IS135 = default(IToken);
		IToken END136 = default(IToken);
		IToken COMPONENT137 = default(IToken);
		IToken SEMI139 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> local_generic_clause = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> local_port_clause = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier134 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier138 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMPONENT133_tree = default(CommonTree);
		CommonTree IS135_tree = default(CommonTree);
		CommonTree END136_tree = default(CommonTree);
		CommonTree COMPONENT137_tree = default(CommonTree);
		CommonTree SEMI139_tree = default(CommonTree);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_COMPONENT=new RewriteRuleITokenStream(adaptor,"token COMPONENT");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_generic_clause=new RewriteRuleSubtreeStream(adaptor,"rule generic_clause");
		RewriteRuleSubtreeStream stream_port_clause=new RewriteRuleSubtreeStream(adaptor,"rule port_clause");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "component_declaration");
		DebugLocation(478, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:479:5: ( COMPONENT identifier ( IS )? (local_generic_clause= generic_clause )? (local_port_clause= port_clause )? END COMPONENT ( end_identifier )? SEMI -> ^( COMPONENT identifier ( IS )? ( $local_generic_clause)? ( $local_port_clause)? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:479:9: COMPONENT identifier ( IS )? (local_generic_clause= generic_clause )? (local_port_clause= port_clause )? END COMPONENT ( end_identifier )? SEMI
			{
			DebugLocation(479, 9);
			COMPONENT133=(IToken)Match(input,COMPONENT,Follow._COMPONENT_in_component_declaration4976); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMPONENT.Add(COMPONENT133);

			DebugLocation(479, 19);
			PushFollow(Follow._identifier_in_component_declaration4978);
			identifier134=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier134.Tree);
			DebugLocation(479, 30);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:479:30: ( IS )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_0 = input.LA(1);

			if ((LA46_0==IS))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:479:30: IS
				{
				DebugLocation(479, 30);
				IS135=(IToken)Match(input,IS,Follow._IS_in_component_declaration4980); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IS.Add(IS135);


				}
				break;

			}
			} finally { DebugExitSubRule(46); }

			DebugLocation(480, 29);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:480:29: (local_generic_clause= generic_clause )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_0 = input.LA(1);

			if ((LA47_0==GENERIC))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:480:29: local_generic_clause= generic_clause
				{
				DebugLocation(480, 29);
				PushFollow(Follow._generic_clause_in_component_declaration4993);
				local_generic_clause=generic_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_generic_clause.Add(local_generic_clause.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(47); }

			DebugLocation(481, 26);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:481:26: (local_port_clause= port_clause )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_0 = input.LA(1);

			if ((LA48_0==PORT))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:481:26: local_port_clause= port_clause
				{
				DebugLocation(481, 26);
				PushFollow(Follow._port_clause_in_component_declaration5006);
				local_port_clause=port_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_port_clause.Add(local_port_clause.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(482, 9);
			END136=(IToken)Match(input,END,Follow._END_in_component_declaration5017); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END136);

			DebugLocation(482, 13);
			COMPONENT137=(IToken)Match(input,COMPONENT,Follow._COMPONENT_in_component_declaration5019); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMPONENT.Add(COMPONENT137);

			DebugLocation(482, 23);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:482:23: ( end_identifier )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_0 = input.LA(1);

			if ((LA49_0==BASIC_IDENTIFIER||LA49_0==EXTENDED_IDENTIFIER))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:482:23: end_identifier
				{
				DebugLocation(482, 23);
				PushFollow(Follow._end_identifier_in_component_declaration5021);
				end_identifier138=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier138.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(49); }

			DebugLocation(482, 39);
			SEMI139=(IToken)Match(input,SEMI,Follow._SEMI_in_component_declaration5024); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI139);



			{
			// AST REWRITE
			// elements: COMPONENT, end_identifier, local_generic_clause, identifier, local_port_clause, IS
			// token labels: 
			// rule labels: retval, local_generic_clause, local_port_clause
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_local_generic_clause=new RewriteRuleSubtreeStream(adaptor,"rule local_generic_clause",local_generic_clause!=null?local_generic_clause.Tree:null);
			RewriteRuleSubtreeStream stream_local_port_clause=new RewriteRuleSubtreeStream(adaptor,"rule local_port_clause",local_port_clause!=null?local_port_clause.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 483:9: -> ^( COMPONENT identifier ( IS )? ( $local_generic_clause)? ( $local_port_clause)? ( end_identifier )? )
			{
				DebugLocation(483, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:483:12: ^( COMPONENT identifier ( IS )? ( $local_generic_clause)? ( $local_port_clause)? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(483, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_COMPONENT.NextNode(), root_1);

				DebugLocation(483, 25);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(483, 36);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:483:36: ( IS )?
				if (stream_IS.HasNext)
				{
					DebugLocation(483, 36);
					adaptor.AddChild(root_1, stream_IS.NextNode());

				}
				stream_IS.Reset();
				DebugLocation(483, 41);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:483:41: ( $local_generic_clause)?
				if (stream_local_generic_clause.HasNext)
				{
					DebugLocation(483, 41);
					adaptor.AddChild(root_1, stream_local_generic_clause.NextTree());

				}
				stream_local_generic_clause.Reset();
				DebugLocation(483, 64);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:483:64: ( $local_port_clause)?
				if (stream_local_port_clause.HasNext)
				{
					DebugLocation(483, 64);
					adaptor.AddChild(root_1, stream_local_port_clause.NextTree());

				}
				stream_local_port_clause.Reset();
				DebugLocation(483, 83);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:483:83: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(483, 83);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("component_declaration", 33);
			LeaveRule("component_declaration", 33);
			LeaveRule_component_declaration();
			if (state.backtracking > 0) { Memoize(input, 33, component_declaration_StartIndex); }

		}
		DebugLocation(484, 4);
		} finally { DebugExitRule(GrammarFileName, "component_declaration"); }
		return retval;

	}
	// $ANTLR end "component_declaration"

	partial void EnterRule_component_instantiation_statement();
	partial void LeaveRule_component_instantiation_statement();

	// $ANTLR start "component_instantiation_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:486:1: component_instantiation_statement : iu= instantiated_unit (gma= generic_map_aspect )? (pma= port_map_aspect )? SEMI -> ^( COMPONENT_INSTANTIATION_STATEMENT $iu ( $gma)? ( $pma)? ) ;
	[GrammarRule("component_instantiation_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> component_instantiation_statement()
	{
		EnterRule_component_instantiation_statement();
		EnterRule("component_instantiation_statement", 34);
		TraceIn("component_instantiation_statement", 34);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int component_instantiation_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI140 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iu = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> gma = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> pma = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI140_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_generic_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule generic_map_aspect");
		RewriteRuleSubtreeStream stream_instantiated_unit=new RewriteRuleSubtreeStream(adaptor,"rule instantiated_unit");
		RewriteRuleSubtreeStream stream_port_map_aspect=new RewriteRuleSubtreeStream(adaptor,"rule port_map_aspect");
		try { DebugEnterRule(GrammarFileName, "component_instantiation_statement");
		DebugLocation(486, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 34)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:487:5: (iu= instantiated_unit (gma= generic_map_aspect )? (pma= port_map_aspect )? SEMI -> ^( COMPONENT_INSTANTIATION_STATEMENT $iu ( $gma)? ( $pma)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:487:9: iu= instantiated_unit (gma= generic_map_aspect )? (pma= port_map_aspect )? SEMI
			{
			DebugLocation(487, 11);
			PushFollow(Follow._instantiated_unit_in_component_instantiation_statement5077);
			iu=instantiated_unit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_instantiated_unit.Add(iu.Tree);
			DebugLocation(488, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:488:12: (gma= generic_map_aspect )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_0 = input.LA(1);

			if ((LA50_0==GENERIC))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:488:12: gma= generic_map_aspect
				{
				DebugLocation(488, 12);
				PushFollow(Follow._generic_map_aspect_in_component_instantiation_statement5089);
				gma=generic_map_aspect();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_generic_map_aspect.Add(gma.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(489, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:489:12: (pma= port_map_aspect )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_0 = input.LA(1);

			if ((LA51_0==PORT))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:489:12: pma= port_map_aspect
				{
				DebugLocation(489, 12);
				PushFollow(Follow._port_map_aspect_in_component_instantiation_statement5102);
				pma=port_map_aspect();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_port_map_aspect.Add(pma.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(51); }

			DebugLocation(489, 30);
			SEMI140=(IToken)Match(input,SEMI,Follow._SEMI_in_component_instantiation_statement5105); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI140);



			{
			// AST REWRITE
			// elements: iu, gma, pma
			// token labels: 
			// rule labels: gma, retval, iu, pma
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_gma=new RewriteRuleSubtreeStream(adaptor,"rule gma",gma!=null?gma.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_iu=new RewriteRuleSubtreeStream(adaptor,"rule iu",iu!=null?iu.Tree:null);
			RewriteRuleSubtreeStream stream_pma=new RewriteRuleSubtreeStream(adaptor,"rule pma",pma!=null?pma.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 490:9: -> ^( COMPONENT_INSTANTIATION_STATEMENT $iu ( $gma)? ( $pma)? )
			{
				DebugLocation(490, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:490:12: ^( COMPONENT_INSTANTIATION_STATEMENT $iu ( $gma)? ( $pma)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(490, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMPONENT_INSTANTIATION_STATEMENT, "COMPONENT_INSTANTIATION_STATEMENT"), root_1);

				DebugLocation(490, 50);
				adaptor.AddChild(root_1, stream_iu.NextTree());
				DebugLocation(490, 54);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:490:54: ( $gma)?
				if (stream_gma.HasNext)
				{
					DebugLocation(490, 54);
					adaptor.AddChild(root_1, stream_gma.NextTree());

				}
				stream_gma.Reset();
				DebugLocation(490, 60);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:490:60: ( $pma)?
				if (stream_pma.HasNext)
				{
					DebugLocation(490, 60);
					adaptor.AddChild(root_1, stream_pma.NextTree());

				}
				stream_pma.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("component_instantiation_statement", 34);
			LeaveRule("component_instantiation_statement", 34);
			LeaveRule_component_instantiation_statement();
			if (state.backtracking > 0) { Memoize(input, 34, component_instantiation_statement_StartIndex); }

		}
		DebugLocation(491, 4);
		} finally { DebugExitRule(GrammarFileName, "component_instantiation_statement"); }
		return retval;

	}
	// $ANTLR end "component_instantiation_statement"

	partial void EnterRule_component_specification();
	partial void LeaveRule_component_specification();

	// $ANTLR start "component_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:493:1: component_specification : instantiation_list COLON component= name -> instantiation_list $component;
	[GrammarRule("component_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> component_specification()
	{
		EnterRule_component_specification();
		EnterRule("component_specification", 35);
		TraceIn("component_specification", 35);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int component_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON142 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> component = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> instantiation_list141 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON142_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_instantiation_list=new RewriteRuleSubtreeStream(adaptor,"rule instantiation_list");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "component_specification");
		DebugLocation(493, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 35)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:494:5: ( instantiation_list COLON component= name -> instantiation_list $component)
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:494:9: instantiation_list COLON component= name
			{
			DebugLocation(494, 9);
			PushFollow(Follow._instantiation_list_in_component_specification5151);
			instantiation_list141=instantiation_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_instantiation_list.Add(instantiation_list141.Tree);
			DebugLocation(494, 28);
			COLON142=(IToken)Match(input,COLON,Follow._COLON_in_component_specification5153); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON142);

			DebugLocation(494, 43);
			PushFollow(Follow._name_in_component_specification5157);
			component=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(component.Tree);


			{
			// AST REWRITE
			// elements: instantiation_list, component
			// token labels: 
			// rule labels: retval, component
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_component=new RewriteRuleSubtreeStream(adaptor,"rule component",component!=null?component.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 495:9: -> instantiation_list $component
			{
				DebugLocation(495, 12);
				adaptor.AddChild(root_0, stream_instantiation_list.NextTree());
				DebugLocation(495, 32);
				adaptor.AddChild(root_0, stream_component.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("component_specification", 35);
			LeaveRule("component_specification", 35);
			LeaveRule_component_specification();
			if (state.backtracking > 0) { Memoize(input, 35, component_specification_StartIndex); }

		}
		DebugLocation(496, 4);
		} finally { DebugExitRule(GrammarFileName, "component_specification"); }
		return retval;

	}
	// $ANTLR end "component_specification"

	partial void EnterRule_composite_type_definition();
	partial void LeaveRule_composite_type_definition();

	// $ANTLR start "composite_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:498:1: composite_type_definition : ( array_type_definition | record_type_definition );
	[GrammarRule("composite_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> composite_type_definition()
	{
		EnterRule_composite_type_definition();
		EnterRule("composite_type_definition", 36);
		TraceIn("composite_type_definition", 36);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int composite_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> array_type_definition143 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> record_type_definition144 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "composite_type_definition");
		DebugLocation(498, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 36)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:499:5: ( array_type_definition | record_type_definition )
			int alt52=2;
			try { DebugEnterDecision(52, false);
			int LA52_0 = input.LA(1);

			if ((LA52_0==ARRAY))
			{
				alt52 = 1;
			}
			else if ((LA52_0==RECORD))
			{
				alt52 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:499:9: array_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(499, 9);
				PushFollow(Follow._array_type_definition_in_composite_type_definition5191);
				array_type_definition143=array_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_type_definition143.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:500:9: record_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(500, 9);
				PushFollow(Follow._record_type_definition_in_composite_type_definition5201);
				record_type_definition144=record_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, record_type_definition144.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("composite_type_definition", 36);
			LeaveRule("composite_type_definition", 36);
			LeaveRule_composite_type_definition();
			if (state.backtracking > 0) { Memoize(input, 36, composite_type_definition_StartIndex); }

		}
		DebugLocation(501, 4);
		} finally { DebugExitRule(GrammarFileName, "composite_type_definition"); }
		return retval;

	}
	// $ANTLR end "composite_type_definition"

	partial void EnterRule_concurrent_assertion_statement();
	partial void LeaveRule_concurrent_assertion_statement();

	// $ANTLR start "concurrent_assertion_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:503:1: concurrent_assertion_statement : assertion SEMI -> assertion ;
	[GrammarRule("concurrent_assertion_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_assertion_statement()
	{
		EnterRule_concurrent_assertion_statement();
		EnterRule("concurrent_assertion_statement", 37);
		TraceIn("concurrent_assertion_statement", 37);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_assertion_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI146 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assertion145 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI146_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_assertion=new RewriteRuleSubtreeStream(adaptor,"rule assertion");
		try { DebugEnterRule(GrammarFileName, "concurrent_assertion_statement");
		DebugLocation(503, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 37)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:504:5: ( assertion SEMI -> assertion )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:504:9: assertion SEMI
			{
			DebugLocation(504, 9);
			PushFollow(Follow._assertion_in_concurrent_assertion_statement5220);
			assertion145=assertion();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assertion.Add(assertion145.Tree);
			DebugLocation(504, 19);
			SEMI146=(IToken)Match(input,SEMI,Follow._SEMI_in_concurrent_assertion_statement5222); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI146);



			{
			// AST REWRITE
			// elements: assertion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 505:9: -> assertion
			{
				DebugLocation(505, 12);
				adaptor.AddChild(root_0, stream_assertion.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_assertion_statement", 37);
			LeaveRule("concurrent_assertion_statement", 37);
			LeaveRule_concurrent_assertion_statement();
			if (state.backtracking > 0) { Memoize(input, 37, concurrent_assertion_statement_StartIndex); }

		}
		DebugLocation(506, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_assertion_statement"); }
		return retval;

	}
	// $ANTLR end "concurrent_assertion_statement"

	partial void EnterRule_concurrent_procedure_call_statement();
	partial void LeaveRule_concurrent_procedure_call_statement();

	// $ANTLR start "concurrent_procedure_call_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:508:1: concurrent_procedure_call_statement : procedure_call SEMI -> procedure_call ;
	[GrammarRule("concurrent_procedure_call_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_procedure_call_statement()
	{
		EnterRule_concurrent_procedure_call_statement();
		EnterRule("concurrent_procedure_call_statement", 38);
		TraceIn("concurrent_procedure_call_statement", 38);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_procedure_call_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI148 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> procedure_call147 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI148_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_procedure_call=new RewriteRuleSubtreeStream(adaptor,"rule procedure_call");
		try { DebugEnterRule(GrammarFileName, "concurrent_procedure_call_statement");
		DebugLocation(508, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 38)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:509:5: ( procedure_call SEMI -> procedure_call )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:509:9: procedure_call SEMI
			{
			DebugLocation(509, 9);
			PushFollow(Follow._procedure_call_in_concurrent_procedure_call_statement5253);
			procedure_call147=procedure_call();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_procedure_call.Add(procedure_call147.Tree);
			DebugLocation(509, 24);
			SEMI148=(IToken)Match(input,SEMI,Follow._SEMI_in_concurrent_procedure_call_statement5255); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI148);



			{
			// AST REWRITE
			// elements: procedure_call
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 510:9: -> procedure_call
			{
				DebugLocation(510, 12);
				adaptor.AddChild(root_0, stream_procedure_call.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_procedure_call_statement", 38);
			LeaveRule("concurrent_procedure_call_statement", 38);
			LeaveRule_concurrent_procedure_call_statement();
			if (state.backtracking > 0) { Memoize(input, 38, concurrent_procedure_call_statement_StartIndex); }

		}
		DebugLocation(511, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_procedure_call_statement"); }
		return retval;

	}
	// $ANTLR end "concurrent_procedure_call_statement"

	partial void EnterRule_concurrent_statement();
	partial void LeaveRule_concurrent_statement();

	// $ANTLR start "concurrent_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:514:1: concurrent_statement : ( ( identifier COLON ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) ) ) | concurrent_statement_optional_label );
	[GrammarRule("concurrent_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement()
	{
		EnterRule_concurrent_statement();
		EnterRule("concurrent_statement", 39);
		TraceIn("concurrent_statement", 39);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON150 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier149 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_optional_label151 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_with_label152 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_optional_label153 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON150_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_concurrent_statement_with_label=new RewriteRuleSubtreeStream(adaptor,"rule concurrent_statement_with_label");
		RewriteRuleSubtreeStream stream_concurrent_statement_optional_label=new RewriteRuleSubtreeStream(adaptor,"rule concurrent_statement_optional_label");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "concurrent_statement");
		DebugLocation(514, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 39)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:515:5: ( ( identifier COLON ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) ) ) | concurrent_statement_optional_label )
			int alt54=2;
			try { DebugEnterDecision(54, false);
			int LA54_0 = input.LA(1);

			if ((LA54_0==BASIC_IDENTIFIER||LA54_0==EXTENDED_IDENTIFIER))
			{
				int LA54_1 = input.LA(2);

				if ((LA54_1==COLON))
				{
					alt54 = 1;
				}
				else if ((LA54_1==APOSTROPHE||LA54_1==DOT||(LA54_1>=LBRACKET && LA54_1<=LE)||LA54_1==LPAREN||LA54_1==SEMI))
				{
					alt54 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 54, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA54_0==ASSERT||LA54_0==LPAREN||LA54_0==POSTPONED||LA54_0==PROCESS||LA54_0==STRING_LITERAL||LA54_0==WITH))
			{
				alt54 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:515:9: ( identifier COLON ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) ) )
				{
				DebugLocation(515, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:515:9: ( identifier COLON ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) ) )
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:516:13: identifier COLON ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) )
				{
				DebugLocation(516, 13);
				PushFollow(Follow._identifier_in_concurrent_statement5301);
				identifier149=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier149.Tree);
				DebugLocation(516, 24);
				COLON150=(IToken)Match(input,COLON,Follow._COLON_in_concurrent_statement5303); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON150);

				DebugLocation(517, 13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:517:13: ( ( concurrent_statement_optional_label )=> concurrent_statement_optional_label -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label ) | concurrent_statement_with_label -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label ) )
				int alt53=2;
				try { DebugEnterSubRule(53);
				try { DebugEnterDecision(53, false);
				int LA53_0 = input.LA(1);

				if ((LA53_0==POSTPONED) && (EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
				{
					alt53 = 1;
				}
				else if ((LA53_0==PROCESS) && (EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
				{
					alt53 = 1;
				}
				else if ((LA53_0==BASIC_IDENTIFIER||LA53_0==EXTENDED_IDENTIFIER))
				{
					int LA53_3 = input.LA(2);

					if ((EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
					{
						alt53 = 1;
					}
					else if ((true))
					{
						alt53 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 53, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA53_0==STRING_LITERAL))
				{
					int LA53_4 = input.LA(2);

					if ((EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
					{
						alt53 = 1;
					}
					else if ((true))
					{
						alt53 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 53, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA53_0==LPAREN) && (EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
				{
					alt53 = 1;
				}
				else if ((LA53_0==ASSERT) && (EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
				{
					alt53 = 1;
				}
				else if ((LA53_0==WITH) && (EvaluatePredicate(synpred3_VhdlAntlr_fragment)))
				{
					alt53 = 1;
				}
				else if ((LA53_0==BLOCK||LA53_0==COMPONENT||LA53_0==CONFIGURATION||LA53_0==ENTITY||LA53_0==FOR||LA53_0==IF))
				{
					alt53 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(53); }
				switch (alt53)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:518:21: ( concurrent_statement_optional_label )=> concurrent_statement_optional_label
					{
					DebugLocation(518, 61);
					PushFollow(Follow._concurrent_statement_optional_label_in_concurrent_statement5344);
					concurrent_statement_optional_label151=concurrent_statement_optional_label();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_concurrent_statement_optional_label.Add(concurrent_statement_optional_label151.Tree);


					{
					// AST REWRITE
					// elements: concurrent_statement_optional_label, identifier
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 519:21: -> ^( LABEL_STATEMENT identifier concurrent_statement_optional_label )
					{
						DebugLocation(519, 24);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:519:24: ^( LABEL_STATEMENT identifier concurrent_statement_optional_label )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(519, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LABEL_STATEMENT, "LABEL_STATEMENT"), root_1);

						DebugLocation(519, 43);
						adaptor.AddChild(root_1, stream_identifier.NextTree());
						DebugLocation(519, 54);
						adaptor.AddChild(root_1, stream_concurrent_statement_optional_label.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:520:21: concurrent_statement_with_label
					{
					DebugLocation(520, 21);
					PushFollow(Follow._concurrent_statement_with_label_in_concurrent_statement5398);
					concurrent_statement_with_label152=concurrent_statement_with_label();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_concurrent_statement_with_label.Add(concurrent_statement_with_label152.Tree);


					{
					// AST REWRITE
					// elements: concurrent_statement_with_label, identifier
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 521:21: -> ^( LABEL_STATEMENT identifier concurrent_statement_with_label )
					{
						DebugLocation(521, 24);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:521:24: ^( LABEL_STATEMENT identifier concurrent_statement_with_label )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(521, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LABEL_STATEMENT, "LABEL_STATEMENT"), root_1);

						DebugLocation(521, 43);
						adaptor.AddChild(root_1, stream_identifier.NextTree());
						DebugLocation(521, 54);
						adaptor.AddChild(root_1, stream_concurrent_statement_with_label.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(53); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:524:9: concurrent_statement_optional_label
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(524, 9);
				PushFollow(Follow._concurrent_statement_optional_label_in_concurrent_statement5464);
				concurrent_statement_optional_label153=concurrent_statement_optional_label();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_statement_optional_label153.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_statement", 39);
			LeaveRule("concurrent_statement", 39);
			LeaveRule_concurrent_statement();
			if (state.backtracking > 0) { Memoize(input, 39, concurrent_statement_StartIndex); }

		}
		DebugLocation(525, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_statement"); }
		return retval;

	}
	// $ANTLR end "concurrent_statement"

	partial void EnterRule_concurrent_statement_with_label();
	partial void LeaveRule_concurrent_statement_with_label();

	// $ANTLR start "concurrent_statement_with_label"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:527:1: concurrent_statement_with_label : ( block_statement | component_instantiation_statement | generate_statement );
	[GrammarRule("concurrent_statement_with_label")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_with_label()
	{
		EnterRule_concurrent_statement_with_label();
		EnterRule("concurrent_statement_with_label", 40);
		TraceIn("concurrent_statement_with_label", 40);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_statement_with_label_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block_statement154 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> component_instantiation_statement155 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> generate_statement156 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "concurrent_statement_with_label");
		DebugLocation(527, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 40)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:528:5: ( block_statement | component_instantiation_statement | generate_statement )
			int alt55=3;
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case BLOCK:
				{
				alt55 = 1;
				}
				break;
			case BASIC_IDENTIFIER:
			case COMPONENT:
			case CONFIGURATION:
			case ENTITY:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt55 = 2;
				}
				break;
			case FOR:
			case IF:
				{
				alt55 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:528:9: block_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(528, 9);
				PushFollow(Follow._block_statement_in_concurrent_statement_with_label5483);
				block_statement154=block_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block_statement154.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:529:9: component_instantiation_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(529, 9);
				PushFollow(Follow._component_instantiation_statement_in_concurrent_statement_with_label5493);
				component_instantiation_statement155=component_instantiation_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, component_instantiation_statement155.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:530:9: generate_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(530, 9);
				PushFollow(Follow._generate_statement_in_concurrent_statement_with_label5503);
				generate_statement156=generate_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, generate_statement156.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_statement_with_label", 40);
			LeaveRule("concurrent_statement_with_label", 40);
			LeaveRule_concurrent_statement_with_label();
			if (state.backtracking > 0) { Memoize(input, 40, concurrent_statement_with_label_StartIndex); }

		}
		DebugLocation(531, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_statement_with_label"); }
		return retval;

	}
	// $ANTLR end "concurrent_statement_with_label"

	partial void EnterRule_concurrent_statement_optional_label();
	partial void LeaveRule_concurrent_statement_optional_label();

	// $ANTLR start "concurrent_statement_optional_label"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:533:1: concurrent_statement_optional_label : ( POSTPONED s= concurrent_statement_optional_label_2 -> ^( POSTPONED $s) | concurrent_statement_optional_label_2 );
	[GrammarRule("concurrent_statement_optional_label")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_optional_label()
	{
		EnterRule_concurrent_statement_optional_label();
		EnterRule("concurrent_statement_optional_label", 41);
		TraceIn("concurrent_statement_optional_label", 41);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_statement_optional_label_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken POSTPONED157 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_optional_label_2158 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree POSTPONED157_tree = default(CommonTree);
		RewriteRuleITokenStream stream_POSTPONED=new RewriteRuleITokenStream(adaptor,"token POSTPONED");
		RewriteRuleSubtreeStream stream_concurrent_statement_optional_label_2=new RewriteRuleSubtreeStream(adaptor,"rule concurrent_statement_optional_label_2");
		try { DebugEnterRule(GrammarFileName, "concurrent_statement_optional_label");
		DebugLocation(533, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 41)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:534:5: ( POSTPONED s= concurrent_statement_optional_label_2 -> ^( POSTPONED $s) | concurrent_statement_optional_label_2 )
			int alt56=2;
			try { DebugEnterDecision(56, false);
			int LA56_0 = input.LA(1);

			if ((LA56_0==POSTPONED))
			{
				alt56 = 1;
			}
			else if ((LA56_0==ASSERT||LA56_0==BASIC_IDENTIFIER||LA56_0==EXTENDED_IDENTIFIER||LA56_0==LPAREN||LA56_0==PROCESS||LA56_0==STRING_LITERAL||LA56_0==WITH))
			{
				alt56 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 56, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:534:9: POSTPONED s= concurrent_statement_optional_label_2
				{
				DebugLocation(534, 9);
				POSTPONED157=(IToken)Match(input,POSTPONED,Follow._POSTPONED_in_concurrent_statement_optional_label5522); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSTPONED.Add(POSTPONED157);

				DebugLocation(534, 20);
				PushFollow(Follow._concurrent_statement_optional_label_2_in_concurrent_statement_optional_label5526);
				s=concurrent_statement_optional_label_2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_concurrent_statement_optional_label_2.Add(s.Tree);


				{
				// AST REWRITE
				// elements: s, POSTPONED
				// token labels: 
				// rule labels: retval, s
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 535:9: -> ^( POSTPONED $s)
				{
					DebugLocation(535, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:535:12: ^( POSTPONED $s)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(535, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_POSTPONED.NextNode(), root_1);

					DebugLocation(535, 26);
					adaptor.AddChild(root_1, stream_s.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:536:9: concurrent_statement_optional_label_2
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(536, 9);
				PushFollow(Follow._concurrent_statement_optional_label_2_in_concurrent_statement_optional_label5555);
				concurrent_statement_optional_label_2158=concurrent_statement_optional_label_2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_statement_optional_label_2158.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_statement_optional_label", 41);
			LeaveRule("concurrent_statement_optional_label", 41);
			LeaveRule_concurrent_statement_optional_label();
			if (state.backtracking > 0) { Memoize(input, 41, concurrent_statement_optional_label_StartIndex); }

		}
		DebugLocation(537, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_statement_optional_label"); }
		return retval;

	}
	// $ANTLR end "concurrent_statement_optional_label"

	partial void EnterRule_concurrent_statement_optional_label_2();
	partial void LeaveRule_concurrent_statement_optional_label_2();

	// $ANTLR start "concurrent_statement_optional_label_2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:539:1: concurrent_statement_optional_label_2 : ( process_statement | ( target LE )=> conditional_signal_assignment | ( concurrent_procedure_call_statement )=> concurrent_procedure_call_statement | concurrent_assertion_statement | selected_signal_assignment );
	[GrammarRule("concurrent_statement_optional_label_2")]
	private AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement_optional_label_2()
	{
		EnterRule_concurrent_statement_optional_label_2();
		EnterRule("concurrent_statement_optional_label_2", 42);
		TraceIn("concurrent_statement_optional_label_2", 42);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int concurrent_statement_optional_label_2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> process_statement159 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditional_signal_assignment160 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_procedure_call_statement161 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_assertion_statement162 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> selected_signal_assignment163 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "concurrent_statement_optional_label_2");
		DebugLocation(539, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 42)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:540:5: ( process_statement | ( target LE )=> conditional_signal_assignment | ( concurrent_procedure_call_statement )=> concurrent_procedure_call_statement | concurrent_assertion_statement | selected_signal_assignment )
			int alt57=5;
			try { DebugEnterDecision(57, false);
			int LA57_0 = input.LA(1);

			if ((LA57_0==PROCESS))
			{
				alt57 = 1;
			}
			else if ((LA57_0==BASIC_IDENTIFIER||LA57_0==EXTENDED_IDENTIFIER))
			{
				int LA57_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_VhdlAntlr_fragment)))
				{
					alt57 = 2;
				}
				else if ((EvaluatePredicate(synpred5_VhdlAntlr_fragment)))
				{
					alt57 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA57_0==STRING_LITERAL))
			{
				int LA57_3 = input.LA(2);

				if ((EvaluatePredicate(synpred4_VhdlAntlr_fragment)))
				{
					alt57 = 2;
				}
				else if ((EvaluatePredicate(synpred5_VhdlAntlr_fragment)))
				{
					alt57 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA57_0==LPAREN) && (EvaluatePredicate(synpred4_VhdlAntlr_fragment)))
			{
				alt57 = 2;
			}
			else if ((LA57_0==ASSERT))
			{
				alt57 = 4;
			}
			else if ((LA57_0==WITH))
			{
				alt57 = 5;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:540:9: process_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(540, 9);
				PushFollow(Follow._process_statement_in_concurrent_statement_optional_label_25574);
				process_statement159=process_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, process_statement159.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:541:9: ( target LE )=> conditional_signal_assignment
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(541, 23);
				PushFollow(Follow._conditional_signal_assignment_in_concurrent_statement_optional_label_25591);
				conditional_signal_assignment160=conditional_signal_assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, conditional_signal_assignment160.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:542:9: ( concurrent_procedure_call_statement )=> concurrent_procedure_call_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(542, 49);
				PushFollow(Follow._concurrent_procedure_call_statement_in_concurrent_statement_optional_label_25606);
				concurrent_procedure_call_statement161=concurrent_procedure_call_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_procedure_call_statement161.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:543:9: concurrent_assertion_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(543, 9);
				PushFollow(Follow._concurrent_assertion_statement_in_concurrent_statement_optional_label_25616);
				concurrent_assertion_statement162=concurrent_assertion_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_assertion_statement162.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:544:9: selected_signal_assignment
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(544, 9);
				PushFollow(Follow._selected_signal_assignment_in_concurrent_statement_optional_label_25626);
				selected_signal_assignment163=selected_signal_assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, selected_signal_assignment163.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concurrent_statement_optional_label_2", 42);
			LeaveRule("concurrent_statement_optional_label_2", 42);
			LeaveRule_concurrent_statement_optional_label_2();
			if (state.backtracking > 0) { Memoize(input, 42, concurrent_statement_optional_label_2_StartIndex); }

		}
		DebugLocation(545, 4);
		} finally { DebugExitRule(GrammarFileName, "concurrent_statement_optional_label_2"); }
		return retval;

	}
	// $ANTLR end "concurrent_statement_optional_label_2"

	partial void EnterRule_condition();
	partial void LeaveRule_condition();

	// $ANTLR start "condition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:547:1: condition : bolean_expression= expression ;
	[GrammarRule("condition")]
	private AstParserRuleReturnScope<CommonTree, IToken> condition()
	{
		EnterRule_condition();
		EnterRule("condition", 43);
		TraceIn("condition", 43);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int condition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> bolean_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "condition");
		DebugLocation(547, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 43)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:548:5: (bolean_expression= expression )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:548:9: bolean_expression= expression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(548, 26);
			PushFollow(Follow._expression_in_condition5647);
			bolean_expression=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bolean_expression.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condition", 43);
			LeaveRule("condition", 43);
			LeaveRule_condition();
			if (state.backtracking > 0) { Memoize(input, 43, condition_StartIndex); }

		}
		DebugLocation(549, 4);
		} finally { DebugExitRule(GrammarFileName, "condition"); }
		return retval;

	}
	// $ANTLR end "condition"

	partial void EnterRule_condition_clause();
	partial void LeaveRule_condition_clause();

	// $ANTLR start "condition_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:551:1: condition_clause : UNTIL condition -> ^( UNTIL condition ) ;
	[GrammarRule("condition_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> condition_clause()
	{
		EnterRule_condition_clause();
		EnterRule("condition_clause", 44);
		TraceIn("condition_clause", 44);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int condition_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken UNTIL164 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition165 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree UNTIL164_tree = default(CommonTree);
		RewriteRuleITokenStream stream_UNTIL=new RewriteRuleITokenStream(adaptor,"token UNTIL");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "condition_clause");
		DebugLocation(551, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 44)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:552:5: ( UNTIL condition -> ^( UNTIL condition ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:552:9: UNTIL condition
			{
			DebugLocation(552, 9);
			UNTIL164=(IToken)Match(input,UNTIL,Follow._UNTIL_in_condition_clause5666); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_UNTIL.Add(UNTIL164);

			DebugLocation(552, 15);
			PushFollow(Follow._condition_in_condition_clause5668);
			condition165=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition165.Tree);


			{
			// AST REWRITE
			// elements: UNTIL, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 553:9: -> ^( UNTIL condition )
			{
				DebugLocation(553, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:553:12: ^( UNTIL condition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(553, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_UNTIL.NextNode(), root_1);

				DebugLocation(553, 21);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condition_clause", 44);
			LeaveRule("condition_clause", 44);
			LeaveRule_condition_clause();
			if (state.backtracking > 0) { Memoize(input, 44, condition_clause_StartIndex); }

		}
		DebugLocation(554, 4);
		} finally { DebugExitRule(GrammarFileName, "condition_clause"); }
		return retval;

	}
	// $ANTLR end "condition_clause"

	partial void EnterRule_conditional_signal_assignment();
	partial void LeaveRule_conditional_signal_assignment();

	// $ANTLR start "conditional_signal_assignment"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:556:1: conditional_signal_assignment : target LE sao= signal_assignment_options cw= conditional_waveforms SEMI -> ^( CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT target ( $sao)? $cw) ;
	[GrammarRule("conditional_signal_assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditional_signal_assignment()
	{
		EnterRule_conditional_signal_assignment();
		EnterRule("conditional_signal_assignment", 45);
		TraceIn("conditional_signal_assignment", 45);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditional_signal_assignment_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LE167 = default(IToken);
		IToken SEMI168 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sao = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cw = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> target166 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LE167_tree = default(CommonTree);
		CommonTree SEMI168_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LE=new RewriteRuleITokenStream(adaptor,"token LE");
		RewriteRuleSubtreeStream stream_conditional_waveforms=new RewriteRuleSubtreeStream(adaptor,"rule conditional_waveforms");
		RewriteRuleSubtreeStream stream_signal_assignment_options=new RewriteRuleSubtreeStream(adaptor,"rule signal_assignment_options");
		RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target");
		try { DebugEnterRule(GrammarFileName, "conditional_signal_assignment");
		DebugLocation(556, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 45)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:557:5: ( target LE sao= signal_assignment_options cw= conditional_waveforms SEMI -> ^( CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT target ( $sao)? $cw) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:557:9: target LE sao= signal_assignment_options cw= conditional_waveforms SEMI
			{
			DebugLocation(557, 9);
			PushFollow(Follow._target_in_conditional_signal_assignment5705);
			target166=target();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_target.Add(target166.Tree);
			DebugLocation(557, 16);
			LE167=(IToken)Match(input,LE,Follow._LE_in_conditional_signal_assignment5707); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LE.Add(LE167);

			DebugLocation(557, 22);
			PushFollow(Follow._signal_assignment_options_in_conditional_signal_assignment5711);
			sao=signal_assignment_options();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_signal_assignment_options.Add(sao.Tree);
			DebugLocation(557, 51);
			PushFollow(Follow._conditional_waveforms_in_conditional_signal_assignment5715);
			cw=conditional_waveforms();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_conditional_waveforms.Add(cw.Tree);
			DebugLocation(557, 74);
			SEMI168=(IToken)Match(input,SEMI,Follow._SEMI_in_conditional_signal_assignment5717); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI168);



			{
			// AST REWRITE
			// elements: sao, target, cw
			// token labels: 
			// rule labels: retval, sao, cw
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_sao=new RewriteRuleSubtreeStream(adaptor,"rule sao",sao!=null?sao.Tree:null);
			RewriteRuleSubtreeStream stream_cw=new RewriteRuleSubtreeStream(adaptor,"rule cw",cw!=null?cw.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 558:9: -> ^( CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT target ( $sao)? $cw)
			{
				DebugLocation(558, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:558:12: ^( CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT target ( $sao)? $cw)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(558, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT, "CONDITIONAL_SIGNAL_ASSIGNMENT_STATEMENT"), root_1);

				DebugLocation(558, 55);
				adaptor.AddChild(root_1, stream_target.NextTree());
				DebugLocation(558, 63);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:558:63: ( $sao)?
				if (stream_sao.HasNext)
				{
					DebugLocation(558, 63);
					adaptor.AddChild(root_1, stream_sao.NextTree());

				}
				stream_sao.Reset();
				DebugLocation(558, 69);
				adaptor.AddChild(root_1, stream_cw.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditional_signal_assignment", 45);
			LeaveRule("conditional_signal_assignment", 45);
			LeaveRule_conditional_signal_assignment();
			if (state.backtracking > 0) { Memoize(input, 45, conditional_signal_assignment_StartIndex); }

		}
		DebugLocation(559, 4);
		} finally { DebugExitRule(GrammarFileName, "conditional_signal_assignment"); }
		return retval;

	}
	// $ANTLR end "conditional_signal_assignment"

	partial void EnterRule_conditional_waveforms();
	partial void LeaveRule_conditional_waveforms();

	// $ANTLR start "conditional_waveforms"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:561:1: conditional_waveforms : waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )? -> ^( CONDITIONAL_WAVEFORMS waveform ( condition )? ( conditional_waveforms2 )? ) ;
	[GrammarRule("conditional_waveforms")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditional_waveforms()
	{
		EnterRule_conditional_waveforms();
		EnterRule("conditional_waveforms", 46);
		TraceIn("conditional_waveforms", 46);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditional_waveforms_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WHEN170 = default(IToken);
		IToken ELSE172 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> waveform169 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition171 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditional_waveforms2173 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHEN170_tree = default(CommonTree);
		CommonTree ELSE172_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_conditional_waveforms2=new RewriteRuleSubtreeStream(adaptor,"rule conditional_waveforms2");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_waveform=new RewriteRuleSubtreeStream(adaptor,"rule waveform");
		try { DebugEnterRule(GrammarFileName, "conditional_waveforms");
		DebugLocation(561, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 46)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:5: ( waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )? -> ^( CONDITIONAL_WAVEFORMS waveform ( condition )? ( conditional_waveforms2 )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:9: waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )?
			{
			DebugLocation(562, 9);
			PushFollow(Follow._waveform_in_conditional_waveforms5761);
			waveform169=waveform();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_waveform.Add(waveform169.Tree);
			DebugLocation(562, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:18: ( WHEN condition ( ELSE conditional_waveforms2 )? )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_0 = input.LA(1);

			if ((LA59_0==WHEN))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:20: WHEN condition ( ELSE conditional_waveforms2 )?
				{
				DebugLocation(562, 20);
				WHEN170=(IToken)Match(input,WHEN,Follow._WHEN_in_conditional_waveforms5765); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHEN.Add(WHEN170);

				DebugLocation(562, 25);
				PushFollow(Follow._condition_in_conditional_waveforms5767);
				condition171=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition171.Tree);
				DebugLocation(562, 35);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:35: ( ELSE conditional_waveforms2 )?
				int alt58=2;
				try { DebugEnterSubRule(58);
				try { DebugEnterDecision(58, false);
				int LA58_0 = input.LA(1);

				if ((LA58_0==ELSE))
				{
					alt58 = 1;
				}
				} finally { DebugExitDecision(58); }
				switch (alt58)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:562:37: ELSE conditional_waveforms2
					{
					DebugLocation(562, 37);
					ELSE172=(IToken)Match(input,ELSE,Follow._ELSE_in_conditional_waveforms5771); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ELSE.Add(ELSE172);

					DebugLocation(562, 42);
					PushFollow(Follow._conditional_waveforms2_in_conditional_waveforms5773);
					conditional_waveforms2173=conditional_waveforms2();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_conditional_waveforms2.Add(conditional_waveforms2173.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(58); }


				}
				break;

			}
			} finally { DebugExitSubRule(59); }



			{
			// AST REWRITE
			// elements: waveform, conditional_waveforms2, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 563:9: -> ^( CONDITIONAL_WAVEFORMS waveform ( condition )? ( conditional_waveforms2 )? )
			{
				DebugLocation(563, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:563:12: ^( CONDITIONAL_WAVEFORMS waveform ( condition )? ( conditional_waveforms2 )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(563, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONDITIONAL_WAVEFORMS, "CONDITIONAL_WAVEFORMS"), root_1);

				DebugLocation(563, 37);
				adaptor.AddChild(root_1, stream_waveform.NextTree());
				DebugLocation(563, 46);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:563:46: ( condition )?
				if (stream_condition.HasNext)
				{
					DebugLocation(563, 46);
					adaptor.AddChild(root_1, stream_condition.NextTree());

				}
				stream_condition.Reset();
				DebugLocation(563, 57);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:563:57: ( conditional_waveforms2 )?
				if (stream_conditional_waveforms2.HasNext)
				{
					DebugLocation(563, 57);
					adaptor.AddChild(root_1, stream_conditional_waveforms2.NextTree());

				}
				stream_conditional_waveforms2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditional_waveforms", 46);
			LeaveRule("conditional_waveforms", 46);
			LeaveRule_conditional_waveforms();
			if (state.backtracking > 0) { Memoize(input, 46, conditional_waveforms_StartIndex); }

		}
		DebugLocation(564, 4);
		} finally { DebugExitRule(GrammarFileName, "conditional_waveforms"); }
		return retval;

	}
	// $ANTLR end "conditional_waveforms"

	partial void EnterRule_conditional_waveforms2();
	partial void LeaveRule_conditional_waveforms2();

	// $ANTLR start "conditional_waveforms2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:566:1: conditional_waveforms2 : waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )? -> waveform ( condition )? ( conditional_waveforms2 )? ;
	[GrammarRule("conditional_waveforms2")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditional_waveforms2()
	{
		EnterRule_conditional_waveforms2();
		EnterRule("conditional_waveforms2", 47);
		TraceIn("conditional_waveforms2", 47);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditional_waveforms2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WHEN175 = default(IToken);
		IToken ELSE177 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> waveform174 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition176 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditional_waveforms2178 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHEN175_tree = default(CommonTree);
		CommonTree ELSE177_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_conditional_waveforms2=new RewriteRuleSubtreeStream(adaptor,"rule conditional_waveforms2");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_waveform=new RewriteRuleSubtreeStream(adaptor,"rule waveform");
		try { DebugEnterRule(GrammarFileName, "conditional_waveforms2");
		DebugLocation(566, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 47)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:5: ( waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )? -> waveform ( condition )? ( conditional_waveforms2 )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:9: waveform ( WHEN condition ( ELSE conditional_waveforms2 )? )?
			{
			DebugLocation(567, 9);
			PushFollow(Follow._waveform_in_conditional_waveforms25822);
			waveform174=waveform();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_waveform.Add(waveform174.Tree);
			DebugLocation(567, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:18: ( WHEN condition ( ELSE conditional_waveforms2 )? )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_0 = input.LA(1);

			if ((LA61_0==WHEN))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:20: WHEN condition ( ELSE conditional_waveforms2 )?
				{
				DebugLocation(567, 20);
				WHEN175=(IToken)Match(input,WHEN,Follow._WHEN_in_conditional_waveforms25826); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHEN.Add(WHEN175);

				DebugLocation(567, 25);
				PushFollow(Follow._condition_in_conditional_waveforms25828);
				condition176=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition176.Tree);
				DebugLocation(567, 35);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:35: ( ELSE conditional_waveforms2 )?
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_0 = input.LA(1);

				if ((LA60_0==ELSE))
				{
					alt60 = 1;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:567:37: ELSE conditional_waveforms2
					{
					DebugLocation(567, 37);
					ELSE177=(IToken)Match(input,ELSE,Follow._ELSE_in_conditional_waveforms25832); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ELSE.Add(ELSE177);

					DebugLocation(567, 42);
					PushFollow(Follow._conditional_waveforms2_in_conditional_waveforms25834);
					conditional_waveforms2178=conditional_waveforms2();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_conditional_waveforms2.Add(conditional_waveforms2178.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(60); }


				}
				break;

			}
			} finally { DebugExitSubRule(61); }



			{
			// AST REWRITE
			// elements: waveform, conditional_waveforms2, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 568:9: -> waveform ( condition )? ( conditional_waveforms2 )?
			{
				DebugLocation(568, 12);
				adaptor.AddChild(root_0, stream_waveform.NextTree());
				DebugLocation(568, 21);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:568:21: ( condition )?
				if (stream_condition.HasNext)
				{
					DebugLocation(568, 21);
					adaptor.AddChild(root_0, stream_condition.NextTree());

				}
				stream_condition.Reset();
				DebugLocation(568, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:568:32: ( conditional_waveforms2 )?
				if (stream_conditional_waveforms2.HasNext)
				{
					DebugLocation(568, 32);
					adaptor.AddChild(root_0, stream_conditional_waveforms2.NextTree());

				}
				stream_conditional_waveforms2.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditional_waveforms2", 47);
			LeaveRule("conditional_waveforms2", 47);
			LeaveRule_conditional_waveforms2();
			if (state.backtracking > 0) { Memoize(input, 47, conditional_waveforms2_StartIndex); }

		}
		DebugLocation(569, 4);
		} finally { DebugExitRule(GrammarFileName, "conditional_waveforms2"); }
		return retval;

	}
	// $ANTLR end "conditional_waveforms2"

	partial void EnterRule_configuration_declaration();
	partial void LeaveRule_configuration_declaration();

	// $ANTLR start "configuration_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:572:1: configuration_declaration : CONFIGURATION identifier OF entity= name IS (cdp= configuration_declarative_part )? bc= block_configuration END ( CONFIGURATION )? ( end_identifier )? SEMI -> ^( CONFIGURATION identifier $entity ( $cdp)? $bc ( end_identifier )? ) ;
	[GrammarRule("configuration_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> configuration_declaration()
	{
		EnterRule_configuration_declaration();
		EnterRule("configuration_declaration", 48);
		TraceIn("configuration_declaration", 48);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int configuration_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CONFIGURATION179 = default(IToken);
		IToken OF181 = default(IToken);
		IToken IS182 = default(IToken);
		IToken END183 = default(IToken);
		IToken CONFIGURATION184 = default(IToken);
		IToken SEMI186 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cdp = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bc = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier180 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier185 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONFIGURATION179_tree = default(CommonTree);
		CommonTree OF181_tree = default(CommonTree);
		CommonTree IS182_tree = default(CommonTree);
		CommonTree END183_tree = default(CommonTree);
		CommonTree CONFIGURATION184_tree = default(CommonTree);
		CommonTree SEMI186_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CONFIGURATION=new RewriteRuleITokenStream(adaptor,"token CONFIGURATION");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_configuration_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule configuration_declarative_part");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_block_configuration=new RewriteRuleSubtreeStream(adaptor,"rule block_configuration");
		try { DebugEnterRule(GrammarFileName, "configuration_declaration");
		DebugLocation(572, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 48)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:573:5: ( CONFIGURATION identifier OF entity= name IS (cdp= configuration_declarative_part )? bc= block_configuration END ( CONFIGURATION )? ( end_identifier )? SEMI -> ^( CONFIGURATION identifier $entity ( $cdp)? $bc ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:573:9: CONFIGURATION identifier OF entity= name IS (cdp= configuration_declarative_part )? bc= block_configuration END ( CONFIGURATION )? ( end_identifier )? SEMI
			{
			DebugLocation(573, 9);
			CONFIGURATION179=(IToken)Match(input,CONFIGURATION,Follow._CONFIGURATION_in_configuration_declaration5878); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONFIGURATION.Add(CONFIGURATION179);

			DebugLocation(573, 23);
			PushFollow(Follow._identifier_in_configuration_declaration5880);
			identifier180=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier180.Tree);
			DebugLocation(573, 34);
			OF181=(IToken)Match(input,OF,Follow._OF_in_configuration_declaration5882); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF181);

			DebugLocation(573, 43);
			PushFollow(Follow._name_in_configuration_declaration5886);
			entity=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(entity.Tree);
			DebugLocation(573, 49);
			IS182=(IToken)Match(input,IS,Follow._IS_in_configuration_declaration5888); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS182);

			DebugLocation(574, 12);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:574:12: (cdp= configuration_declarative_part )?
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_0 = input.LA(1);

			if ((LA62_0==ATTRIBUTE||LA62_0==GROUP||LA62_0==USE))
			{
				alt62 = 1;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:574:12: cdp= configuration_declarative_part
				{
				DebugLocation(574, 12);
				PushFollow(Follow._configuration_declarative_part_in_configuration_declaration5900);
				cdp=configuration_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_configuration_declarative_part.Add(cdp.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(62); }

			DebugLocation(575, 11);
			PushFollow(Follow._block_configuration_in_configuration_declaration5913);
			bc=block_configuration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block_configuration.Add(bc.Tree);
			DebugLocation(576, 9);
			END183=(IToken)Match(input,END,Follow._END_in_configuration_declaration5923); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END183);

			DebugLocation(576, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:576:13: ( CONFIGURATION )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_0 = input.LA(1);

			if ((LA63_0==CONFIGURATION))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:576:13: CONFIGURATION
				{
				DebugLocation(576, 13);
				CONFIGURATION184=(IToken)Match(input,CONFIGURATION,Follow._CONFIGURATION_in_configuration_declaration5925); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONFIGURATION.Add(CONFIGURATION184);


				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(576, 28);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:576:28: ( end_identifier )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==BASIC_IDENTIFIER||LA64_0==EXTENDED_IDENTIFIER))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:576:28: end_identifier
				{
				DebugLocation(576, 28);
				PushFollow(Follow._end_identifier_in_configuration_declaration5928);
				end_identifier185=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier185.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(576, 44);
			SEMI186=(IToken)Match(input,SEMI,Follow._SEMI_in_configuration_declaration5931); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI186);



			{
			// AST REWRITE
			// elements: CONFIGURATION, cdp, bc, end_identifier, entity, identifier
			// token labels: 
			// rule labels: retval, cdp, entity, bc
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_cdp=new RewriteRuleSubtreeStream(adaptor,"rule cdp",cdp!=null?cdp.Tree:null);
			RewriteRuleSubtreeStream stream_entity=new RewriteRuleSubtreeStream(adaptor,"rule entity",entity!=null?entity.Tree:null);
			RewriteRuleSubtreeStream stream_bc=new RewriteRuleSubtreeStream(adaptor,"rule bc",bc!=null?bc.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 577:9: -> ^( CONFIGURATION identifier $entity ( $cdp)? $bc ( end_identifier )? )
			{
				DebugLocation(577, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:577:12: ^( CONFIGURATION identifier $entity ( $cdp)? $bc ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(577, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_CONFIGURATION.NextNode(), root_1);

				DebugLocation(577, 29);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(577, 41);
				adaptor.AddChild(root_1, stream_entity.NextTree());
				DebugLocation(577, 49);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:577:49: ( $cdp)?
				if (stream_cdp.HasNext)
				{
					DebugLocation(577, 49);
					adaptor.AddChild(root_1, stream_cdp.NextTree());

				}
				stream_cdp.Reset();
				DebugLocation(577, 55);
				adaptor.AddChild(root_1, stream_bc.NextTree());
				DebugLocation(577, 58);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:577:58: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(577, 58);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("configuration_declaration", 48);
			LeaveRule("configuration_declaration", 48);
			LeaveRule_configuration_declaration();
			if (state.backtracking > 0) { Memoize(input, 48, configuration_declaration_StartIndex); }

		}
		DebugLocation(578, 4);
		} finally { DebugExitRule(GrammarFileName, "configuration_declaration"); }
		return retval;

	}
	// $ANTLR end "configuration_declaration"

	partial void EnterRule_configuration_declarative_item();
	partial void LeaveRule_configuration_declarative_item();

	// $ANTLR start "configuration_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:580:1: configuration_declarative_item : ( use_clause | attribute_specification | group_declaration );
	[GrammarRule("configuration_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> configuration_declarative_item()
	{
		EnterRule_configuration_declarative_item();
		EnterRule("configuration_declarative_item", 49);
		TraceIn("configuration_declarative_item", 49);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int configuration_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> use_clause187 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification188 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration189 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "configuration_declarative_item");
		DebugLocation(580, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 49)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:581:5: ( use_clause | attribute_specification | group_declaration )
			int alt65=3;
			try { DebugEnterDecision(65, false);
			switch (input.LA(1))
			{
			case USE:
				{
				alt65 = 1;
				}
				break;
			case ATTRIBUTE:
				{
				alt65 = 2;
				}
				break;
			case GROUP:
				{
				alt65 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:581:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(581, 9);
				PushFollow(Follow._use_clause_in_configuration_declarative_item5981);
				use_clause187=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause187.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:582:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(582, 9);
				PushFollow(Follow._attribute_specification_in_configuration_declarative_item5991);
				attribute_specification188=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification188.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:583:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(583, 9);
				PushFollow(Follow._group_declaration_in_configuration_declarative_item6001);
				group_declaration189=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration189.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("configuration_declarative_item", 49);
			LeaveRule("configuration_declarative_item", 49);
			LeaveRule_configuration_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 49, configuration_declarative_item_StartIndex); }

		}
		DebugLocation(584, 4);
		} finally { DebugExitRule(GrammarFileName, "configuration_declarative_item"); }
		return retval;

	}
	// $ANTLR end "configuration_declarative_item"

	partial void EnterRule_configuration_declarative_part();
	partial void LeaveRule_configuration_declarative_part();

	// $ANTLR start "configuration_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:586:1: configuration_declarative_part : ( configuration_declarative_item )+ ;
	[GrammarRule("configuration_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> configuration_declarative_part()
	{
		EnterRule_configuration_declarative_part();
		EnterRule("configuration_declarative_part", 50);
		TraceIn("configuration_declarative_part", 50);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int configuration_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> configuration_declarative_item190 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "configuration_declarative_part");
		DebugLocation(586, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 50)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:587:5: ( ( configuration_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:587:9: ( configuration_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(587, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:587:9: ( configuration_declarative_item )+
			int cnt66=0;
			try { DebugEnterSubRule(66);
			while (true)
			{
				int alt66=2;
				try { DebugEnterDecision(66, false);
				int LA66_0 = input.LA(1);

				if ((LA66_0==ATTRIBUTE||LA66_0==GROUP||LA66_0==USE))
				{
					alt66 = 1;
				}


				} finally { DebugExitDecision(66); }
				switch (alt66)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:587:9: configuration_declarative_item
					{
					DebugLocation(587, 9);
					PushFollow(Follow._configuration_declarative_item_in_configuration_declarative_part6020);
					configuration_declarative_item190=configuration_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, configuration_declarative_item190.Tree);

					}
					break;

				default:
					if (cnt66 >= 1)
						goto loop66;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee66 = new EarlyExitException( 66, input );
					DebugRecognitionException(eee66);
					throw eee66;
				}
				cnt66++;
			}
			loop66:
				;

			} finally { DebugExitSubRule(66); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("configuration_declarative_part", 50);
			LeaveRule("configuration_declarative_part", 50);
			LeaveRule_configuration_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 50, configuration_declarative_part_StartIndex); }

		}
		DebugLocation(588, 4);
		} finally { DebugExitRule(GrammarFileName, "configuration_declarative_part"); }
		return retval;

	}
	// $ANTLR end "configuration_declarative_part"

	partial void EnterRule_configuration_item();
	partial void LeaveRule_configuration_item();

	// $ANTLR start "configuration_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:590:1: configuration_item : ( block_configuration | component_configuration );
	[GrammarRule("configuration_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> configuration_item()
	{
		EnterRule_configuration_item();
		EnterRule("configuration_item", 51);
		TraceIn("configuration_item", 51);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int configuration_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block_configuration191 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> component_configuration192 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "configuration_item");
		DebugLocation(590, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 51)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:591:5: ( block_configuration | component_configuration )
			int alt67=2;
			try { DebugEnterDecision(67, false);
			int LA67_0 = input.LA(1);

			if ((LA67_0==FOR))
			{
				switch (input.LA(2))
				{
				case BASIC_IDENTIFIER:
				case EXTENDED_IDENTIFIER:
					{
					int LA67_2 = input.LA(3);

					if ((LA67_2==APOSTROPHE||LA67_2==DOT||LA67_2==END||LA67_2==FOR||LA67_2==LBRACKET||LA67_2==LPAREN||LA67_2==USE))
					{
						alt67 = 1;
					}
					else if (((LA67_2>=COLON && LA67_2<=COMMA)))
					{
						alt67 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 67, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case STRING_LITERAL:
					{
					alt67 = 1;
					}
					break;
				case ALL:
				case OTHERS:
					{
					alt67 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 67, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:591:9: block_configuration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(591, 9);
				PushFollow(Follow._block_configuration_in_configuration_item6040);
				block_configuration191=block_configuration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block_configuration191.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:592:9: component_configuration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(592, 9);
				PushFollow(Follow._component_configuration_in_configuration_item6050);
				component_configuration192=component_configuration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, component_configuration192.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("configuration_item", 51);
			LeaveRule("configuration_item", 51);
			LeaveRule_configuration_item();
			if (state.backtracking > 0) { Memoize(input, 51, configuration_item_StartIndex); }

		}
		DebugLocation(593, 4);
		} finally { DebugExitRule(GrammarFileName, "configuration_item"); }
		return retval;

	}
	// $ANTLR end "configuration_item"

	partial void EnterRule_configuration_specification();
	partial void LeaveRule_configuration_specification();

	// $ANTLR start "configuration_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:595:1: configuration_specification : FOR component_specification binding_indication SEMI -> ^( CONFIGURATION_SPECIFICATION component_specification ( binding_indication )? ) ;
	[GrammarRule("configuration_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> configuration_specification()
	{
		EnterRule_configuration_specification();
		EnterRule("configuration_specification", 52);
		TraceIn("configuration_specification", 52);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int configuration_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FOR193 = default(IToken);
		IToken SEMI196 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> component_specification194 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> binding_indication195 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR193_tree = default(CommonTree);
		CommonTree SEMI196_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_component_specification=new RewriteRuleSubtreeStream(adaptor,"rule component_specification");
		RewriteRuleSubtreeStream stream_binding_indication=new RewriteRuleSubtreeStream(adaptor,"rule binding_indication");
		try { DebugEnterRule(GrammarFileName, "configuration_specification");
		DebugLocation(595, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 52)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:596:5: ( FOR component_specification binding_indication SEMI -> ^( CONFIGURATION_SPECIFICATION component_specification ( binding_indication )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:596:9: FOR component_specification binding_indication SEMI
			{
			DebugLocation(596, 9);
			FOR193=(IToken)Match(input,FOR,Follow._FOR_in_configuration_specification6069); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR193);

			DebugLocation(596, 13);
			PushFollow(Follow._component_specification_in_configuration_specification6071);
			component_specification194=component_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_component_specification.Add(component_specification194.Tree);
			DebugLocation(596, 37);
			PushFollow(Follow._binding_indication_in_configuration_specification6073);
			binding_indication195=binding_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_binding_indication.Add(binding_indication195.Tree);
			DebugLocation(596, 56);
			SEMI196=(IToken)Match(input,SEMI,Follow._SEMI_in_configuration_specification6075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI196);



			{
			// AST REWRITE
			// elements: component_specification, binding_indication
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 597:9: -> ^( CONFIGURATION_SPECIFICATION component_specification ( binding_indication )? )
			{
				DebugLocation(597, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:597:12: ^( CONFIGURATION_SPECIFICATION component_specification ( binding_indication )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(597, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONFIGURATION_SPECIFICATION, "CONFIGURATION_SPECIFICATION"), root_1);

				DebugLocation(597, 43);
				adaptor.AddChild(root_1, stream_component_specification.NextTree());
				DebugLocation(597, 67);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:597:67: ( binding_indication )?
				if (stream_binding_indication.HasNext)
				{
					DebugLocation(597, 67);
					adaptor.AddChild(root_1, stream_binding_indication.NextTree());

				}
				stream_binding_indication.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("configuration_specification", 52);
			LeaveRule("configuration_specification", 52);
			LeaveRule_configuration_specification();
			if (state.backtracking > 0) { Memoize(input, 52, configuration_specification_StartIndex); }

		}
		DebugLocation(598, 4);
		} finally { DebugExitRule(GrammarFileName, "configuration_specification"); }
		return retval;

	}
	// $ANTLR end "configuration_specification"

	partial void EnterRule_constant_declaration();
	partial void LeaveRule_constant_declaration();

	// $ANTLR start "constant_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:600:1: constant_declaration : CONSTANT identifier_list COLON subtype_indication ( VARASGN expression )? SEMI -> ^( CONSTANT identifier_list subtype_indication ( expression )? ) ;
	[GrammarRule("constant_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> constant_declaration()
	{
		EnterRule_constant_declaration();
		EnterRule("constant_declaration", 53);
		TraceIn("constant_declaration", 53);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int constant_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CONSTANT197 = default(IToken);
		IToken COLON199 = default(IToken);
		IToken VARASGN201 = default(IToken);
		IToken SEMI203 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list198 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication200 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression202 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONSTANT197_tree = default(CommonTree);
		CommonTree COLON199_tree = default(CommonTree);
		CommonTree VARASGN201_tree = default(CommonTree);
		CommonTree SEMI203_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_CONSTANT=new RewriteRuleITokenStream(adaptor,"token CONSTANT");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "constant_declaration");
		DebugLocation(600, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 53)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:601:5: ( CONSTANT identifier_list COLON subtype_indication ( VARASGN expression )? SEMI -> ^( CONSTANT identifier_list subtype_indication ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:601:9: CONSTANT identifier_list COLON subtype_indication ( VARASGN expression )? SEMI
			{
			DebugLocation(601, 9);
			CONSTANT197=(IToken)Match(input,CONSTANT,Follow._CONSTANT_in_constant_declaration6115); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONSTANT.Add(CONSTANT197);

			DebugLocation(601, 18);
			PushFollow(Follow._identifier_list_in_constant_declaration6117);
			identifier_list198=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list198.Tree);
			DebugLocation(601, 34);
			COLON199=(IToken)Match(input,COLON,Follow._COLON_in_constant_declaration6119); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON199);

			DebugLocation(601, 40);
			PushFollow(Follow._subtype_indication_in_constant_declaration6121);
			subtype_indication200=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication200.Tree);
			DebugLocation(601, 59);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:601:59: ( VARASGN expression )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_0 = input.LA(1);

			if ((LA68_0==VARASGN))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:601:61: VARASGN expression
				{
				DebugLocation(601, 61);
				VARASGN201=(IToken)Match(input,VARASGN,Follow._VARASGN_in_constant_declaration6125); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN201);

				DebugLocation(601, 69);
				PushFollow(Follow._expression_in_constant_declaration6127);
				expression202=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression202.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(601, 83);
			SEMI203=(IToken)Match(input,SEMI,Follow._SEMI_in_constant_declaration6132); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI203);



			{
			// AST REWRITE
			// elements: subtype_indication, expression, identifier_list, CONSTANT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 602:9: -> ^( CONSTANT identifier_list subtype_indication ( expression )? )
			{
				DebugLocation(602, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:602:12: ^( CONSTANT identifier_list subtype_indication ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(602, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_CONSTANT.NextNode(), root_1);

				DebugLocation(602, 24);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(602, 40);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(602, 59);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:602:59: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(602, 59);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant_declaration", 53);
			LeaveRule("constant_declaration", 53);
			LeaveRule_constant_declaration();
			if (state.backtracking > 0) { Memoize(input, 53, constant_declaration_StartIndex); }

		}
		DebugLocation(603, 4);
		} finally { DebugExitRule(GrammarFileName, "constant_declaration"); }
		return retval;

	}
	// $ANTLR end "constant_declaration"

	partial void EnterRule_constrained_array_definition();
	partial void LeaveRule_constrained_array_definition();

	// $ANTLR start "constrained_array_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:605:2: constrained_array_definition : index_constraint OF element_subtype_indication= subtype_indication -> ^( CONSTRAINED_ARRAY_DEFINITION index_constraint $element_subtype_indication) ;
	[GrammarRule("constrained_array_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> constrained_array_definition()
	{
		EnterRule_constrained_array_definition();
		EnterRule("constrained_array_definition", 54);
		TraceIn("constrained_array_definition", 54);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int constrained_array_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken OF205 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> element_subtype_indication = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> index_constraint204 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree OF205_tree = default(CommonTree);
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_index_constraint=new RewriteRuleSubtreeStream(adaptor,"rule index_constraint");
		try { DebugEnterRule(GrammarFileName, "constrained_array_definition");
		DebugLocation(605, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 54)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:606:5: ( index_constraint OF element_subtype_indication= subtype_indication -> ^( CONSTRAINED_ARRAY_DEFINITION index_constraint $element_subtype_indication) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:606:9: index_constraint OF element_subtype_indication= subtype_indication
			{
			DebugLocation(606, 9);
			PushFollow(Follow._index_constraint_in_constrained_array_definition6175);
			index_constraint204=index_constraint();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index_constraint.Add(index_constraint204.Tree);
			DebugLocation(606, 26);
			OF205=(IToken)Match(input,OF,Follow._OF_in_constrained_array_definition6177); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF205);

			DebugLocation(606, 55);
			PushFollow(Follow._subtype_indication_in_constrained_array_definition6181);
			element_subtype_indication=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(element_subtype_indication.Tree);


			{
			// AST REWRITE
			// elements: element_subtype_indication, index_constraint
			// token labels: 
			// rule labels: retval, element_subtype_indication
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_element_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule element_subtype_indication",element_subtype_indication!=null?element_subtype_indication.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 607:9: -> ^( CONSTRAINED_ARRAY_DEFINITION index_constraint $element_subtype_indication)
			{
				DebugLocation(607, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:607:12: ^( CONSTRAINED_ARRAY_DEFINITION index_constraint $element_subtype_indication)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(607, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONSTRAINED_ARRAY_DEFINITION, "CONSTRAINED_ARRAY_DEFINITION"), root_1);

				DebugLocation(607, 44);
				adaptor.AddChild(root_1, stream_index_constraint.NextTree());
				DebugLocation(607, 62);
				adaptor.AddChild(root_1, stream_element_subtype_indication.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constrained_array_definition", 54);
			LeaveRule("constrained_array_definition", 54);
			LeaveRule_constrained_array_definition();
			if (state.backtracking > 0) { Memoize(input, 54, constrained_array_definition_StartIndex); }

		}
		DebugLocation(608, 4);
		} finally { DebugExitRule(GrammarFileName, "constrained_array_definition"); }
		return retval;

	}
	// $ANTLR end "constrained_array_definition"

	partial void EnterRule_constraint();
	partial void LeaveRule_constraint();

	// $ANTLR start "constraint"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:610:1: constraint : ( range_constraint | index_constraint );
	[GrammarRule("constraint")]
	private AstParserRuleReturnScope<CommonTree, IToken> constraint()
	{
		EnterRule_constraint();
		EnterRule("constraint", 55);
		TraceIn("constraint", 55);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int constraint_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> range_constraint206 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> index_constraint207 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "constraint");
		DebugLocation(610, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 55)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:611:5: ( range_constraint | index_constraint )
			int alt69=2;
			try { DebugEnterDecision(69, false);
			int LA69_0 = input.LA(1);

			if ((LA69_0==RANGETOK))
			{
				alt69 = 1;
			}
			else if ((LA69_0==LPAREN))
			{
				alt69 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 69, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:611:9: range_constraint
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(611, 9);
				PushFollow(Follow._range_constraint_in_constraint6221);
				range_constraint206=range_constraint();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, range_constraint206.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:612:9: index_constraint
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(612, 9);
				PushFollow(Follow._index_constraint_in_constraint6231);
				index_constraint207=index_constraint();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, index_constraint207.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constraint", 55);
			LeaveRule("constraint", 55);
			LeaveRule_constraint();
			if (state.backtracking > 0) { Memoize(input, 55, constraint_StartIndex); }

		}
		DebugLocation(613, 4);
		} finally { DebugExitRule(GrammarFileName, "constraint"); }
		return retval;

	}
	// $ANTLR end "constraint"

	partial void EnterRule_context_clause();
	partial void LeaveRule_context_clause();

	// $ANTLR start "context_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:615:1: context_clause : ( context_item )* ;
	[GrammarRule("context_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> context_clause()
	{
		EnterRule_context_clause();
		EnterRule("context_clause", 56);
		TraceIn("context_clause", 56);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int context_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> context_item208 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "context_clause");
		DebugLocation(615, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 56)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:616:5: ( ( context_item )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:616:9: ( context_item )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(616, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:616:9: ( context_item )*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_0 = input.LA(1);

				if ((LA70_0==LIBRARY||LA70_0==USE))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:616:9: context_item
					{
					DebugLocation(616, 9);
					PushFollow(Follow._context_item_in_context_clause6250);
					context_item208=context_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, context_item208.Tree);

					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("context_clause", 56);
			LeaveRule("context_clause", 56);
			LeaveRule_context_clause();
			if (state.backtracking > 0) { Memoize(input, 56, context_clause_StartIndex); }

		}
		DebugLocation(617, 4);
		} finally { DebugExitRule(GrammarFileName, "context_clause"); }
		return retval;

	}
	// $ANTLR end "context_clause"

	partial void EnterRule_context_item();
	partial void LeaveRule_context_item();

	// $ANTLR start "context_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:619:1: context_item : ( library_clause | use_clause );
	[GrammarRule("context_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> context_item()
	{
		EnterRule_context_item();
		EnterRule("context_item", 57);
		TraceIn("context_item", 57);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int context_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> library_clause209 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause210 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "context_item");
		DebugLocation(619, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 57)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:620:5: ( library_clause | use_clause )
			int alt71=2;
			try { DebugEnterDecision(71, false);
			int LA71_0 = input.LA(1);

			if ((LA71_0==LIBRARY))
			{
				alt71 = 1;
			}
			else if ((LA71_0==USE))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:620:9: library_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(620, 9);
				PushFollow(Follow._library_clause_in_context_item6270);
				library_clause209=library_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, library_clause209.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:621:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(621, 9);
				PushFollow(Follow._use_clause_in_context_item6280);
				use_clause210=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause210.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("context_item", 57);
			LeaveRule("context_item", 57);
			LeaveRule_context_item();
			if (state.backtracking > 0) { Memoize(input, 57, context_item_StartIndex); }

		}
		DebugLocation(622, 4);
		} finally { DebugExitRule(GrammarFileName, "context_item"); }
		return retval;

	}
	// $ANTLR end "context_item"

	partial void EnterRule_delay_mechanism();
	partial void LeaveRule_delay_mechanism();

	// $ANTLR start "delay_mechanism"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:624:1: delay_mechanism : ( TRANSPORT -> ^( TRANSPORT ) | ( REJECT expression )? INERTIAL -> ^( INERTIAL ( expression )? ) );
	[GrammarRule("delay_mechanism")]
	private AstParserRuleReturnScope<CommonTree, IToken> delay_mechanism()
	{
		EnterRule_delay_mechanism();
		EnterRule("delay_mechanism", 58);
		TraceIn("delay_mechanism", 58);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int delay_mechanism_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken TRANSPORT211 = default(IToken);
		IToken REJECT212 = default(IToken);
		IToken INERTIAL214 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression213 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree TRANSPORT211_tree = default(CommonTree);
		CommonTree REJECT212_tree = default(CommonTree);
		CommonTree INERTIAL214_tree = default(CommonTree);
		RewriteRuleITokenStream stream_TRANSPORT=new RewriteRuleITokenStream(adaptor,"token TRANSPORT");
		RewriteRuleITokenStream stream_INERTIAL=new RewriteRuleITokenStream(adaptor,"token INERTIAL");
		RewriteRuleITokenStream stream_REJECT=new RewriteRuleITokenStream(adaptor,"token REJECT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "delay_mechanism");
		DebugLocation(624, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 58)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:625:5: ( TRANSPORT -> ^( TRANSPORT ) | ( REJECT expression )? INERTIAL -> ^( INERTIAL ( expression )? ) )
			int alt73=2;
			try { DebugEnterDecision(73, false);
			int LA73_0 = input.LA(1);

			if ((LA73_0==TRANSPORT))
			{
				alt73 = 1;
			}
			else if ((LA73_0==INERTIAL||LA73_0==REJECT))
			{
				alt73 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 73, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:625:9: TRANSPORT
				{
				DebugLocation(625, 9);
				TRANSPORT211=(IToken)Match(input,TRANSPORT,Follow._TRANSPORT_in_delay_mechanism6299); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TRANSPORT.Add(TRANSPORT211);



				{
				// AST REWRITE
				// elements: TRANSPORT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 625:35: -> ^( TRANSPORT )
				{
					DebugLocation(625, 38);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:625:38: ^( TRANSPORT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(625, 40);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_TRANSPORT.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:626:9: ( REJECT expression )? INERTIAL
				{
				DebugLocation(626, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:626:9: ( REJECT expression )?
				int alt72=2;
				try { DebugEnterSubRule(72);
				try { DebugEnterDecision(72, false);
				int LA72_0 = input.LA(1);

				if ((LA72_0==REJECT))
				{
					alt72 = 1;
				}
				} finally { DebugExitDecision(72); }
				switch (alt72)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:626:11: REJECT expression
					{
					DebugLocation(626, 11);
					REJECT212=(IToken)Match(input,REJECT,Follow._REJECT_in_delay_mechanism6350); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_REJECT.Add(REJECT212);

					DebugLocation(626, 18);
					PushFollow(Follow._expression_in_delay_mechanism6352);
					expression213=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression213.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(72); }

				DebugLocation(626, 32);
				INERTIAL214=(IToken)Match(input,INERTIAL,Follow._INERTIAL_in_delay_mechanism6357); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INERTIAL.Add(INERTIAL214);



				{
				// AST REWRITE
				// elements: INERTIAL, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 626:41: -> ^( INERTIAL ( expression )? )
				{
					DebugLocation(626, 44);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:626:44: ^( INERTIAL ( expression )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(626, 47);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_INERTIAL.NextNode(), root_1);

					DebugLocation(626, 56);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:626:56: ( expression )?
					if (stream_expression.HasNext)
					{
						DebugLocation(626, 56);
						adaptor.AddChild(root_1, stream_expression.NextTree());

					}
					stream_expression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("delay_mechanism", 58);
			LeaveRule("delay_mechanism", 58);
			LeaveRule_delay_mechanism();
			if (state.backtracking > 0) { Memoize(input, 58, delay_mechanism_StartIndex); }

		}
		DebugLocation(627, 4);
		} finally { DebugExitRule(GrammarFileName, "delay_mechanism"); }
		return retval;

	}
	// $ANTLR end "delay_mechanism"

	partial void EnterRule_design_file();
	partial void LeaveRule_design_file();

	// $ANTLR start "design_file"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:630:1: public design_file : ( design_unit )* EOF ;
	[GrammarRule("design_file")]
	public AstParserRuleReturnScope<CommonTree, IToken> design_file()
	{
		EnterRule_design_file();
		EnterRule("design_file", 59);
		TraceIn("design_file", 59);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int design_file_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken EOF216 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> design_unit215 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EOF216_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "design_file");
		DebugLocation(630, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 59)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:631:5: ( ( design_unit )* EOF )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:631:9: ( design_unit )* EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(631, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:631:9: ( design_unit )*
			try { DebugEnterSubRule(74);
			while (true)
			{
				int alt74=2;
				try { DebugEnterDecision(74, false);
				int LA74_0 = input.LA(1);

				if ((LA74_0==ARCHITECTURE||LA74_0==CONFIGURATION||LA74_0==ENTITY||LA74_0==LIBRARY||LA74_0==PACKAGE||LA74_0==USE))
				{
					alt74 = 1;
				}


				} finally { DebugExitDecision(74); }
				switch ( alt74 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:631:9: design_unit
					{
					DebugLocation(631, 9);
					PushFollow(Follow._design_unit_in_design_file6393);
					design_unit215=design_unit();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, design_unit215.Tree);

					}
					break;

				default:
					goto loop74;
				}
			}

			loop74:
				;

			} finally { DebugExitSubRule(74); }

			DebugLocation(631, 22);
			EOF216=(IToken)Match(input,EOF,Follow._EOF_in_design_file6396); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EOF216_tree = (CommonTree)adaptor.Create(EOF216);
			adaptor.AddChild(root_0, EOF216_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("design_file", 59);
			LeaveRule("design_file", 59);
			LeaveRule_design_file();
			if (state.backtracking > 0) { Memoize(input, 59, design_file_StartIndex); }

		}
		DebugLocation(632, 4);
		} finally { DebugExitRule(GrammarFileName, "design_file"); }
		return retval;

	}
	// $ANTLR end "design_file"

	partial void EnterRule_design_unit();
	partial void LeaveRule_design_unit();

	// $ANTLR start "design_unit"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:634:1: design_unit : context_clause ( primary_unit | secondary_unit ) ;
	[GrammarRule("design_unit")]
	private AstParserRuleReturnScope<CommonTree, IToken> design_unit()
	{
		EnterRule_design_unit();
		EnterRule("design_unit", 60);
		TraceIn("design_unit", 60);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int design_unit_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> context_clause217 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> primary_unit218 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> secondary_unit219 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "design_unit");
		DebugLocation(634, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 60)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:635:5: ( context_clause ( primary_unit | secondary_unit ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:635:9: context_clause ( primary_unit | secondary_unit )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(635, 9);
			PushFollow(Follow._context_clause_in_design_unit6415);
			context_clause217=context_clause();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, context_clause217.Tree);
			DebugLocation(635, 24);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:635:24: ( primary_unit | secondary_unit )
			int alt75=2;
			try { DebugEnterSubRule(75);
			try { DebugEnterDecision(75, false);
			switch (input.LA(1))
			{
			case CONFIGURATION:
			case ENTITY:
				{
				alt75 = 1;
				}
				break;
			case PACKAGE:
				{
				int LA75_2 = input.LA(2);

				if ((LA75_2==BODY))
				{
					alt75 = 2;
				}
				else if ((LA75_2==BASIC_IDENTIFIER||LA75_2==EXTENDED_IDENTIFIER))
				{
					alt75 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 75, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARCHITECTURE:
				{
				alt75 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 75, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:635:25: primary_unit
				{
				DebugLocation(635, 25);
				PushFollow(Follow._primary_unit_in_design_unit6418);
				primary_unit218=primary_unit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primary_unit218.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:635:38: secondary_unit
				{
				DebugLocation(635, 38);
				PushFollow(Follow._secondary_unit_in_design_unit6420);
				secondary_unit219=secondary_unit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, secondary_unit219.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(75); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("design_unit", 60);
			LeaveRule("design_unit", 60);
			LeaveRule_design_unit();
			if (state.backtracking > 0) { Memoize(input, 60, design_unit_StartIndex); }

		}
		DebugLocation(636, 4);
		} finally { DebugExitRule(GrammarFileName, "design_unit"); }
		return retval;

	}
	// $ANTLR end "design_unit"

	partial void EnterRule_designator();
	partial void LeaveRule_designator();

	// $ANTLR start "designator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:638:1: designator : ( identifier |operator_symbol= STRING_LITERAL );
	[GrammarRule("designator")]
	private AstParserRuleReturnScope<CommonTree, IToken> designator()
	{
		EnterRule_designator();
		EnterRule("designator", 61);
		TraceIn("designator", 61);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int designator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken operator_symbol = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier220 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree operator_symbol_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "designator");
		DebugLocation(638, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 61)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:639:5: ( identifier |operator_symbol= STRING_LITERAL )
			int alt76=2;
			try { DebugEnterDecision(76, false);
			int LA76_0 = input.LA(1);

			if ((LA76_0==BASIC_IDENTIFIER||LA76_0==EXTENDED_IDENTIFIER))
			{
				alt76 = 1;
			}
			else if ((LA76_0==STRING_LITERAL))
			{
				alt76 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 76, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:639:9: identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(639, 9);
				PushFollow(Follow._identifier_in_designator6440);
				identifier220=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier220.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:640:9: operator_symbol= STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(640, 24);
				operator_symbol=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_designator6452); if (state.failed) return retval;
				if (state.backtracking == 0) {
				operator_symbol_tree = (CommonTree)adaptor.Create(operator_symbol);
				adaptor.AddChild(root_0, operator_symbol_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("designator", 61);
			LeaveRule("designator", 61);
			LeaveRule_designator();
			if (state.backtracking > 0) { Memoize(input, 61, designator_StartIndex); }

		}
		DebugLocation(641, 4);
		} finally { DebugExitRule(GrammarFileName, "designator"); }
		return retval;

	}
	// $ANTLR end "designator"

	partial void EnterRule_direction();
	partial void LeaveRule_direction();

	// $ANTLR start "direction"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:643:1: direction : ( TO | DOWNTO );
	[GrammarRule("direction")]
	private AstParserRuleReturnScope<CommonTree, IToken> direction()
	{
		EnterRule_direction();
		EnterRule("direction", 62);
		TraceIn("direction", 62);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int direction_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set221 = default(IToken);

		CommonTree set221_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "direction");
		DebugLocation(643, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 62)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:644:5: ( TO | DOWNTO )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(644, 5);

			set221=(IToken)input.LT(1);
			if (input.LA(1)==DOWNTO||input.LA(1)==TO)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set221));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("direction", 62);
			LeaveRule("direction", 62);
			LeaveRule_direction();
			if (state.backtracking > 0) { Memoize(input, 62, direction_StartIndex); }

		}
		DebugLocation(646, 4);
		} finally { DebugExitRule(GrammarFileName, "direction"); }
		return retval;

	}
	// $ANTLR end "direction"

	partial void EnterRule_disconnection_specification();
	partial void LeaveRule_disconnection_specification();

	// $ANTLR start "disconnection_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:648:1: disconnection_specification : DISCONNECT guarded_signal_specification AFTER time_expression= expression SEMI -> ^( DISCONNECT guarded_signal_specification $time_expression) ;
	[GrammarRule("disconnection_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> disconnection_specification()
	{
		EnterRule_disconnection_specification();
		EnterRule("disconnection_specification", 63);
		TraceIn("disconnection_specification", 63);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int disconnection_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken DISCONNECT222 = default(IToken);
		IToken AFTER224 = default(IToken);
		IToken SEMI225 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> time_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> guarded_signal_specification223 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DISCONNECT222_tree = default(CommonTree);
		CommonTree AFTER224_tree = default(CommonTree);
		CommonTree SEMI225_tree = default(CommonTree);
		RewriteRuleITokenStream stream_AFTER=new RewriteRuleITokenStream(adaptor,"token AFTER");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_DISCONNECT=new RewriteRuleITokenStream(adaptor,"token DISCONNECT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_guarded_signal_specification=new RewriteRuleSubtreeStream(adaptor,"rule guarded_signal_specification");
		try { DebugEnterRule(GrammarFileName, "disconnection_specification");
		DebugLocation(648, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 63)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:649:5: ( DISCONNECT guarded_signal_specification AFTER time_expression= expression SEMI -> ^( DISCONNECT guarded_signal_specification $time_expression) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:649:9: DISCONNECT guarded_signal_specification AFTER time_expression= expression SEMI
			{
			DebugLocation(649, 9);
			DISCONNECT222=(IToken)Match(input,DISCONNECT,Follow._DISCONNECT_in_disconnection_specification6500); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DISCONNECT.Add(DISCONNECT222);

			DebugLocation(649, 20);
			PushFollow(Follow._guarded_signal_specification_in_disconnection_specification6502);
			guarded_signal_specification223=guarded_signal_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_guarded_signal_specification.Add(guarded_signal_specification223.Tree);
			DebugLocation(649, 49);
			AFTER224=(IToken)Match(input,AFTER,Follow._AFTER_in_disconnection_specification6504); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_AFTER.Add(AFTER224);

			DebugLocation(649, 70);
			PushFollow(Follow._expression_in_disconnection_specification6508);
			time_expression=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(time_expression.Tree);
			DebugLocation(649, 82);
			SEMI225=(IToken)Match(input,SEMI,Follow._SEMI_in_disconnection_specification6510); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI225);



			{
			// AST REWRITE
			// elements: time_expression, guarded_signal_specification, DISCONNECT
			// token labels: 
			// rule labels: retval, time_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_time_expression=new RewriteRuleSubtreeStream(adaptor,"rule time_expression",time_expression!=null?time_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 650:9: -> ^( DISCONNECT guarded_signal_specification $time_expression)
			{
				DebugLocation(650, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:650:12: ^( DISCONNECT guarded_signal_specification $time_expression)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(650, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_DISCONNECT.NextNode(), root_1);

				DebugLocation(650, 26);
				adaptor.AddChild(root_1, stream_guarded_signal_specification.NextTree());
				DebugLocation(650, 56);
				adaptor.AddChild(root_1, stream_time_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("disconnection_specification", 63);
			LeaveRule("disconnection_specification", 63);
			LeaveRule_disconnection_specification();
			if (state.backtracking > 0) { Memoize(input, 63, disconnection_specification_StartIndex); }

		}
		DebugLocation(651, 4);
		} finally { DebugExitRule(GrammarFileName, "disconnection_specification"); }
		return retval;

	}
	// $ANTLR end "disconnection_specification"

	partial void EnterRule_discrete_range();
	partial void LeaveRule_discrete_range();

	// $ANTLR start "discrete_range"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:658:1: discrete_range : ( ( simple_expression direction )=> simple_expression direction simple_expression -> ^( direction simple_expression simple_expression ) |type_mark= name_without_parens ( constraint )? -> ^( DISCRETE_RANGE $type_mark ( constraint )? ) );
	[GrammarRule("discrete_range")]
	private AstParserRuleReturnScope<CommonTree, IToken> discrete_range()
	{
		EnterRule_discrete_range();
		EnterRule("discrete_range", 64);
		TraceIn("discrete_range", 64);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int discrete_range_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression226 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> direction227 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression228 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constraint229 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_simple_expression=new RewriteRuleSubtreeStream(adaptor,"rule simple_expression");
		RewriteRuleSubtreeStream stream_direction=new RewriteRuleSubtreeStream(adaptor,"rule direction");
		RewriteRuleSubtreeStream stream_constraint=new RewriteRuleSubtreeStream(adaptor,"rule constraint");
		try { DebugEnterRule(GrammarFileName, "discrete_range");
		DebugLocation(658, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 64)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:659:5: ( ( simple_expression direction )=> simple_expression direction simple_expression -> ^( direction simple_expression simple_expression ) |type_mark= name_without_parens ( constraint )? -> ^( DISCRETE_RANGE $type_mark ( constraint )? ) )
			int alt78=2;
			try { DebugEnterDecision(78, false);
			int LA78_0 = input.LA(1);

			if ((LA78_0==MINUS||LA78_0==PLUS) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==BINANRY_BASED_INTEGER||LA78_0==DEC_BASED_INTEGER||LA78_0==HEXA_BASED_INTEGER||LA78_0==OCTAL_BASED_INTEGER) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==FLOAT_POINT_LITERAL) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==CHARACTER_LITERAL) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==BIT_STRING_LITERAL_BINARY) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==BIT_STRING_LITERAL_OCTAL) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==BIT_STRING_LITERAL_HEX) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==NULLTOK) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==LPAREN) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==NEW) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==BASIC_IDENTIFIER||LA78_0==EXTENDED_IDENTIFIER))
			{
				int LA78_11 = input.LA(2);

				if ((EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
				{
					alt78 = 1;
				}
				else if ((true))
				{
					alt78 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 78, 11, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA78_0==STRING_LITERAL))
			{
				int LA78_12 = input.LA(2);

				if ((EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
				{
					alt78 = 1;
				}
				else if ((true))
				{
					alt78 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 78, 12, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA78_0==ABS) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else if ((LA78_0==NOT) && (EvaluatePredicate(synpred6_VhdlAntlr_fragment)))
			{
				alt78 = 1;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 78, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:659:9: ( simple_expression direction )=> simple_expression direction simple_expression
				{
				DebugLocation(659, 41);
				PushFollow(Follow._simple_expression_in_discrete_range6562);
				simple_expression226=simple_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_expression.Add(simple_expression226.Tree);
				DebugLocation(659, 59);
				PushFollow(Follow._direction_in_discrete_range6564);
				direction227=direction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_direction.Add(direction227.Tree);
				DebugLocation(659, 69);
				PushFollow(Follow._simple_expression_in_discrete_range6566);
				simple_expression228=simple_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simple_expression.Add(simple_expression228.Tree);


				{
				// AST REWRITE
				// elements: simple_expression, simple_expression, direction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 660:9: -> ^( direction simple_expression simple_expression )
				{
					DebugLocation(660, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:660:12: ^( direction simple_expression simple_expression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(660, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_direction.NextNode(), root_1);

					DebugLocation(660, 25);
					adaptor.AddChild(root_1, stream_simple_expression.NextTree());
					DebugLocation(660, 43);
					adaptor.AddChild(root_1, stream_simple_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:661:9: type_mark= name_without_parens ( constraint )?
				{
				DebugLocation(661, 18);
				PushFollow(Follow._name_without_parens_in_discrete_range6598);
				type_mark=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(type_mark.Tree);
				DebugLocation(661, 39);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:661:39: ( constraint )?
				int alt77=2;
				try { DebugEnterSubRule(77);
				try { DebugEnterDecision(77, false);
				int LA77_0 = input.LA(1);

				if ((LA77_0==LPAREN||LA77_0==RANGETOK))
				{
					alt77 = 1;
				}
				} finally { DebugExitDecision(77); }
				switch (alt77)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:661:39: constraint
					{
					DebugLocation(661, 39);
					PushFollow(Follow._constraint_in_discrete_range6600);
					constraint229=constraint();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_constraint.Add(constraint229.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(77); }



				{
				// AST REWRITE
				// elements: type_mark, constraint
				// token labels: 
				// rule labels: retval, type_mark
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_type_mark=new RewriteRuleSubtreeStream(adaptor,"rule type_mark",type_mark!=null?type_mark.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 662:9: -> ^( DISCRETE_RANGE $type_mark ( constraint )? )
				{
					DebugLocation(662, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:662:12: ^( DISCRETE_RANGE $type_mark ( constraint )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(662, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DISCRETE_RANGE, "DISCRETE_RANGE"), root_1);

					DebugLocation(662, 31);
					adaptor.AddChild(root_1, stream_type_mark.NextTree());
					DebugLocation(662, 41);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:662:41: ( constraint )?
					if (stream_constraint.HasNext)
					{
						DebugLocation(662, 41);
						adaptor.AddChild(root_1, stream_constraint.NextTree());

					}
					stream_constraint.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("discrete_range", 64);
			LeaveRule("discrete_range", 64);
			LeaveRule_discrete_range();
			if (state.backtracking > 0) { Memoize(input, 64, discrete_range_StartIndex); }

		}
		DebugLocation(663, 4);
		} finally { DebugExitRule(GrammarFileName, "discrete_range"); }
		return retval;

	}
	// $ANTLR end "discrete_range"

	partial void EnterRule_element_association();
	partial void LeaveRule_element_association();

	// $ANTLR start "element_association"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:665:1: element_association : ( ( choices ARROW )=> choices ARROW )? expression -> ( choices )? expression ;
	[GrammarRule("element_association")]
	private AstParserRuleReturnScope<CommonTree, IToken> element_association()
	{
		EnterRule_element_association();
		EnterRule("element_association", 65);
		TraceIn("element_association", 65);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int element_association_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ARROW231 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> choices230 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression232 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ARROW231_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ARROW=new RewriteRuleITokenStream(adaptor,"token ARROW");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_choices=new RewriteRuleSubtreeStream(adaptor,"rule choices");
		try { DebugEnterRule(GrammarFileName, "element_association");
		DebugLocation(665, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 65)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:5: ( ( ( choices ARROW )=> choices ARROW )? expression -> ( choices )? expression )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:9: ( ( choices ARROW )=> choices ARROW )? expression
			{
			DebugLocation(666, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:9: ( ( choices ARROW )=> choices ARROW )?
			int alt79=2;
			try { DebugEnterSubRule(79);
			try { DebugEnterDecision(79, false);
			int LA79_0 = input.LA(1);

			if ((LA79_0==MINUS||LA79_0==PLUS))
			{
				int LA79_1 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==BINANRY_BASED_INTEGER||LA79_0==DEC_BASED_INTEGER||LA79_0==HEXA_BASED_INTEGER||LA79_0==OCTAL_BASED_INTEGER))
			{
				int LA79_2 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==FLOAT_POINT_LITERAL))
			{
				int LA79_3 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==CHARACTER_LITERAL))
			{
				int LA79_4 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==BIT_STRING_LITERAL_BINARY))
			{
				int LA79_5 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==BIT_STRING_LITERAL_OCTAL))
			{
				int LA79_6 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==BIT_STRING_LITERAL_HEX))
			{
				int LA79_7 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==NULLTOK))
			{
				int LA79_8 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==LPAREN))
			{
				int LA79_9 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==NEW))
			{
				int LA79_10 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==BASIC_IDENTIFIER||LA79_0==EXTENDED_IDENTIFIER))
			{
				int LA79_11 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==STRING_LITERAL))
			{
				int LA79_12 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==ABS))
			{
				int LA79_13 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==NOT))
			{
				int LA79_14 = input.LA(2);

				if ((EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
				{
					alt79 = 1;
				}
			}
			else if ((LA79_0==OTHERS) && (EvaluatePredicate(synpred7_VhdlAntlr_fragment)))
			{
				alt79 = 1;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:11: ( choices ARROW )=> choices ARROW
				{
				DebugLocation(666, 29);
				PushFollow(Follow._choices_in_element_association6651);
				choices230=choices();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_choices.Add(choices230.Tree);
				DebugLocation(666, 37);
				ARROW231=(IToken)Match(input,ARROW,Follow._ARROW_in_element_association6653); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARROW.Add(ARROW231);


				}
				break;

			}
			} finally { DebugExitSubRule(79); }

			DebugLocation(666, 46);
			PushFollow(Follow._expression_in_element_association6658);
			expression232=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression232.Tree);


			{
			// AST REWRITE
			// elements: expression, choices
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 667:9: -> ( choices )? expression
			{
				DebugLocation(667, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:667:12: ( choices )?
				if (stream_choices.HasNext)
				{
					DebugLocation(667, 12);
					adaptor.AddChild(root_0, stream_choices.NextTree());

				}
				stream_choices.Reset();
				DebugLocation(667, 21);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element_association", 65);
			LeaveRule("element_association", 65);
			LeaveRule_element_association();
			if (state.backtracking > 0) { Memoize(input, 65, element_association_StartIndex); }

		}
		DebugLocation(668, 4);
		} finally { DebugExitRule(GrammarFileName, "element_association"); }
		return retval;

	}
	// $ANTLR end "element_association"

	partial void EnterRule_element_declaration();
	partial void LeaveRule_element_declaration();

	// $ANTLR start "element_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:670:1: element_declaration : identifier_list COLON element_subtype_indication= subtype_indication SEMI -> identifier_list $element_subtype_indication;
	[GrammarRule("element_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> element_declaration()
	{
		EnterRule_element_declaration();
		EnterRule("element_declaration", 66);
		TraceIn("element_declaration", 66);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int element_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON234 = default(IToken);
		IToken SEMI235 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> element_subtype_indication = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list233 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON234_tree = default(CommonTree);
		CommonTree SEMI235_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "element_declaration");
		DebugLocation(670, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 66)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:671:5: ( identifier_list COLON element_subtype_indication= subtype_indication SEMI -> identifier_list $element_subtype_indication)
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:671:9: identifier_list COLON element_subtype_indication= subtype_indication SEMI
			{
			DebugLocation(671, 9);
			PushFollow(Follow._identifier_list_in_element_declaration6692);
			identifier_list233=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list233.Tree);
			DebugLocation(671, 25);
			COLON234=(IToken)Match(input,COLON,Follow._COLON_in_element_declaration6694); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON234);

			DebugLocation(671, 57);
			PushFollow(Follow._subtype_indication_in_element_declaration6698);
			element_subtype_indication=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(element_subtype_indication.Tree);
			DebugLocation(671, 77);
			SEMI235=(IToken)Match(input,SEMI,Follow._SEMI_in_element_declaration6700); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI235);



			{
			// AST REWRITE
			// elements: element_subtype_indication, identifier_list
			// token labels: 
			// rule labels: retval, element_subtype_indication
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_element_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule element_subtype_indication",element_subtype_indication!=null?element_subtype_indication.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 672:9: -> identifier_list $element_subtype_indication
			{
				DebugLocation(672, 12);
				adaptor.AddChild(root_0, stream_identifier_list.NextTree());
				DebugLocation(672, 29);
				adaptor.AddChild(root_0, stream_element_subtype_indication.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element_declaration", 66);
			LeaveRule("element_declaration", 66);
			LeaveRule_element_declaration();
			if (state.backtracking > 0) { Memoize(input, 66, element_declaration_StartIndex); }

		}
		DebugLocation(673, 4);
		} finally { DebugExitRule(GrammarFileName, "element_declaration"); }
		return retval;

	}
	// $ANTLR end "element_declaration"

	partial void EnterRule_entity_aspect();
	partial void LeaveRule_entity_aspect();

	// $ANTLR start "entity_aspect"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:675:1: entity_aspect : ( ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )? -> ^( ENTITY $entity ( $architecture)? ) | CONFIGURATION configuration= name -> ^( CONFIGURATION $configuration) | OPEN );
	[GrammarRule("entity_aspect")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_aspect()
	{
		EnterRule_entity_aspect();
		EnterRule("entity_aspect", 67);
		TraceIn("entity_aspect", 67);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_aspect_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ENTITY236 = default(IToken);
		IToken LPAREN237 = default(IToken);
		IToken RPAREN238 = default(IToken);
		IToken CONFIGURATION239 = default(IToken);
		IToken OPEN240 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> architecture = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> configuration = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ENTITY236_tree = default(CommonTree);
		CommonTree LPAREN237_tree = default(CommonTree);
		CommonTree RPAREN238_tree = default(CommonTree);
		CommonTree CONFIGURATION239_tree = default(CommonTree);
		CommonTree OPEN240_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_CONFIGURATION=new RewriteRuleITokenStream(adaptor,"token CONFIGURATION");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_ENTITY=new RewriteRuleITokenStream(adaptor,"token ENTITY");
		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "entity_aspect");
		DebugLocation(675, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 67)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:676:5: ( ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )? -> ^( ENTITY $entity ( $architecture)? ) | CONFIGURATION configuration= name -> ^( CONFIGURATION $configuration) | OPEN )
			int alt81=3;
			try { DebugEnterDecision(81, false);
			switch (input.LA(1))
			{
			case ENTITY:
				{
				alt81 = 1;
				}
				break;
			case CONFIGURATION:
				{
				alt81 = 2;
				}
				break;
			case OPEN:
				{
				alt81 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 81, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:676:9: ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )?
				{
				DebugLocation(676, 9);
				ENTITY236=(IToken)Match(input,ENTITY,Follow._ENTITY_in_entity_aspect6734); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENTITY.Add(ENTITY236);

				DebugLocation(676, 22);
				PushFollow(Follow._name_without_parens_in_entity_aspect6738);
				entity=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(entity.Tree);
				DebugLocation(676, 43);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:676:43: ( LPAREN architecture= identifier RPAREN )?
				int alt80=2;
				try { DebugEnterSubRule(80);
				try { DebugEnterDecision(80, false);
				int LA80_0 = input.LA(1);

				if ((LA80_0==LPAREN))
				{
					alt80 = 1;
				}
				} finally { DebugExitDecision(80); }
				switch (alt80)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:676:45: LPAREN architecture= identifier RPAREN
					{
					DebugLocation(676, 45);
					LPAREN237=(IToken)Match(input,LPAREN,Follow._LPAREN_in_entity_aspect6742); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LPAREN.Add(LPAREN237);

					DebugLocation(676, 64);
					PushFollow(Follow._identifier_in_entity_aspect6746);
					architecture=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(architecture.Tree);
					DebugLocation(676, 76);
					RPAREN238=(IToken)Match(input,RPAREN,Follow._RPAREN_in_entity_aspect6748); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RPAREN.Add(RPAREN238);


					}
					break;

				}
				} finally { DebugExitSubRule(80); }



				{
				// AST REWRITE
				// elements: architecture, entity, ENTITY
				// token labels: 
				// rule labels: retval, entity, architecture
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_entity=new RewriteRuleSubtreeStream(adaptor,"rule entity",entity!=null?entity.Tree:null);
				RewriteRuleSubtreeStream stream_architecture=new RewriteRuleSubtreeStream(adaptor,"rule architecture",architecture!=null?architecture.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 677:9: -> ^( ENTITY $entity ( $architecture)? )
				{
					DebugLocation(677, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:677:12: ^( ENTITY $entity ( $architecture)? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(677, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_ENTITY.NextNode(), root_1);

					DebugLocation(677, 23);
					adaptor.AddChild(root_1, stream_entity.NextTree());
					DebugLocation(677, 31);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:677:31: ( $architecture)?
					if (stream_architecture.HasNext)
					{
						DebugLocation(677, 31);
						adaptor.AddChild(root_1, stream_architecture.NextTree());

					}
					stream_architecture.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:678:9: CONFIGURATION configuration= name
				{
				DebugLocation(678, 9);
				CONFIGURATION239=(IToken)Match(input,CONFIGURATION,Follow._CONFIGURATION_in_entity_aspect6784); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONFIGURATION.Add(CONFIGURATION239);

				DebugLocation(678, 36);
				PushFollow(Follow._name_in_entity_aspect6788);
				configuration=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(configuration.Tree);


				{
				// AST REWRITE
				// elements: configuration, CONFIGURATION
				// token labels: 
				// rule labels: retval, configuration
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_configuration=new RewriteRuleSubtreeStream(adaptor,"rule configuration",configuration!=null?configuration.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 679:9: -> ^( CONFIGURATION $configuration)
				{
					DebugLocation(679, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:679:12: ^( CONFIGURATION $configuration)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(679, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_CONFIGURATION.NextNode(), root_1);

					DebugLocation(679, 30);
					adaptor.AddChild(root_1, stream_configuration.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:680:9: OPEN
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(680, 9);
				OPEN240=(IToken)Match(input,OPEN,Follow._OPEN_in_entity_aspect6817); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OPEN240_tree = (CommonTree)adaptor.Create(OPEN240);
				adaptor.AddChild(root_0, OPEN240_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_aspect", 67);
			LeaveRule("entity_aspect", 67);
			LeaveRule_entity_aspect();
			if (state.backtracking > 0) { Memoize(input, 67, entity_aspect_StartIndex); }

		}
		DebugLocation(681, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_aspect"); }
		return retval;

	}
	// $ANTLR end "entity_aspect"

	partial void EnterRule_entity_class();
	partial void LeaveRule_entity_class();

	// $ANTLR start "entity_class"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:683:1: entity_class : ( ENTITY | ARCHITECTURE | CONFIGURATION | PROCEDURE | FUNCTION | PACKAGE | TYPE | SUBTYPE | CONSTANT | SIGNAL | VARIABLE | COMPONENT | LABEL | LITERAL | UNITS | GROUP | FILE );
	[GrammarRule("entity_class")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_class()
	{
		EnterRule_entity_class();
		EnterRule("entity_class", 68);
		TraceIn("entity_class", 68);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_class_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set241 = default(IToken);

		CommonTree set241_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "entity_class");
		DebugLocation(683, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 68)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:684:5: ( ENTITY | ARCHITECTURE | CONFIGURATION | PROCEDURE | FUNCTION | PACKAGE | TYPE | SUBTYPE | CONSTANT | SIGNAL | VARIABLE | COMPONENT | LABEL | LITERAL | UNITS | GROUP | FILE )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(684, 5);

			set241=(IToken)input.LT(1);
			if (input.LA(1)==ARCHITECTURE||input.LA(1)==COMPONENT||input.LA(1)==CONFIGURATION||input.LA(1)==CONSTANT||input.LA(1)==ENTITY||input.LA(1)==FILE||input.LA(1)==FUNCTION||input.LA(1)==GROUP||input.LA(1)==LABEL||input.LA(1)==LITERAL||input.LA(1)==PACKAGE||input.LA(1)==PROCEDURE||input.LA(1)==SIGNAL||input.LA(1)==SUBTYPE||input.LA(1)==TYPE||input.LA(1)==UNITS||input.LA(1)==VARIABLE)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set241));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_class", 68);
			LeaveRule("entity_class", 68);
			LeaveRule_entity_class();
			if (state.backtracking > 0) { Memoize(input, 68, entity_class_StartIndex); }

		}
		DebugLocation(701, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_class"); }
		return retval;

	}
	// $ANTLR end "entity_class"

	partial void EnterRule_entity_class_entry();
	partial void LeaveRule_entity_class_entry();

	// $ANTLR start "entity_class_entry"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:703:1: entity_class_entry : entity_class ( BOX )? ;
	[GrammarRule("entity_class_entry")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_class_entry()
	{
		EnterRule_entity_class_entry();
		EnterRule("entity_class_entry", 69);
		TraceIn("entity_class_entry", 69);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_class_entry_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken BOX243 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity_class242 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BOX243_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "entity_class_entry");
		DebugLocation(703, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 69)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:704:5: ( entity_class ( BOX )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:704:9: entity_class ( BOX )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(704, 9);
			PushFollow(Follow._entity_class_in_entity_class_entry7015);
			entity_class242=entity_class();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, entity_class242.Tree);
			DebugLocation(704, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:704:22: ( BOX )?
			int alt82=2;
			try { DebugEnterSubRule(82);
			try { DebugEnterDecision(82, false);
			int LA82_0 = input.LA(1);

			if ((LA82_0==BOX))
			{
				alt82 = 1;
			}
			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:704:22: BOX
				{
				DebugLocation(704, 22);
				BOX243=(IToken)Match(input,BOX,Follow._BOX_in_entity_class_entry7017); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BOX243_tree = (CommonTree)adaptor.Create(BOX243);
				adaptor.AddChild(root_0, BOX243_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(82); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_class_entry", 69);
			LeaveRule("entity_class_entry", 69);
			LeaveRule_entity_class_entry();
			if (state.backtracking > 0) { Memoize(input, 69, entity_class_entry_StartIndex); }

		}
		DebugLocation(705, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_class_entry"); }
		return retval;

	}
	// $ANTLR end "entity_class_entry"

	partial void EnterRule_entity_class_entry_list();
	partial void LeaveRule_entity_class_entry_list();

	// $ANTLR start "entity_class_entry_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:707:1: entity_class_entry_list : entity_class_entry ( COMMA entity_class_entry )* -> ( entity_class_entry )+ ;
	[GrammarRule("entity_class_entry_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_class_entry_list()
	{
		EnterRule_entity_class_entry_list();
		EnterRule("entity_class_entry_list", 70);
		TraceIn("entity_class_entry_list", 70);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_class_entry_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA245 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity_class_entry244 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_class_entry246 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA245_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_entity_class_entry=new RewriteRuleSubtreeStream(adaptor,"rule entity_class_entry");
		try { DebugEnterRule(GrammarFileName, "entity_class_entry_list");
		DebugLocation(707, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 70)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:708:5: ( entity_class_entry ( COMMA entity_class_entry )* -> ( entity_class_entry )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:708:9: entity_class_entry ( COMMA entity_class_entry )*
			{
			DebugLocation(708, 9);
			PushFollow(Follow._entity_class_entry_in_entity_class_entry_list7037);
			entity_class_entry244=entity_class_entry();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_class_entry.Add(entity_class_entry244.Tree);
			DebugLocation(708, 28);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:708:28: ( COMMA entity_class_entry )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_0 = input.LA(1);

				if ((LA83_0==COMMA))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:708:30: COMMA entity_class_entry
					{
					DebugLocation(708, 30);
					COMMA245=(IToken)Match(input,COMMA,Follow._COMMA_in_entity_class_entry_list7041); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA245);

					DebugLocation(708, 36);
					PushFollow(Follow._entity_class_entry_in_entity_class_entry_list7043);
					entity_class_entry246=entity_class_entry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_entity_class_entry.Add(entity_class_entry246.Tree);

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }



			{
			// AST REWRITE
			// elements: entity_class_entry
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 709:9: -> ( entity_class_entry )+
			{
				DebugLocation(709, 12);
				if (!(stream_entity_class_entry.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_entity_class_entry.HasNext )
				{
					DebugLocation(709, 12);
					adaptor.AddChild(root_0, stream_entity_class_entry.NextTree());

				}
				stream_entity_class_entry.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_class_entry_list", 70);
			LeaveRule("entity_class_entry_list", 70);
			LeaveRule_entity_class_entry_list();
			if (state.backtracking > 0) { Memoize(input, 70, entity_class_entry_list_StartIndex); }

		}
		DebugLocation(710, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_class_entry_list"); }
		return retval;

	}
	// $ANTLR end "entity_class_entry_list"

	partial void EnterRule_entity_declaration();
	partial void LeaveRule_entity_declaration();

	// $ANTLR start "entity_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:713:1: entity_declaration : ENTITY identifier IS entity_header ( entity_declarative_part )? ( BEGIN ( entity_statement_part )? )? END ( ENTITY )? ( end_identifier )? SEMI -> ^( ENTITY identifier ( entity_header )? ( entity_declarative_part )? ( entity_statement_part )? ( end_identifier )? ) ;
	[GrammarRule("entity_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_declaration()
	{
		EnterRule_entity_declaration();
		EnterRule("entity_declaration", 71);
		TraceIn("entity_declaration", 71);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ENTITY247 = default(IToken);
		IToken IS249 = default(IToken);
		IToken BEGIN252 = default(IToken);
		IToken END254 = default(IToken);
		IToken ENTITY255 = default(IToken);
		IToken SEMI257 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier248 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_header250 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_declarative_part251 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_statement_part253 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier256 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ENTITY247_tree = default(CommonTree);
		CommonTree IS249_tree = default(CommonTree);
		CommonTree BEGIN252_tree = default(CommonTree);
		CommonTree END254_tree = default(CommonTree);
		CommonTree ENTITY255_tree = default(CommonTree);
		CommonTree SEMI257_tree = default(CommonTree);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleITokenStream stream_ENTITY=new RewriteRuleITokenStream(adaptor,"token ENTITY");
		RewriteRuleSubtreeStream stream_entity_statement_part=new RewriteRuleSubtreeStream(adaptor,"rule entity_statement_part");
		RewriteRuleSubtreeStream stream_entity_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule entity_declarative_part");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_entity_header=new RewriteRuleSubtreeStream(adaptor,"rule entity_header");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "entity_declaration");
		DebugLocation(713, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 71)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:714:5: ( ENTITY identifier IS entity_header ( entity_declarative_part )? ( BEGIN ( entity_statement_part )? )? END ( ENTITY )? ( end_identifier )? SEMI -> ^( ENTITY identifier ( entity_header )? ( entity_declarative_part )? ( entity_statement_part )? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:714:9: ENTITY identifier IS entity_header ( entity_declarative_part )? ( BEGIN ( entity_statement_part )? )? END ( ENTITY )? ( end_identifier )? SEMI
			{
			DebugLocation(714, 9);
			ENTITY247=(IToken)Match(input,ENTITY,Follow._ENTITY_in_entity_declaration7079); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ENTITY.Add(ENTITY247);

			DebugLocation(714, 16);
			PushFollow(Follow._identifier_in_entity_declaration7081);
			identifier248=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier248.Tree);
			DebugLocation(714, 27);
			IS249=(IToken)Match(input,IS,Follow._IS_in_entity_declaration7083); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS249);

			DebugLocation(715, 9);
			PushFollow(Follow._entity_header_in_entity_declaration7093);
			entity_header250=entity_header();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_header.Add(entity_header250.Tree);
			DebugLocation(716, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:716:9: ( entity_declarative_part )?
			int alt84=2;
			try { DebugEnterSubRule(84);
			try { DebugEnterDecision(84, false);
			int LA84_0 = input.LA(1);

			if ((LA84_0==ALIAS||LA84_0==ATTRIBUTE||LA84_0==CONSTANT||LA84_0==DISCONNECT||LA84_0==FILE||LA84_0==FUNCTION||LA84_0==GROUP||LA84_0==IMPURE||LA84_0==PROCEDURE||LA84_0==PURE||(LA84_0>=SHARED && LA84_0<=SIGNAL)||LA84_0==SUBTYPE||LA84_0==TYPE||LA84_0==USE||LA84_0==VARIABLE))
			{
				alt84 = 1;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:716:9: entity_declarative_part
				{
				DebugLocation(716, 9);
				PushFollow(Follow._entity_declarative_part_in_entity_declaration7103);
				entity_declarative_part251=entity_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_entity_declarative_part.Add(entity_declarative_part251.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(84); }

			DebugLocation(717, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:717:9: ( BEGIN ( entity_statement_part )? )?
			int alt86=2;
			try { DebugEnterSubRule(86);
			try { DebugEnterDecision(86, false);
			int LA86_0 = input.LA(1);

			if ((LA86_0==BEGIN))
			{
				alt86 = 1;
			}
			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:717:11: BEGIN ( entity_statement_part )?
				{
				DebugLocation(717, 11);
				BEGIN252=(IToken)Match(input,BEGIN,Follow._BEGIN_in_entity_declaration7116); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BEGIN.Add(BEGIN252);

				DebugLocation(717, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:717:17: ( entity_statement_part )?
				int alt85=2;
				try { DebugEnterSubRule(85);
				try { DebugEnterDecision(85, false);
				int LA85_0 = input.LA(1);

				if ((LA85_0==ASSERT||LA85_0==BASIC_IDENTIFIER||LA85_0==EXTENDED_IDENTIFIER||LA85_0==POSTPONED||LA85_0==PROCESS||LA85_0==STRING_LITERAL))
				{
					alt85 = 1;
				}
				} finally { DebugExitDecision(85); }
				switch (alt85)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:717:17: entity_statement_part
					{
					DebugLocation(717, 17);
					PushFollow(Follow._entity_statement_part_in_entity_declaration7118);
					entity_statement_part253=entity_statement_part();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_entity_statement_part.Add(entity_statement_part253.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(85); }


				}
				break;

			}
			} finally { DebugExitSubRule(86); }

			DebugLocation(718, 9);
			END254=(IToken)Match(input,END,Follow._END_in_entity_declaration7132); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END254);

			DebugLocation(718, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:718:13: ( ENTITY )?
			int alt87=2;
			try { DebugEnterSubRule(87);
			try { DebugEnterDecision(87, false);
			int LA87_0 = input.LA(1);

			if ((LA87_0==ENTITY))
			{
				alt87 = 1;
			}
			} finally { DebugExitDecision(87); }
			switch (alt87)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:718:13: ENTITY
				{
				DebugLocation(718, 13);
				ENTITY255=(IToken)Match(input,ENTITY,Follow._ENTITY_in_entity_declaration7134); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENTITY.Add(ENTITY255);


				}
				break;

			}
			} finally { DebugExitSubRule(87); }

			DebugLocation(718, 21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:718:21: ( end_identifier )?
			int alt88=2;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			int LA88_0 = input.LA(1);

			if ((LA88_0==BASIC_IDENTIFIER||LA88_0==EXTENDED_IDENTIFIER))
			{
				alt88 = 1;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:718:21: end_identifier
				{
				DebugLocation(718, 21);
				PushFollow(Follow._end_identifier_in_entity_declaration7137);
				end_identifier256=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier256.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(88); }

			DebugLocation(718, 37);
			SEMI257=(IToken)Match(input,SEMI,Follow._SEMI_in_entity_declaration7140); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI257);



			{
			// AST REWRITE
			// elements: entity_header, ENTITY, entity_declarative_part, end_identifier, identifier, entity_statement_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 719:9: -> ^( ENTITY identifier ( entity_header )? ( entity_declarative_part )? ( entity_statement_part )? ( end_identifier )? )
			{
				DebugLocation(719, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:719:12: ^( ENTITY identifier ( entity_header )? ( entity_declarative_part )? ( entity_statement_part )? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(719, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ENTITY.NextNode(), root_1);

				DebugLocation(719, 22);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(719, 33);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:719:33: ( entity_header )?
				if (stream_entity_header.HasNext)
				{
					DebugLocation(719, 33);
					adaptor.AddChild(root_1, stream_entity_header.NextTree());

				}
				stream_entity_header.Reset();
				DebugLocation(719, 48);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:719:48: ( entity_declarative_part )?
				if (stream_entity_declarative_part.HasNext)
				{
					DebugLocation(719, 48);
					adaptor.AddChild(root_1, stream_entity_declarative_part.NextTree());

				}
				stream_entity_declarative_part.Reset();
				DebugLocation(719, 73);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:719:73: ( entity_statement_part )?
				if (stream_entity_statement_part.HasNext)
				{
					DebugLocation(719, 73);
					adaptor.AddChild(root_1, stream_entity_statement_part.NextTree());

				}
				stream_entity_statement_part.Reset();
				DebugLocation(719, 96);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:719:96: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(719, 96);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_declaration", 71);
			LeaveRule("entity_declaration", 71);
			LeaveRule_entity_declaration();
			if (state.backtracking > 0) { Memoize(input, 71, entity_declaration_StartIndex); }

		}
		DebugLocation(720, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_declaration"); }
		return retval;

	}
	// $ANTLR end "entity_declaration"

	partial void EnterRule_entity_declarative_item();
	partial void LeaveRule_entity_declarative_item();

	// $ANTLR start "entity_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:722:1: entity_declarative_item : ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("entity_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_declarative_item()
	{
		EnterRule_entity_declarative_item();
		EnterRule("entity_declarative_item", 72);
		TraceIn("entity_declarative_item", 72);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shared_variable_declaration = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration258 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration259 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration260 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration261 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signal_declaration262 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration263 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration264 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration265 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification266 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> disconnection_specification267 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause268 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration269 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration270 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_declarative_item");
		DebugLocation(722, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 72)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:723:5: ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration )
			int alt89=14;
			try { DebugEnterDecision(89, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt89 = 1;
				}
				break;
			case TYPE:
				{
				alt89 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt89 = 3;
				}
				break;
			case CONSTANT:
				{
				alt89 = 4;
				}
				break;
			case SIGNAL:
				{
				alt89 = 5;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt89 = 6;
				}
				break;
			case FILE:
				{
				alt89 = 7;
				}
				break;
			case ALIAS:
				{
				alt89 = 8;
				}
				break;
			case ATTRIBUTE:
				{
				int LA89_9 = input.LA(2);

				if ((LA89_9==BASIC_IDENTIFIER||LA89_9==EXTENDED_IDENTIFIER))
				{
					int LA89_13 = input.LA(3);

					if ((LA89_13==COLON))
					{
						alt89 = 9;
					}
					else if ((LA89_13==OF))
					{
						alt89 = 10;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 89, 13, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA89_9==RANGETOK))
				{
					alt89 = 10;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 9, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DISCONNECT:
				{
				alt89 = 11;
				}
				break;
			case USE:
				{
				alt89 = 12;
				}
				break;
			case GROUP:
				{
				int LA89_12 = input.LA(2);

				if ((LA89_12==BASIC_IDENTIFIER||LA89_12==EXTENDED_IDENTIFIER))
				{
					int LA89_15 = input.LA(3);

					if ((LA89_15==IS))
					{
						alt89 = 13;
					}
					else if ((LA89_15==COLON))
					{
						alt89 = 14;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 89, 15, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 12, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:723:9: subprogram_body_or_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(723, 9);
				PushFollow(Follow._subprogram_body_or_declaration_in_entity_declarative_item7189);
				subprogram_body_or_declaration258=subprogram_body_or_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_body_or_declaration258.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:724:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(724, 9);
				PushFollow(Follow._type_declaration_in_entity_declarative_item7199);
				type_declaration259=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration259.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:725:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(725, 9);
				PushFollow(Follow._subtype_declaration_in_entity_declarative_item7209);
				subtype_declaration260=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration260.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:726:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(726, 9);
				PushFollow(Follow._constant_declaration_in_entity_declarative_item7219);
				constant_declaration261=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration261.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:727:9: signal_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(727, 9);
				PushFollow(Follow._signal_declaration_in_entity_declarative_item7229);
				signal_declaration262=signal_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, signal_declaration262.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:728:9: shared_variable_declaration= variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(728, 36);
				PushFollow(Follow._variable_declaration_in_entity_declarative_item7241);
				shared_variable_declaration=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, shared_variable_declaration.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:729:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(729, 9);
				PushFollow(Follow._file_declaration_in_entity_declarative_item7251);
				file_declaration263=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration263.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:730:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(730, 9);
				PushFollow(Follow._alias_declaration_in_entity_declarative_item7261);
				alias_declaration264=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration264.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:731:9: attribute_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(731, 9);
				PushFollow(Follow._attribute_declaration_in_entity_declarative_item7271);
				attribute_declaration265=attribute_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_declaration265.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:732:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(732, 9);
				PushFollow(Follow._attribute_specification_in_entity_declarative_item7281);
				attribute_specification266=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification266.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:733:9: disconnection_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(733, 9);
				PushFollow(Follow._disconnection_specification_in_entity_declarative_item7291);
				disconnection_specification267=disconnection_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disconnection_specification267.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:734:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(734, 9);
				PushFollow(Follow._use_clause_in_entity_declarative_item7301);
				use_clause268=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause268.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:735:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(735, 9);
				PushFollow(Follow._group_template_declaration_in_entity_declarative_item7311);
				group_template_declaration269=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration269.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:736:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(736, 9);
				PushFollow(Follow._group_declaration_in_entity_declarative_item7321);
				group_declaration270=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration270.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_declarative_item", 72);
			LeaveRule("entity_declarative_item", 72);
			LeaveRule_entity_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 72, entity_declarative_item_StartIndex); }

		}
		DebugLocation(737, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_declarative_item"); }
		return retval;

	}
	// $ANTLR end "entity_declarative_item"

	partial void EnterRule_entity_declarative_part();
	partial void LeaveRule_entity_declarative_part();

	// $ANTLR start "entity_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:739:1: entity_declarative_part : ( entity_declarative_item )+ ;
	[GrammarRule("entity_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_declarative_part()
	{
		EnterRule_entity_declarative_part();
		EnterRule("entity_declarative_part", 73);
		TraceIn("entity_declarative_part", 73);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> entity_declarative_item271 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_declarative_part");
		DebugLocation(739, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 73)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:740:5: ( ( entity_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:740:9: ( entity_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(740, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:740:9: ( entity_declarative_item )+
			int cnt90=0;
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				int LA90_0 = input.LA(1);

				if ((LA90_0==ALIAS||LA90_0==ATTRIBUTE||LA90_0==CONSTANT||LA90_0==DISCONNECT||LA90_0==FILE||LA90_0==FUNCTION||LA90_0==GROUP||LA90_0==IMPURE||LA90_0==PROCEDURE||LA90_0==PURE||(LA90_0>=SHARED && LA90_0<=SIGNAL)||LA90_0==SUBTYPE||LA90_0==TYPE||LA90_0==USE||LA90_0==VARIABLE))
				{
					alt90 = 1;
				}


				} finally { DebugExitDecision(90); }
				switch (alt90)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:740:9: entity_declarative_item
					{
					DebugLocation(740, 9);
					PushFollow(Follow._entity_declarative_item_in_entity_declarative_part7340);
					entity_declarative_item271=entity_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, entity_declarative_item271.Tree);

					}
					break;

				default:
					if (cnt90 >= 1)
						goto loop90;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee90 = new EarlyExitException( 90, input );
					DebugRecognitionException(eee90);
					throw eee90;
				}
				cnt90++;
			}
			loop90:
				;

			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_declarative_part", 73);
			LeaveRule("entity_declarative_part", 73);
			LeaveRule_entity_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 73, entity_declarative_part_StartIndex); }

		}
		DebugLocation(741, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_declarative_part"); }
		return retval;

	}
	// $ANTLR end "entity_declarative_part"

	partial void EnterRule_entity_designator();
	partial void LeaveRule_entity_designator();

	// $ANTLR start "entity_designator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:743:1: entity_designator : entity_tag ( signature )? ;
	[GrammarRule("entity_designator")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_designator()
	{
		EnterRule_entity_designator();
		EnterRule("entity_designator", 74);
		TraceIn("entity_designator", 74);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_designator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> entity_tag272 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signature273 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_designator");
		DebugLocation(743, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 74)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:744:5: ( entity_tag ( signature )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:744:9: entity_tag ( signature )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(744, 9);
			PushFollow(Follow._entity_tag_in_entity_designator7360);
			entity_tag272=entity_tag();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, entity_tag272.Tree);
			DebugLocation(744, 20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:744:20: ( signature )?
			int alt91=2;
			try { DebugEnterSubRule(91);
			try { DebugEnterDecision(91, false);
			int LA91_0 = input.LA(1);

			if ((LA91_0==LBRACKET))
			{
				alt91 = 1;
			}
			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:744:20: signature
				{
				DebugLocation(744, 20);
				PushFollow(Follow._signature_in_entity_designator7362);
				signature273=signature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, signature273.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(91); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_designator", 74);
			LeaveRule("entity_designator", 74);
			LeaveRule_entity_designator();
			if (state.backtracking > 0) { Memoize(input, 74, entity_designator_StartIndex); }

		}
		DebugLocation(745, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_designator"); }
		return retval;

	}
	// $ANTLR end "entity_designator"

	partial void EnterRule_entity_header();
	partial void LeaveRule_entity_header();

	// $ANTLR start "entity_header"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:747:1: entity_header : (formal_generic_clause= generic_clause )? (formal_port_clause= port_clause )? ;
	[GrammarRule("entity_header")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_header()
	{
		EnterRule_entity_header();
		EnterRule("entity_header", 75);
		TraceIn("entity_header", 75);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_header_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> formal_generic_clause = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> formal_port_clause = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_header");
		DebugLocation(747, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 75)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:748:5: ( (formal_generic_clause= generic_clause )? (formal_port_clause= port_clause )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:748:9: (formal_generic_clause= generic_clause )? (formal_port_clause= port_clause )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(748, 30);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:748:30: (formal_generic_clause= generic_clause )?
			int alt92=2;
			try { DebugEnterSubRule(92);
			try { DebugEnterDecision(92, false);
			int LA92_0 = input.LA(1);

			if ((LA92_0==GENERIC))
			{
				alt92 = 1;
			}
			} finally { DebugExitDecision(92); }
			switch (alt92)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:748:30: formal_generic_clause= generic_clause
				{
				DebugLocation(748, 30);
				PushFollow(Follow._generic_clause_in_entity_header7384);
				formal_generic_clause=generic_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, formal_generic_clause.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(92); }

			DebugLocation(749, 27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:749:27: (formal_port_clause= port_clause )?
			int alt93=2;
			try { DebugEnterSubRule(93);
			try { DebugEnterDecision(93, false);
			int LA93_0 = input.LA(1);

			if ((LA93_0==PORT))
			{
				alt93 = 1;
			}
			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:749:27: formal_port_clause= port_clause
				{
				DebugLocation(749, 27);
				PushFollow(Follow._port_clause_in_entity_header7397);
				formal_port_clause=port_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, formal_port_clause.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(93); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_header", 75);
			LeaveRule("entity_header", 75);
			LeaveRule_entity_header();
			if (state.backtracking > 0) { Memoize(input, 75, entity_header_StartIndex); }

		}
		DebugLocation(750, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_header"); }
		return retval;

	}
	// $ANTLR end "entity_header"

	partial void EnterRule_entity_name_list();
	partial void LeaveRule_entity_name_list();

	// $ANTLR start "entity_name_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:752:1: entity_name_list : ( entity_designator ( COMMA entity_designator )* -> ( entity_designator )+ | OTHERS | ALL );
	[GrammarRule("entity_name_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_name_list()
	{
		EnterRule_entity_name_list();
		EnterRule("entity_name_list", 76);
		TraceIn("entity_name_list", 76);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_name_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA275 = default(IToken);
		IToken OTHERS277 = default(IToken);
		IToken ALL278 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity_designator274 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_designator276 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA275_tree = default(CommonTree);
		CommonTree OTHERS277_tree = default(CommonTree);
		CommonTree ALL278_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_entity_designator=new RewriteRuleSubtreeStream(adaptor,"rule entity_designator");
		try { DebugEnterRule(GrammarFileName, "entity_name_list");
		DebugLocation(752, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 76)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:753:5: ( entity_designator ( COMMA entity_designator )* -> ( entity_designator )+ | OTHERS | ALL )
			int alt95=3;
			try { DebugEnterDecision(95, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case CHARACTER_LITERAL:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt95 = 1;
				}
				break;
			case OTHERS:
				{
				alt95 = 2;
				}
				break;
			case ALL:
				{
				alt95 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 95, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:753:9: entity_designator ( COMMA entity_designator )*
				{
				DebugLocation(753, 9);
				PushFollow(Follow._entity_designator_in_entity_name_list7417);
				entity_designator274=entity_designator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_entity_designator.Add(entity_designator274.Tree);
				DebugLocation(753, 27);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:753:27: ( COMMA entity_designator )*
				try { DebugEnterSubRule(94);
				while (true)
				{
					int alt94=2;
					try { DebugEnterDecision(94, false);
					int LA94_0 = input.LA(1);

					if ((LA94_0==COMMA))
					{
						alt94 = 1;
					}


					} finally { DebugExitDecision(94); }
					switch ( alt94 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:753:29: COMMA entity_designator
						{
						DebugLocation(753, 29);
						COMMA275=(IToken)Match(input,COMMA,Follow._COMMA_in_entity_name_list7421); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA275);

						DebugLocation(753, 35);
						PushFollow(Follow._entity_designator_in_entity_name_list7423);
						entity_designator276=entity_designator();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_entity_designator.Add(entity_designator276.Tree);

						}
						break;

					default:
						goto loop94;
					}
				}

				loop94:
					;

				} finally { DebugExitSubRule(94); }



				{
				// AST REWRITE
				// elements: entity_designator
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 754:9: -> ( entity_designator )+
				{
					DebugLocation(754, 12);
					if (!(stream_entity_designator.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_entity_designator.HasNext )
					{
						DebugLocation(754, 12);
						adaptor.AddChild(root_0, stream_entity_designator.NextTree());

					}
					stream_entity_designator.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:755:9: OTHERS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(755, 9);
				OTHERS277=(IToken)Match(input,OTHERS,Follow._OTHERS_in_entity_name_list7449); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OTHERS277_tree = (CommonTree)adaptor.Create(OTHERS277);
				adaptor.AddChild(root_0, OTHERS277_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:756:9: ALL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(756, 9);
				ALL278=(IToken)Match(input,ALL,Follow._ALL_in_entity_name_list7459); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ALL278_tree = (CommonTree)adaptor.Create(ALL278);
				adaptor.AddChild(root_0, ALL278_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_name_list", 76);
			LeaveRule("entity_name_list", 76);
			LeaveRule_entity_name_list();
			if (state.backtracking > 0) { Memoize(input, 76, entity_name_list_StartIndex); }

		}
		DebugLocation(757, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_name_list"); }
		return retval;

	}
	// $ANTLR end "entity_name_list"

	partial void EnterRule_entity_specification();
	partial void LeaveRule_entity_specification();

	// $ANTLR start "entity_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:759:1: entity_specification : entity_name_list COLON entity_class -> entity_name_list entity_class ;
	[GrammarRule("entity_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_specification()
	{
		EnterRule_entity_specification();
		EnterRule("entity_specification", 77);
		TraceIn("entity_specification", 77);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON280 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> entity_name_list279 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_class281 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON280_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_entity_name_list=new RewriteRuleSubtreeStream(adaptor,"rule entity_name_list");
		RewriteRuleSubtreeStream stream_entity_class=new RewriteRuleSubtreeStream(adaptor,"rule entity_class");
		try { DebugEnterRule(GrammarFileName, "entity_specification");
		DebugLocation(759, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 77)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:760:5: ( entity_name_list COLON entity_class -> entity_name_list entity_class )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:760:9: entity_name_list COLON entity_class
			{
			DebugLocation(760, 9);
			PushFollow(Follow._entity_name_list_in_entity_specification7478);
			entity_name_list279=entity_name_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_name_list.Add(entity_name_list279.Tree);
			DebugLocation(760, 26);
			COLON280=(IToken)Match(input,COLON,Follow._COLON_in_entity_specification7480); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON280);

			DebugLocation(760, 32);
			PushFollow(Follow._entity_class_in_entity_specification7482);
			entity_class281=entity_class();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_class.Add(entity_class281.Tree);


			{
			// AST REWRITE
			// elements: entity_class, entity_name_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 761:9: -> entity_name_list entity_class
			{
				DebugLocation(761, 12);
				adaptor.AddChild(root_0, stream_entity_name_list.NextTree());
				DebugLocation(761, 29);
				adaptor.AddChild(root_0, stream_entity_class.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_specification", 77);
			LeaveRule("entity_specification", 77);
			LeaveRule_entity_specification();
			if (state.backtracking > 0) { Memoize(input, 77, entity_specification_StartIndex); }

		}
		DebugLocation(762, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_specification"); }
		return retval;

	}
	// $ANTLR end "entity_specification"

	partial void EnterRule_entity_statement();
	partial void LeaveRule_entity_statement();

	// $ANTLR start "entity_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:764:1: entity_statement : ( identifier COLON )? ( POSTPONED )? entity_statement2 -> ^( ENTITY_STATEMENT ( identifier )? ( POSTPONED )? entity_statement2 ) ;
	[GrammarRule("entity_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_statement()
	{
		EnterRule_entity_statement();
		EnterRule("entity_statement", 78);
		TraceIn("entity_statement", 78);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON283 = default(IToken);
		IToken POSTPONED284 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier282 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_statement2285 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON283_tree = default(CommonTree);
		CommonTree POSTPONED284_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_POSTPONED=new RewriteRuleITokenStream(adaptor,"token POSTPONED");
		RewriteRuleSubtreeStream stream_entity_statement2=new RewriteRuleSubtreeStream(adaptor,"rule entity_statement2");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "entity_statement");
		DebugLocation(764, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 78)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:5: ( ( identifier COLON )? ( POSTPONED )? entity_statement2 -> ^( ENTITY_STATEMENT ( identifier )? ( POSTPONED )? entity_statement2 ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:9: ( identifier COLON )? ( POSTPONED )? entity_statement2
			{
			DebugLocation(765, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:9: ( identifier COLON )?
			int alt96=2;
			try { DebugEnterSubRule(96);
			try { DebugEnterDecision(96, false);
			int LA96_0 = input.LA(1);

			if ((LA96_0==BASIC_IDENTIFIER||LA96_0==EXTENDED_IDENTIFIER))
			{
				int LA96_1 = input.LA(2);

				if ((LA96_1==COLON))
				{
					alt96 = 1;
				}
			}
			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:11: identifier COLON
				{
				DebugLocation(765, 11);
				PushFollow(Follow._identifier_in_entity_statement7517);
				identifier282=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier282.Tree);
				DebugLocation(765, 22);
				COLON283=(IToken)Match(input,COLON,Follow._COLON_in_entity_statement7519); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON283);


				}
				break;

			}
			} finally { DebugExitSubRule(96); }

			DebugLocation(765, 31);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:31: ( POSTPONED )?
			int alt97=2;
			try { DebugEnterSubRule(97);
			try { DebugEnterDecision(97, false);
			int LA97_0 = input.LA(1);

			if ((LA97_0==POSTPONED))
			{
				alt97 = 1;
			}
			} finally { DebugExitDecision(97); }
			switch (alt97)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:765:31: POSTPONED
				{
				DebugLocation(765, 31);
				POSTPONED284=(IToken)Match(input,POSTPONED,Follow._POSTPONED_in_entity_statement7524); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSTPONED.Add(POSTPONED284);


				}
				break;

			}
			} finally { DebugExitSubRule(97); }

			DebugLocation(765, 42);
			PushFollow(Follow._entity_statement2_in_entity_statement7527);
			entity_statement2285=entity_statement2();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_statement2.Add(entity_statement2285.Tree);


			{
			// AST REWRITE
			// elements: entity_statement2, identifier, POSTPONED
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 766:9: -> ^( ENTITY_STATEMENT ( identifier )? ( POSTPONED )? entity_statement2 )
			{
				DebugLocation(766, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:766:12: ^( ENTITY_STATEMENT ( identifier )? ( POSTPONED )? entity_statement2 )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(766, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ENTITY_STATEMENT, "ENTITY_STATEMENT"), root_1);

				DebugLocation(766, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:766:32: ( identifier )?
				if (stream_identifier.HasNext)
				{
					DebugLocation(766, 32);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();
				DebugLocation(766, 44);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:766:44: ( POSTPONED )?
				if (stream_POSTPONED.HasNext)
				{
					DebugLocation(766, 44);
					adaptor.AddChild(root_1, stream_POSTPONED.NextNode());

				}
				stream_POSTPONED.Reset();
				DebugLocation(766, 55);
				adaptor.AddChild(root_1, stream_entity_statement2.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_statement", 78);
			LeaveRule("entity_statement", 78);
			LeaveRule_entity_statement();
			if (state.backtracking > 0) { Memoize(input, 78, entity_statement_StartIndex); }

		}
		DebugLocation(767, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_statement"); }
		return retval;

	}
	// $ANTLR end "entity_statement"

	partial void EnterRule_entity_statement2();
	partial void LeaveRule_entity_statement2();

	// $ANTLR start "entity_statement2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:769:1: entity_statement2 : ( concurrent_assertion_statement | concurrent_procedure_call_statement | process_statement );
	[GrammarRule("entity_statement2")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_statement2()
	{
		EnterRule_entity_statement2();
		EnterRule("entity_statement2", 79);
		TraceIn("entity_statement2", 79);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_statement2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> concurrent_assertion_statement286 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_procedure_call_statement287 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> process_statement288 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_statement2");
		DebugLocation(769, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 79)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:770:5: ( concurrent_assertion_statement | concurrent_procedure_call_statement | process_statement )
			int alt98=3;
			try { DebugEnterDecision(98, false);
			switch (input.LA(1))
			{
			case ASSERT:
				{
				alt98 = 1;
				}
				break;
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt98 = 2;
				}
				break;
			case PROCESS:
				{
				alt98 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:770:9: concurrent_assertion_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(770, 9);
				PushFollow(Follow._concurrent_assertion_statement_in_entity_statement27570);
				concurrent_assertion_statement286=concurrent_assertion_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_assertion_statement286.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:771:9: concurrent_procedure_call_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(771, 9);
				PushFollow(Follow._concurrent_procedure_call_statement_in_entity_statement27580);
				concurrent_procedure_call_statement287=concurrent_procedure_call_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, concurrent_procedure_call_statement287.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:772:9: process_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(772, 9);
				PushFollow(Follow._process_statement_in_entity_statement27590);
				process_statement288=process_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, process_statement288.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_statement2", 79);
			LeaveRule("entity_statement2", 79);
			LeaveRule_entity_statement2();
			if (state.backtracking > 0) { Memoize(input, 79, entity_statement2_StartIndex); }

		}
		DebugLocation(773, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_statement2"); }
		return retval;

	}
	// $ANTLR end "entity_statement2"

	partial void EnterRule_entity_statement_part();
	partial void LeaveRule_entity_statement_part();

	// $ANTLR start "entity_statement_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:775:1: entity_statement_part : ( entity_statement )+ ;
	[GrammarRule("entity_statement_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_statement_part()
	{
		EnterRule_entity_statement_part();
		EnterRule("entity_statement_part", 80);
		TraceIn("entity_statement_part", 80);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_statement_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> entity_statement289 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "entity_statement_part");
		DebugLocation(775, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 80)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:776:5: ( ( entity_statement )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:776:9: ( entity_statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(776, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:776:9: ( entity_statement )+
			int cnt99=0;
			try { DebugEnterSubRule(99);
			while (true)
			{
				int alt99=2;
				try { DebugEnterDecision(99, false);
				int LA99_0 = input.LA(1);

				if ((LA99_0==ASSERT||LA99_0==BASIC_IDENTIFIER||LA99_0==EXTENDED_IDENTIFIER||LA99_0==POSTPONED||LA99_0==PROCESS||LA99_0==STRING_LITERAL))
				{
					alt99 = 1;
				}


				} finally { DebugExitDecision(99); }
				switch (alt99)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:776:9: entity_statement
					{
					DebugLocation(776, 9);
					PushFollow(Follow._entity_statement_in_entity_statement_part7609);
					entity_statement289=entity_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, entity_statement289.Tree);

					}
					break;

				default:
					if (cnt99 >= 1)
						goto loop99;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee99 = new EarlyExitException( 99, input );
					DebugRecognitionException(eee99);
					throw eee99;
				}
				cnt99++;
			}
			loop99:
				;

			} finally { DebugExitSubRule(99); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_statement_part", 80);
			LeaveRule("entity_statement_part", 80);
			LeaveRule_entity_statement_part();
			if (state.backtracking > 0) { Memoize(input, 80, entity_statement_part_StartIndex); }

		}
		DebugLocation(777, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_statement_part"); }
		return retval;

	}
	// $ANTLR end "entity_statement_part"

	partial void EnterRule_entity_tag();
	partial void LeaveRule_entity_tag();

	// $ANTLR start "entity_tag"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:779:1: entity_tag : (simple_name= identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL );
	[GrammarRule("entity_tag")]
	private AstParserRuleReturnScope<CommonTree, IToken> entity_tag()
	{
		EnterRule_entity_tag();
		EnterRule("entity_tag", 81);
		TraceIn("entity_tag", 81);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int entity_tag_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken operator_symbol = default(IToken);
		IToken CHARACTER_LITERAL290 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> simple_name = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree operator_symbol_tree = default(CommonTree);
		CommonTree CHARACTER_LITERAL290_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "entity_tag");
		DebugLocation(779, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 81)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:780:5: (simple_name= identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL )
			int alt100=3;
			try { DebugEnterDecision(100, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				alt100 = 1;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt100 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt100 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 100, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:780:9: simple_name= identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(780, 20);
				PushFollow(Follow._identifier_in_entity_tag7631);
				simple_name=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_name.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:781:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(781, 9);
				CHARACTER_LITERAL290=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_entity_tag7641); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL290_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL290);
				adaptor.AddChild(root_0, CHARACTER_LITERAL290_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:782:9: operator_symbol= STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(782, 24);
				operator_symbol=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_entity_tag7653); if (state.failed) return retval;
				if (state.backtracking == 0) {
				operator_symbol_tree = (CommonTree)adaptor.Create(operator_symbol);
				adaptor.AddChild(root_0, operator_symbol_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("entity_tag", 81);
			LeaveRule("entity_tag", 81);
			LeaveRule_entity_tag();
			if (state.backtracking > 0) { Memoize(input, 81, entity_tag_StartIndex); }

		}
		DebugLocation(783, 4);
		} finally { DebugExitRule(GrammarFileName, "entity_tag"); }
		return retval;

	}
	// $ANTLR end "entity_tag"

	partial void EnterRule_enumeration_literal();
	partial void LeaveRule_enumeration_literal();

	// $ANTLR start "enumeration_literal"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:785:1: enumeration_literal : ( CHARACTER_LITERAL | identifier );
	[GrammarRule("enumeration_literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> enumeration_literal()
	{
		EnterRule_enumeration_literal();
		EnterRule("enumeration_literal", 82);
		TraceIn("enumeration_literal", 82);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int enumeration_literal_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CHARACTER_LITERAL291 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier292 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CHARACTER_LITERAL291_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "enumeration_literal");
		DebugLocation(785, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 82)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:786:5: ( CHARACTER_LITERAL | identifier )
			int alt101=2;
			try { DebugEnterDecision(101, false);
			int LA101_0 = input.LA(1);

			if ((LA101_0==CHARACTER_LITERAL))
			{
				alt101 = 1;
			}
			else if ((LA101_0==BASIC_IDENTIFIER||LA101_0==EXTENDED_IDENTIFIER))
			{
				alt101 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 101, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(101); }
			switch (alt101)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:786:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(786, 9);
				CHARACTER_LITERAL291=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_enumeration_literal7672); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL291_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL291);
				adaptor.AddChild(root_0, CHARACTER_LITERAL291_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:787:9: identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(787, 9);
				PushFollow(Follow._identifier_in_enumeration_literal7682);
				identifier292=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, identifier292.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumeration_literal", 82);
			LeaveRule("enumeration_literal", 82);
			LeaveRule_enumeration_literal();
			if (state.backtracking > 0) { Memoize(input, 82, enumeration_literal_StartIndex); }

		}
		DebugLocation(788, 4);
		} finally { DebugExitRule(GrammarFileName, "enumeration_literal"); }
		return retval;

	}
	// $ANTLR end "enumeration_literal"

	partial void EnterRule_enumeration_type_definition();
	partial void LeaveRule_enumeration_type_definition();

	// $ANTLR start "enumeration_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:790:1: enumeration_type_definition : LPAREN enumeration_literal ( COMMA enumeration_literal )* RPAREN -> ^( ENUMERATION_TYPE_DEFINITION ( enumeration_literal )+ ) ;
	[GrammarRule("enumeration_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> enumeration_type_definition()
	{
		EnterRule_enumeration_type_definition();
		EnterRule("enumeration_type_definition", 83);
		TraceIn("enumeration_type_definition", 83);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int enumeration_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN293 = default(IToken);
		IToken COMMA295 = default(IToken);
		IToken RPAREN297 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> enumeration_literal294 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> enumeration_literal296 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN293_tree = default(CommonTree);
		CommonTree COMMA295_tree = default(CommonTree);
		CommonTree RPAREN297_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_enumeration_literal=new RewriteRuleSubtreeStream(adaptor,"rule enumeration_literal");
		try { DebugEnterRule(GrammarFileName, "enumeration_type_definition");
		DebugLocation(790, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 83)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:791:5: ( LPAREN enumeration_literal ( COMMA enumeration_literal )* RPAREN -> ^( ENUMERATION_TYPE_DEFINITION ( enumeration_literal )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:791:9: LPAREN enumeration_literal ( COMMA enumeration_literal )* RPAREN
			{
			DebugLocation(791, 9);
			LPAREN293=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enumeration_type_definition7701); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN293);

			DebugLocation(791, 16);
			PushFollow(Follow._enumeration_literal_in_enumeration_type_definition7703);
			enumeration_literal294=enumeration_literal();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_enumeration_literal.Add(enumeration_literal294.Tree);
			DebugLocation(791, 36);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:791:36: ( COMMA enumeration_literal )*
			try { DebugEnterSubRule(102);
			while (true)
			{
				int alt102=2;
				try { DebugEnterDecision(102, false);
				int LA102_0 = input.LA(1);

				if ((LA102_0==COMMA))
				{
					alt102 = 1;
				}


				} finally { DebugExitDecision(102); }
				switch ( alt102 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:791:38: COMMA enumeration_literal
					{
					DebugLocation(791, 38);
					COMMA295=(IToken)Match(input,COMMA,Follow._COMMA_in_enumeration_type_definition7707); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA295);

					DebugLocation(791, 44);
					PushFollow(Follow._enumeration_literal_in_enumeration_type_definition7709);
					enumeration_literal296=enumeration_literal();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_enumeration_literal.Add(enumeration_literal296.Tree);

					}
					break;

				default:
					goto loop102;
				}
			}

			loop102:
				;

			} finally { DebugExitSubRule(102); }

			DebugLocation(791, 67);
			RPAREN297=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enumeration_type_definition7714); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN297);



			{
			// AST REWRITE
			// elements: enumeration_literal
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 792:9: -> ^( ENUMERATION_TYPE_DEFINITION ( enumeration_literal )+ )
			{
				DebugLocation(792, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:792:12: ^( ENUMERATION_TYPE_DEFINITION ( enumeration_literal )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(792, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ENUMERATION_TYPE_DEFINITION, "ENUMERATION_TYPE_DEFINITION"), root_1);

				DebugLocation(792, 43);
				if (!(stream_enumeration_literal.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_enumeration_literal.HasNext )
				{
					DebugLocation(792, 43);
					adaptor.AddChild(root_1, stream_enumeration_literal.NextTree());

				}
				stream_enumeration_literal.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumeration_type_definition", 83);
			LeaveRule("enumeration_type_definition", 83);
			LeaveRule_enumeration_type_definition();
			if (state.backtracking > 0) { Memoize(input, 83, enumeration_type_definition_StartIndex); }

		}
		DebugLocation(793, 4);
		} finally { DebugExitRule(GrammarFileName, "enumeration_type_definition"); }
		return retval;

	}
	// $ANTLR end "enumeration_type_definition"

	partial void EnterRule_exit_statement();
	partial void LeaveRule_exit_statement();

	// $ANTLR start "exit_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:795:1: exit_statement : EXIT (loop_label= identifier )? ( WHEN condition )? SEMI -> ^( EXIT ( $loop_label)? ( condition )? ) ;
	[GrammarRule("exit_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> exit_statement()
	{
		EnterRule_exit_statement();
		EnterRule("exit_statement", 84);
		TraceIn("exit_statement", 84);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int exit_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken EXIT298 = default(IToken);
		IToken WHEN299 = default(IToken);
		IToken SEMI301 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> loop_label = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition300 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EXIT298_tree = default(CommonTree);
		CommonTree WHEN299_tree = default(CommonTree);
		CommonTree SEMI301_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EXIT=new RewriteRuleITokenStream(adaptor,"token EXIT");
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "exit_statement");
		DebugLocation(795, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 84)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:5: ( EXIT (loop_label= identifier )? ( WHEN condition )? SEMI -> ^( EXIT ( $loop_label)? ( condition )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:9: EXIT (loop_label= identifier )? ( WHEN condition )? SEMI
			{
			DebugLocation(796, 9);
			EXIT298=(IToken)Match(input,EXIT,Follow._EXIT_in_exit_statement7752); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXIT.Add(EXIT298);

			DebugLocation(796, 24);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:24: (loop_label= identifier )?
			int alt103=2;
			try { DebugEnterSubRule(103);
			try { DebugEnterDecision(103, false);
			int LA103_0 = input.LA(1);

			if ((LA103_0==BASIC_IDENTIFIER||LA103_0==EXTENDED_IDENTIFIER))
			{
				alt103 = 1;
			}
			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:24: loop_label= identifier
				{
				DebugLocation(796, 24);
				PushFollow(Follow._identifier_in_exit_statement7756);
				loop_label=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(loop_label.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(103); }

			DebugLocation(796, 37);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:37: ( WHEN condition )?
			int alt104=2;
			try { DebugEnterSubRule(104);
			try { DebugEnterDecision(104, false);
			int LA104_0 = input.LA(1);

			if ((LA104_0==WHEN))
			{
				alt104 = 1;
			}
			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:796:39: WHEN condition
				{
				DebugLocation(796, 39);
				WHEN299=(IToken)Match(input,WHEN,Follow._WHEN_in_exit_statement7761); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHEN.Add(WHEN299);

				DebugLocation(796, 44);
				PushFollow(Follow._condition_in_exit_statement7763);
				condition300=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition300.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(104); }

			DebugLocation(796, 57);
			SEMI301=(IToken)Match(input,SEMI,Follow._SEMI_in_exit_statement7768); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI301);



			{
			// AST REWRITE
			// elements: EXIT, condition, loop_label
			// token labels: 
			// rule labels: loop_label, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_loop_label=new RewriteRuleSubtreeStream(adaptor,"rule loop_label",loop_label!=null?loop_label.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 797:9: -> ^( EXIT ( $loop_label)? ( condition )? )
			{
				DebugLocation(797, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:797:12: ^( EXIT ( $loop_label)? ( condition )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(797, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_EXIT.NextNode(), root_1);

				DebugLocation(797, 21);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:797:21: ( $loop_label)?
				if (stream_loop_label.HasNext)
				{
					DebugLocation(797, 21);
					adaptor.AddChild(root_1, stream_loop_label.NextTree());

				}
				stream_loop_label.Reset();
				DebugLocation(797, 33);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:797:33: ( condition )?
				if (stream_condition.HasNext)
				{
					DebugLocation(797, 33);
					adaptor.AddChild(root_1, stream_condition.NextTree());

				}
				stream_condition.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exit_statement", 84);
			LeaveRule("exit_statement", 84);
			LeaveRule_exit_statement();
			if (state.backtracking > 0) { Memoize(input, 84, exit_statement_StartIndex); }

		}
		DebugLocation(798, 4);
		} finally { DebugExitRule(GrammarFileName, "exit_statement"); }
		return retval;

	}
	// $ANTLR end "exit_statement"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:800:1: expression : expression2 -> ^( EXPRESSION expression2 ) ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 85);
		TraceIn("expression", 85);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> expression2302 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_expression2=new RewriteRuleSubtreeStream(adaptor,"rule expression2");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(800, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 85)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:801:5: ( expression2 -> ^( EXPRESSION expression2 ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:801:9: expression2
			{
			DebugLocation(801, 9);
			PushFollow(Follow._expression2_in_expression7810);
			expression2302=expression2();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression2.Add(expression2302.Tree);


			{
			// AST REWRITE
			// elements: expression2
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 802:9: -> ^( EXPRESSION expression2 )
			{
				DebugLocation(802, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:802:12: ^( EXPRESSION expression2 )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(802, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(802, 26);
				adaptor.AddChild(root_1, stream_expression2.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 85);
			LeaveRule("expression", 85);
			LeaveRule_expression();
			if (state.backtracking > 0) { Memoize(input, 85, expression_StartIndex); }

		}
		DebugLocation(803, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expression2();
	partial void LeaveRule_expression2();

	// $ANTLR start "expression2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:805:1: expression2 : relation ( logical_operator ^ relation )* ;
	[GrammarRule("expression2")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression2()
	{
		EnterRule_expression2();
		EnterRule("expression2", 86);
		TraceIn("expression2", 86);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expression2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> relation303 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logical_operator304 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relation305 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "expression2");
		DebugLocation(805, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 86)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:806:5: ( relation ( logical_operator ^ relation )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:806:9: relation ( logical_operator ^ relation )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(806, 9);
			PushFollow(Follow._relation_in_expression27847);
			relation303=relation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relation303.Tree);
			DebugLocation(806, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:806:18: ( logical_operator ^ relation )*
			try { DebugEnterSubRule(105);
			while (true)
			{
				int alt105=2;
				try { DebugEnterDecision(105, false);
				int LA105_0 = input.LA(1);

				if ((LA105_0==AND||LA105_0==NAND||LA105_0==NOR||LA105_0==OR||(LA105_0>=XNOR && LA105_0<=XOR)))
				{
					alt105 = 1;
				}


				} finally { DebugExitDecision(105); }
				switch ( alt105 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:806:20: logical_operator ^ relation
					{
					DebugLocation(806, 36);
					PushFollow(Follow._logical_operator_in_expression27851);
					logical_operator304=logical_operator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(logical_operator304.Tree, root_0);
					DebugLocation(806, 38);
					PushFollow(Follow._relation_in_expression27854);
					relation305=relation();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relation305.Tree);

					}
					break;

				default:
					goto loop105;
				}
			}

			loop105:
				;

			} finally { DebugExitSubRule(105); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression2", 86);
			LeaveRule("expression2", 86);
			LeaveRule_expression2();
			if (state.backtracking > 0) { Memoize(input, 86, expression2_StartIndex); }

		}
		DebugLocation(807, 4);
		} finally { DebugExitRule(GrammarFileName, "expression2"); }
		return retval;

	}
	// $ANTLR end "expression2"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();

	// $ANTLR start "factor"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:809:1: factor : ( primary ( DOUBLESTAR ^ primary )? | ABS primary -> ^( ABS primary ) | NOT primary -> ^( NOT primary ) );
	[GrammarRule("factor")]
	private AstParserRuleReturnScope<CommonTree, IToken> factor()
	{
		EnterRule_factor();
		EnterRule("factor", 87);
		TraceIn("factor", 87);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int factor_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken DOUBLESTAR307 = default(IToken);
		IToken ABS309 = default(IToken);
		IToken NOT311 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primary306 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> primary308 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> primary310 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> primary312 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOUBLESTAR307_tree = default(CommonTree);
		CommonTree ABS309_tree = default(CommonTree);
		CommonTree NOT311_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ABS=new RewriteRuleITokenStream(adaptor,"token ABS");
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_primary=new RewriteRuleSubtreeStream(adaptor,"rule primary");
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(809, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 87)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:810:5: ( primary ( DOUBLESTAR ^ primary )? | ABS primary -> ^( ABS primary ) | NOT primary -> ^( NOT primary ) )
			int alt107=3;
			try { DebugEnterDecision(107, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case BINANRY_BASED_INTEGER:
			case BIT_STRING_LITERAL_BINARY:
			case BIT_STRING_LITERAL_HEX:
			case BIT_STRING_LITERAL_OCTAL:
			case CHARACTER_LITERAL:
			case DEC_BASED_INTEGER:
			case EXTENDED_IDENTIFIER:
			case FLOAT_POINT_LITERAL:
			case HEXA_BASED_INTEGER:
			case LPAREN:
			case NEW:
			case NULLTOK:
			case OCTAL_BASED_INTEGER:
			case STRING_LITERAL:
				{
				alt107 = 1;
				}
				break;
			case ABS:
				{
				alt107 = 2;
				}
				break;
			case NOT:
				{
				alt107 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 107, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(107); }
			switch (alt107)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:810:9: primary ( DOUBLESTAR ^ primary )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(810, 9);
				PushFollow(Follow._primary_in_factor7876);
				primary306=primary();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primary306.Tree);
				DebugLocation(810, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:810:17: ( DOUBLESTAR ^ primary )?
				int alt106=2;
				try { DebugEnterSubRule(106);
				try { DebugEnterDecision(106, false);
				int LA106_0 = input.LA(1);

				if ((LA106_0==DOUBLESTAR))
				{
					alt106 = 1;
				}
				} finally { DebugExitDecision(106); }
				switch (alt106)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:810:19: DOUBLESTAR ^ primary
					{
					DebugLocation(810, 29);
					DOUBLESTAR307=(IToken)Match(input,DOUBLESTAR,Follow._DOUBLESTAR_in_factor7880); if (state.failed) return retval;
					if (state.backtracking == 0) {
					DOUBLESTAR307_tree = (CommonTree)adaptor.Create(DOUBLESTAR307);
					root_0 = (CommonTree)adaptor.BecomeRoot(DOUBLESTAR307_tree, root_0);
					}
					DebugLocation(810, 31);
					PushFollow(Follow._primary_in_factor7883);
					primary308=primary();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary308.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(106); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:811:9: ABS primary
				{
				DebugLocation(811, 9);
				ABS309=(IToken)Match(input,ABS,Follow._ABS_in_factor7896); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ABS.Add(ABS309);

				DebugLocation(811, 13);
				PushFollow(Follow._primary_in_factor7898);
				primary310=primary();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primary.Add(primary310.Tree);


				{
				// AST REWRITE
				// elements: primary, ABS
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 812:9: -> ^( ABS primary )
				{
					DebugLocation(812, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:812:12: ^( ABS primary )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(812, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_ABS.NextNode(), root_1);

					DebugLocation(812, 19);
					adaptor.AddChild(root_1, stream_primary.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:813:9: NOT primary
				{
				DebugLocation(813, 9);
				NOT311=(IToken)Match(input,NOT,Follow._NOT_in_factor7926); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT311);

				DebugLocation(813, 13);
				PushFollow(Follow._primary_in_factor7928);
				primary312=primary();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primary.Add(primary312.Tree);


				{
				// AST REWRITE
				// elements: primary, NOT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 814:9: -> ^( NOT primary )
				{
					DebugLocation(814, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:814:12: ^( NOT primary )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(814, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_NOT.NextNode(), root_1);

					DebugLocation(814, 19);
					adaptor.AddChild(root_1, stream_primary.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("factor", 87);
			LeaveRule("factor", 87);
			LeaveRule_factor();
			if (state.backtracking > 0) { Memoize(input, 87, factor_StartIndex); }

		}
		DebugLocation(815, 4);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		return retval;

	}
	// $ANTLR end "factor"

	partial void EnterRule_file_declaration();
	partial void LeaveRule_file_declaration();

	// $ANTLR start "file_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:817:1: file_declaration : FILE identifier_list COLON subtype_indication ( file_open_information )? SEMI -> ^( FILE identifier_list subtype_indication ( file_open_information )? ) ;
	[GrammarRule("file_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> file_declaration()
	{
		EnterRule_file_declaration();
		EnterRule("file_declaration", 88);
		TraceIn("file_declaration", 88);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int file_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FILE313 = default(IToken);
		IToken COLON315 = default(IToken);
		IToken SEMI318 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list314 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication316 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_open_information317 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FILE313_tree = default(CommonTree);
		CommonTree COLON315_tree = default(CommonTree);
		CommonTree SEMI318_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_FILE=new RewriteRuleITokenStream(adaptor,"token FILE");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		RewriteRuleSubtreeStream stream_file_open_information=new RewriteRuleSubtreeStream(adaptor,"rule file_open_information");
		try { DebugEnterRule(GrammarFileName, "file_declaration");
		DebugLocation(817, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 88)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:818:5: ( FILE identifier_list COLON subtype_indication ( file_open_information )? SEMI -> ^( FILE identifier_list subtype_indication ( file_open_information )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:818:9: FILE identifier_list COLON subtype_indication ( file_open_information )? SEMI
			{
			DebugLocation(818, 9);
			FILE313=(IToken)Match(input,FILE,Follow._FILE_in_file_declaration7965); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FILE.Add(FILE313);

			DebugLocation(818, 14);
			PushFollow(Follow._identifier_list_in_file_declaration7967);
			identifier_list314=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list314.Tree);
			DebugLocation(818, 30);
			COLON315=(IToken)Match(input,COLON,Follow._COLON_in_file_declaration7969); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON315);

			DebugLocation(818, 36);
			PushFollow(Follow._subtype_indication_in_file_declaration7971);
			subtype_indication316=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication316.Tree);
			DebugLocation(818, 55);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:818:55: ( file_open_information )?
			int alt108=2;
			try { DebugEnterSubRule(108);
			try { DebugEnterDecision(108, false);
			int LA108_0 = input.LA(1);

			if ((LA108_0==IS||LA108_0==OPEN))
			{
				alt108 = 1;
			}
			} finally { DebugExitDecision(108); }
			switch (alt108)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:818:55: file_open_information
				{
				DebugLocation(818, 55);
				PushFollow(Follow._file_open_information_in_file_declaration7973);
				file_open_information317=file_open_information();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_file_open_information.Add(file_open_information317.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(108); }

			DebugLocation(818, 78);
			SEMI318=(IToken)Match(input,SEMI,Follow._SEMI_in_file_declaration7976); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI318);



			{
			// AST REWRITE
			// elements: subtype_indication, identifier_list, FILE, file_open_information
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 819:9: -> ^( FILE identifier_list subtype_indication ( file_open_information )? )
			{
				DebugLocation(819, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:819:12: ^( FILE identifier_list subtype_indication ( file_open_information )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(819, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_FILE.NextNode(), root_1);

				DebugLocation(819, 20);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(819, 36);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(819, 55);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:819:55: ( file_open_information )?
				if (stream_file_open_information.HasNext)
				{
					DebugLocation(819, 55);
					adaptor.AddChild(root_1, stream_file_open_information.NextTree());

				}
				stream_file_open_information.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file_declaration", 88);
			LeaveRule("file_declaration", 88);
			LeaveRule_file_declaration();
			if (state.backtracking > 0) { Memoize(input, 88, file_declaration_StartIndex); }

		}
		DebugLocation(820, 4);
		} finally { DebugExitRule(GrammarFileName, "file_declaration"); }
		return retval;

	}
	// $ANTLR end "file_declaration"

	partial void EnterRule_file_logical_name();
	partial void LeaveRule_file_logical_name();

	// $ANTLR start "file_logical_name"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:822:1: file_logical_name : string_expression= expression ;
	[GrammarRule("file_logical_name")]
	private AstParserRuleReturnScope<CommonTree, IToken> file_logical_name()
	{
		EnterRule_file_logical_name();
		EnterRule("file_logical_name", 89);
		TraceIn("file_logical_name", 89);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int file_logical_name_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> string_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "file_logical_name");
		DebugLocation(822, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 89)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:823:5: (string_expression= expression )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:823:9: string_expression= expression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(823, 26);
			PushFollow(Follow._expression_in_file_logical_name8020);
			string_expression=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, string_expression.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file_logical_name", 89);
			LeaveRule("file_logical_name", 89);
			LeaveRule_file_logical_name();
			if (state.backtracking > 0) { Memoize(input, 89, file_logical_name_StartIndex); }

		}
		DebugLocation(824, 4);
		} finally { DebugExitRule(GrammarFileName, "file_logical_name"); }
		return retval;

	}
	// $ANTLR end "file_logical_name"

	partial void EnterRule_file_open_information();
	partial void LeaveRule_file_open_information();

	// $ANTLR start "file_open_information"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:826:1: file_open_information : ( OPEN file_open_kind= expression )? IS file_logical_name -> ( ^( OPEN $file_open_kind) )? file_logical_name ;
	[GrammarRule("file_open_information")]
	private AstParserRuleReturnScope<CommonTree, IToken> file_open_information()
	{
		EnterRule_file_open_information();
		EnterRule("file_open_information", 90);
		TraceIn("file_open_information", 90);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int file_open_information_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken OPEN319 = default(IToken);
		IToken IS320 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> file_open_kind = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_logical_name321 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree OPEN319_tree = default(CommonTree);
		CommonTree IS320_tree = default(CommonTree);
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_file_logical_name=new RewriteRuleSubtreeStream(adaptor,"rule file_logical_name");
		try { DebugEnterRule(GrammarFileName, "file_open_information");
		DebugLocation(826, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 90)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:827:5: ( ( OPEN file_open_kind= expression )? IS file_logical_name -> ( ^( OPEN $file_open_kind) )? file_logical_name )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:827:9: ( OPEN file_open_kind= expression )? IS file_logical_name
			{
			DebugLocation(827, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:827:9: ( OPEN file_open_kind= expression )?
			int alt109=2;
			try { DebugEnterSubRule(109);
			try { DebugEnterDecision(109, false);
			int LA109_0 = input.LA(1);

			if ((LA109_0==OPEN))
			{
				alt109 = 1;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:827:11: OPEN file_open_kind= expression
				{
				DebugLocation(827, 11);
				OPEN319=(IToken)Match(input,OPEN,Follow._OPEN_in_file_open_information8041); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OPEN.Add(OPEN319);

				DebugLocation(827, 30);
				PushFollow(Follow._expression_in_file_open_information8045);
				file_open_kind=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(file_open_kind.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(109); }

			DebugLocation(827, 45);
			IS320=(IToken)Match(input,IS,Follow._IS_in_file_open_information8050); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS320);

			DebugLocation(827, 48);
			PushFollow(Follow._file_logical_name_in_file_open_information8052);
			file_logical_name321=file_logical_name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_file_logical_name.Add(file_logical_name321.Tree);


			{
			// AST REWRITE
			// elements: OPEN, file_logical_name, file_open_kind
			// token labels: 
			// rule labels: file_open_kind, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_file_open_kind=new RewriteRuleSubtreeStream(adaptor,"rule file_open_kind",file_open_kind!=null?file_open_kind.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 828:9: -> ( ^( OPEN $file_open_kind) )? file_logical_name
			{
				DebugLocation(828, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:828:12: ( ^( OPEN $file_open_kind) )?
				if (stream_OPEN.HasNext||stream_file_open_kind.HasNext)
				{
					DebugLocation(828, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:828:12: ^( OPEN $file_open_kind)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(828, 14);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_OPEN.NextNode(), root_1);

					DebugLocation(828, 20);
					adaptor.AddChild(root_1, stream_file_open_kind.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				stream_OPEN.Reset();
				stream_file_open_kind.Reset();
				DebugLocation(828, 38);
				adaptor.AddChild(root_0, stream_file_logical_name.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file_open_information", 90);
			LeaveRule("file_open_information", 90);
			LeaveRule_file_open_information();
			if (state.backtracking > 0) { Memoize(input, 90, file_open_information_StartIndex); }

		}
		DebugLocation(829, 4);
		} finally { DebugExitRule(GrammarFileName, "file_open_information"); }
		return retval;

	}
	// $ANTLR end "file_open_information"

	partial void EnterRule_file_type_definition();
	partial void LeaveRule_file_type_definition();

	// $ANTLR start "file_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:831:1: file_type_definition : FILE OF type_mark= name -> ^( FILE_TYPE_DEFINITION $type_mark) ;
	[GrammarRule("file_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> file_type_definition()
	{
		EnterRule_file_type_definition();
		EnterRule("file_type_definition", 91);
		TraceIn("file_type_definition", 91);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int file_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FILE322 = default(IToken);
		IToken OF323 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FILE322_tree = default(CommonTree);
		CommonTree OF323_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FILE=new RewriteRuleITokenStream(adaptor,"token FILE");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "file_type_definition");
		DebugLocation(831, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 91)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:832:5: ( FILE OF type_mark= name -> ^( FILE_TYPE_DEFINITION $type_mark) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:832:9: FILE OF type_mark= name
			{
			DebugLocation(832, 9);
			FILE322=(IToken)Match(input,FILE,Follow._FILE_in_file_type_definition8092); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FILE.Add(FILE322);

			DebugLocation(832, 14);
			OF323=(IToken)Match(input,OF,Follow._OF_in_file_type_definition8094); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF323);

			DebugLocation(832, 26);
			PushFollow(Follow._name_in_file_type_definition8098);
			type_mark=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(type_mark.Tree);


			{
			// AST REWRITE
			// elements: type_mark
			// token labels: 
			// rule labels: retval, type_mark
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_type_mark=new RewriteRuleSubtreeStream(adaptor,"rule type_mark",type_mark!=null?type_mark.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 833:9: -> ^( FILE_TYPE_DEFINITION $type_mark)
			{
				DebugLocation(833, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:833:12: ^( FILE_TYPE_DEFINITION $type_mark)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(833, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FILE_TYPE_DEFINITION, "FILE_TYPE_DEFINITION"), root_1);

				DebugLocation(833, 37);
				adaptor.AddChild(root_1, stream_type_mark.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file_type_definition", 91);
			LeaveRule("file_type_definition", 91);
			LeaveRule_file_type_definition();
			if (state.backtracking > 0) { Memoize(input, 91, file_type_definition_StartIndex); }

		}
		DebugLocation(834, 4);
		} finally { DebugExitRule(GrammarFileName, "file_type_definition"); }
		return retval;

	}
	// $ANTLR end "file_type_definition"

	partial void EnterRule_formal_part();
	partial void LeaveRule_formal_part();

	// $ANTLR start "formal_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:843:1: formal_part : name ;
	[GrammarRule("formal_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> formal_part()
	{
		EnterRule_formal_part();
		EnterRule("formal_part", 92);
		TraceIn("formal_part", 92);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int formal_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name324 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "formal_part");
		DebugLocation(843, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 92)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:844:5: ( name )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:844:9: name
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(844, 9);
			PushFollow(Follow._name_in_formal_part8143);
			name324=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, name324.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formal_part", 92);
			LeaveRule("formal_part", 92);
			LeaveRule_formal_part();
			if (state.backtracking > 0) { Memoize(input, 92, formal_part_StartIndex); }

		}
		DebugLocation(845, 4);
		} finally { DebugExitRule(GrammarFileName, "formal_part"); }
		return retval;

	}
	// $ANTLR end "formal_part"

	partial void EnterRule_full_type_declaration();
	partial void LeaveRule_full_type_declaration();

	// $ANTLR start "full_type_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:847:1: full_type_declaration : TYPE identifier IS type_definition SEMI -> ^( FULL_TYPE_DECLARATION identifier type_definition ) ;
	[GrammarRule("full_type_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> full_type_declaration()
	{
		EnterRule_full_type_declaration();
		EnterRule("full_type_declaration", 93);
		TraceIn("full_type_declaration", 93);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int full_type_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken TYPE325 = default(IToken);
		IToken IS327 = default(IToken);
		IToken SEMI329 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier326 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_definition328 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree TYPE325_tree = default(CommonTree);
		CommonTree IS327_tree = default(CommonTree);
		CommonTree SEMI329_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_type_definition=new RewriteRuleSubtreeStream(adaptor,"rule type_definition");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "full_type_declaration");
		DebugLocation(847, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 93)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:848:5: ( TYPE identifier IS type_definition SEMI -> ^( FULL_TYPE_DECLARATION identifier type_definition ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:848:9: TYPE identifier IS type_definition SEMI
			{
			DebugLocation(848, 9);
			TYPE325=(IToken)Match(input,TYPE,Follow._TYPE_in_full_type_declaration8162); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE325);

			DebugLocation(848, 14);
			PushFollow(Follow._identifier_in_full_type_declaration8164);
			identifier326=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier326.Tree);
			DebugLocation(848, 25);
			IS327=(IToken)Match(input,IS,Follow._IS_in_full_type_declaration8166); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS327);

			DebugLocation(848, 28);
			PushFollow(Follow._type_definition_in_full_type_declaration8168);
			type_definition328=type_definition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_definition.Add(type_definition328.Tree);
			DebugLocation(848, 44);
			SEMI329=(IToken)Match(input,SEMI,Follow._SEMI_in_full_type_declaration8170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI329);



			{
			// AST REWRITE
			// elements: identifier, type_definition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 849:9: -> ^( FULL_TYPE_DECLARATION identifier type_definition )
			{
				DebugLocation(849, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:849:12: ^( FULL_TYPE_DECLARATION identifier type_definition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(849, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FULL_TYPE_DECLARATION, "FULL_TYPE_DECLARATION"), root_1);

				DebugLocation(849, 37);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(849, 48);
				adaptor.AddChild(root_1, stream_type_definition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("full_type_declaration", 93);
			LeaveRule("full_type_declaration", 93);
			LeaveRule_full_type_declaration();
			if (state.backtracking > 0) { Memoize(input, 93, full_type_declaration_StartIndex); }

		}
		DebugLocation(850, 4);
		} finally { DebugExitRule(GrammarFileName, "full_type_declaration"); }
		return retval;

	}
	// $ANTLR end "full_type_declaration"

	partial void EnterRule_generate_statement();
	partial void LeaveRule_generate_statement();

	// $ANTLR start "generate_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:853:1: generate_statement : generation_scheme GENERATE ( ( block_declarative_item )* BEGIN )? ( concurrent_statement )* END GENERATE ( end_identifier )? SEMI -> ^( GENERATE generation_scheme ( block_declarative_item )* ( concurrent_statement )* ( end_identifier )? ) ;
	[GrammarRule("generate_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> generate_statement()
	{
		EnterRule_generate_statement();
		EnterRule("generate_statement", 94);
		TraceIn("generate_statement", 94);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int generate_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GENERATE331 = default(IToken);
		IToken BEGIN333 = default(IToken);
		IToken END335 = default(IToken);
		IToken GENERATE336 = default(IToken);
		IToken SEMI338 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> generation_scheme330 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> block_declarative_item332 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> concurrent_statement334 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier337 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GENERATE331_tree = default(CommonTree);
		CommonTree BEGIN333_tree = default(CommonTree);
		CommonTree END335_tree = default(CommonTree);
		CommonTree GENERATE336_tree = default(CommonTree);
		CommonTree SEMI338_tree = default(CommonTree);
		RewriteRuleITokenStream stream_GENERATE=new RewriteRuleITokenStream(adaptor,"token GENERATE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_generation_scheme=new RewriteRuleSubtreeStream(adaptor,"rule generation_scheme");
		RewriteRuleSubtreeStream stream_concurrent_statement=new RewriteRuleSubtreeStream(adaptor,"rule concurrent_statement");
		RewriteRuleSubtreeStream stream_block_declarative_item=new RewriteRuleSubtreeStream(adaptor,"rule block_declarative_item");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		try { DebugEnterRule(GrammarFileName, "generate_statement");
		DebugLocation(853, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 94)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:854:5: ( generation_scheme GENERATE ( ( block_declarative_item )* BEGIN )? ( concurrent_statement )* END GENERATE ( end_identifier )? SEMI -> ^( GENERATE generation_scheme ( block_declarative_item )* ( concurrent_statement )* ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:854:9: generation_scheme GENERATE ( ( block_declarative_item )* BEGIN )? ( concurrent_statement )* END GENERATE ( end_identifier )? SEMI
			{
			DebugLocation(854, 9);
			PushFollow(Follow._generation_scheme_in_generate_statement8210);
			generation_scheme330=generation_scheme();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_generation_scheme.Add(generation_scheme330.Tree);
			DebugLocation(855, 9);
			GENERATE331=(IToken)Match(input,GENERATE,Follow._GENERATE_in_generate_statement8220); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GENERATE.Add(GENERATE331);

			DebugLocation(856, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:856:9: ( ( block_declarative_item )* BEGIN )?
			int alt111=2;
			try { DebugEnterSubRule(111);
			try { DebugEnterDecision(111, false);
			int LA111_0 = input.LA(1);

			if ((LA111_0==ALIAS||LA111_0==ATTRIBUTE||LA111_0==BEGIN||LA111_0==COMPONENT||LA111_0==CONSTANT||LA111_0==DISCONNECT||LA111_0==FILE||LA111_0==FOR||LA111_0==FUNCTION||LA111_0==GROUP||LA111_0==IMPURE||LA111_0==PROCEDURE||LA111_0==PURE||(LA111_0>=SHARED && LA111_0<=SIGNAL)||LA111_0==SUBTYPE||LA111_0==TYPE||LA111_0==USE||LA111_0==VARIABLE))
			{
				alt111 = 1;
			}
			} finally { DebugExitDecision(111); }
			switch (alt111)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:856:11: ( block_declarative_item )* BEGIN
				{
				DebugLocation(856, 11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:856:11: ( block_declarative_item )*
				try { DebugEnterSubRule(110);
				while (true)
				{
					int alt110=2;
					try { DebugEnterDecision(110, false);
					int LA110_0 = input.LA(1);

					if ((LA110_0==ALIAS||LA110_0==ATTRIBUTE||LA110_0==COMPONENT||LA110_0==CONSTANT||LA110_0==DISCONNECT||LA110_0==FILE||LA110_0==FOR||LA110_0==FUNCTION||LA110_0==GROUP||LA110_0==IMPURE||LA110_0==PROCEDURE||LA110_0==PURE||(LA110_0>=SHARED && LA110_0<=SIGNAL)||LA110_0==SUBTYPE||LA110_0==TYPE||LA110_0==USE||LA110_0==VARIABLE))
					{
						alt110 = 1;
					}


					} finally { DebugExitDecision(110); }
					switch ( alt110 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:856:11: block_declarative_item
						{
						DebugLocation(856, 11);
						PushFollow(Follow._block_declarative_item_in_generate_statement8232);
						block_declarative_item332=block_declarative_item();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_block_declarative_item.Add(block_declarative_item332.Tree);

						}
						break;

					default:
						goto loop110;
					}
				}

				loop110:
					;

				} finally { DebugExitSubRule(110); }

				DebugLocation(856, 35);
				BEGIN333=(IToken)Match(input,BEGIN,Follow._BEGIN_in_generate_statement8235); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BEGIN.Add(BEGIN333);


				}
				break;

			}
			} finally { DebugExitSubRule(111); }

			DebugLocation(857, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:857:9: ( concurrent_statement )*
			try { DebugEnterSubRule(112);
			while (true)
			{
				int alt112=2;
				try { DebugEnterDecision(112, false);
				int LA112_0 = input.LA(1);

				if ((LA112_0==ASSERT||LA112_0==BASIC_IDENTIFIER||LA112_0==EXTENDED_IDENTIFIER||LA112_0==LPAREN||LA112_0==POSTPONED||LA112_0==PROCESS||LA112_0==STRING_LITERAL||LA112_0==WITH))
				{
					alt112 = 1;
				}


				} finally { DebugExitDecision(112); }
				switch ( alt112 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:857:9: concurrent_statement
					{
					DebugLocation(857, 9);
					PushFollow(Follow._concurrent_statement_in_generate_statement8248);
					concurrent_statement334=concurrent_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_concurrent_statement.Add(concurrent_statement334.Tree);

					}
					break;

				default:
					goto loop112;
				}
			}

			loop112:
				;

			} finally { DebugExitSubRule(112); }

			DebugLocation(858, 9);
			END335=(IToken)Match(input,END,Follow._END_in_generate_statement8259); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END335);

			DebugLocation(858, 13);
			GENERATE336=(IToken)Match(input,GENERATE,Follow._GENERATE_in_generate_statement8261); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GENERATE.Add(GENERATE336);

			DebugLocation(858, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:858:22: ( end_identifier )?
			int alt113=2;
			try { DebugEnterSubRule(113);
			try { DebugEnterDecision(113, false);
			int LA113_0 = input.LA(1);

			if ((LA113_0==BASIC_IDENTIFIER||LA113_0==EXTENDED_IDENTIFIER))
			{
				alt113 = 1;
			}
			} finally { DebugExitDecision(113); }
			switch (alt113)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:858:22: end_identifier
				{
				DebugLocation(858, 22);
				PushFollow(Follow._end_identifier_in_generate_statement8263);
				end_identifier337=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier337.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(113); }

			DebugLocation(858, 38);
			SEMI338=(IToken)Match(input,SEMI,Follow._SEMI_in_generate_statement8266); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI338);



			{
			// AST REWRITE
			// elements: end_identifier, generation_scheme, concurrent_statement, GENERATE, block_declarative_item
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 859:9: -> ^( GENERATE generation_scheme ( block_declarative_item )* ( concurrent_statement )* ( end_identifier )? )
			{
				DebugLocation(859, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:859:12: ^( GENERATE generation_scheme ( block_declarative_item )* ( concurrent_statement )* ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(859, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_GENERATE.NextNode(), root_1);

				DebugLocation(859, 24);
				adaptor.AddChild(root_1, stream_generation_scheme.NextTree());
				DebugLocation(859, 42);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:859:42: ( block_declarative_item )*
				while ( stream_block_declarative_item.HasNext )
				{
					DebugLocation(859, 42);
					adaptor.AddChild(root_1, stream_block_declarative_item.NextTree());

				}
				stream_block_declarative_item.Reset();
				DebugLocation(859, 66);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:859:66: ( concurrent_statement )*
				while ( stream_concurrent_statement.HasNext )
				{
					DebugLocation(859, 66);
					adaptor.AddChild(root_1, stream_concurrent_statement.NextTree());

				}
				stream_concurrent_statement.Reset();
				DebugLocation(859, 88);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:859:88: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(859, 88);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generate_statement", 94);
			LeaveRule("generate_statement", 94);
			LeaveRule_generate_statement();
			if (state.backtracking > 0) { Memoize(input, 94, generate_statement_StartIndex); }

		}
		DebugLocation(860, 4);
		} finally { DebugExitRule(GrammarFileName, "generate_statement"); }
		return retval;

	}
	// $ANTLR end "generate_statement"

	partial void EnterRule_generation_scheme();
	partial void LeaveRule_generation_scheme();

	// $ANTLR start "generation_scheme"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:862:1: generation_scheme : ( FOR generate_parameter_specification= parameter_specification | IF condition );
	[GrammarRule("generation_scheme")]
	private AstParserRuleReturnScope<CommonTree, IToken> generation_scheme()
	{
		EnterRule_generation_scheme();
		EnterRule("generation_scheme", 95);
		TraceIn("generation_scheme", 95);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int generation_scheme_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FOR339 = default(IToken);
		IToken IF340 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> generate_parameter_specification = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition341 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR339_tree = default(CommonTree);
		CommonTree IF340_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "generation_scheme");
		DebugLocation(862, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 95)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:863:5: ( FOR generate_parameter_specification= parameter_specification | IF condition )
			int alt114=2;
			try { DebugEnterDecision(114, false);
			int LA114_0 = input.LA(1);

			if ((LA114_0==FOR))
			{
				alt114 = 1;
			}
			else if ((LA114_0==IF))
			{
				alt114 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 114, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(114); }
			switch (alt114)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:863:9: FOR generate_parameter_specification= parameter_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(863, 9);
				FOR339=(IToken)Match(input,FOR,Follow._FOR_in_generation_scheme8312); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FOR339_tree = (CommonTree)adaptor.Create(FOR339);
				adaptor.AddChild(root_0, FOR339_tree);
				}
				DebugLocation(863, 45);
				PushFollow(Follow._parameter_specification_in_generation_scheme8316);
				generate_parameter_specification=parameter_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, generate_parameter_specification.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:864:9: IF condition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(864, 9);
				IF340=(IToken)Match(input,IF,Follow._IF_in_generation_scheme8326); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IF340_tree = (CommonTree)adaptor.Create(IF340);
				adaptor.AddChild(root_0, IF340_tree);
				}
				DebugLocation(864, 12);
				PushFollow(Follow._condition_in_generation_scheme8328);
				condition341=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, condition341.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generation_scheme", 95);
			LeaveRule("generation_scheme", 95);
			LeaveRule_generation_scheme();
			if (state.backtracking > 0) { Memoize(input, 95, generation_scheme_StartIndex); }

		}
		DebugLocation(865, 4);
		} finally { DebugExitRule(GrammarFileName, "generation_scheme"); }
		return retval;

	}
	// $ANTLR end "generation_scheme"

	partial void EnterRule_generic_clause();
	partial void LeaveRule_generic_clause();

	// $ANTLR start "generic_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:867:1: generic_clause : GENERIC LPAREN generic_interface_list RPAREN SEMI -> ^( GENERIC generic_interface_list ) ;
	[GrammarRule("generic_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> generic_clause()
	{
		EnterRule_generic_clause();
		EnterRule("generic_clause", 96);
		TraceIn("generic_clause", 96);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int generic_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GENERIC342 = default(IToken);
		IToken LPAREN343 = default(IToken);
		IToken RPAREN345 = default(IToken);
		IToken SEMI346 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> generic_interface_list344 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GENERIC342_tree = default(CommonTree);
		CommonTree LPAREN343_tree = default(CommonTree);
		CommonTree RPAREN345_tree = default(CommonTree);
		CommonTree SEMI346_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_GENERIC=new RewriteRuleITokenStream(adaptor,"token GENERIC");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_generic_interface_list=new RewriteRuleSubtreeStream(adaptor,"rule generic_interface_list");
		try { DebugEnterRule(GrammarFileName, "generic_clause");
		DebugLocation(867, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 96)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:868:5: ( GENERIC LPAREN generic_interface_list RPAREN SEMI -> ^( GENERIC generic_interface_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:868:9: GENERIC LPAREN generic_interface_list RPAREN SEMI
			{
			DebugLocation(868, 9);
			GENERIC342=(IToken)Match(input,GENERIC,Follow._GENERIC_in_generic_clause8347); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GENERIC.Add(GENERIC342);

			DebugLocation(868, 17);
			LPAREN343=(IToken)Match(input,LPAREN,Follow._LPAREN_in_generic_clause8349); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN343);

			DebugLocation(868, 24);
			PushFollow(Follow._generic_interface_list_in_generic_clause8351);
			generic_interface_list344=generic_interface_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_generic_interface_list.Add(generic_interface_list344.Tree);
			DebugLocation(868, 47);
			RPAREN345=(IToken)Match(input,RPAREN,Follow._RPAREN_in_generic_clause8353); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN345);

			DebugLocation(868, 54);
			SEMI346=(IToken)Match(input,SEMI,Follow._SEMI_in_generic_clause8355); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI346);



			{
			// AST REWRITE
			// elements: generic_interface_list, GENERIC
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 869:9: -> ^( GENERIC generic_interface_list )
			{
				DebugLocation(869, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:869:12: ^( GENERIC generic_interface_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(869, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_GENERIC.NextNode(), root_1);

				DebugLocation(869, 23);
				adaptor.AddChild(root_1, stream_generic_interface_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generic_clause", 96);
			LeaveRule("generic_clause", 96);
			LeaveRule_generic_clause();
			if (state.backtracking > 0) { Memoize(input, 96, generic_clause_StartIndex); }

		}
		DebugLocation(870, 4);
		} finally { DebugExitRule(GrammarFileName, "generic_clause"); }
		return retval;

	}
	// $ANTLR end "generic_clause"

	partial void EnterRule_generic_interface_list();
	partial void LeaveRule_generic_interface_list();

	// $ANTLR start "generic_interface_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:872:1: generic_interface_list : interface_constant_declaration_optional_class ( SEMI interface_constant_declaration_optional_class )* -> ( interface_constant_declaration_optional_class )+ ;
	[GrammarRule("generic_interface_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> generic_interface_list()
	{
		EnterRule_generic_interface_list();
		EnterRule("generic_interface_list", 97);
		TraceIn("generic_interface_list", 97);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int generic_interface_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI348 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration_optional_class347 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration_optional_class349 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI348_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_interface_constant_declaration_optional_class=new RewriteRuleSubtreeStream(adaptor,"rule interface_constant_declaration_optional_class");
		try { DebugEnterRule(GrammarFileName, "generic_interface_list");
		DebugLocation(872, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 97)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:873:5: ( interface_constant_declaration_optional_class ( SEMI interface_constant_declaration_optional_class )* -> ( interface_constant_declaration_optional_class )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:873:9: interface_constant_declaration_optional_class ( SEMI interface_constant_declaration_optional_class )*
			{
			DebugLocation(873, 9);
			PushFollow(Follow._interface_constant_declaration_optional_class_in_generic_interface_list8392);
			interface_constant_declaration_optional_class347=interface_constant_declaration_optional_class();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_interface_constant_declaration_optional_class.Add(interface_constant_declaration_optional_class347.Tree);
			DebugLocation(874, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:874:9: ( SEMI interface_constant_declaration_optional_class )*
			try { DebugEnterSubRule(115);
			while (true)
			{
				int alt115=2;
				try { DebugEnterDecision(115, false);
				int LA115_0 = input.LA(1);

				if ((LA115_0==SEMI))
				{
					alt115 = 1;
				}


				} finally { DebugExitDecision(115); }
				switch ( alt115 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:874:11: SEMI interface_constant_declaration_optional_class
					{
					DebugLocation(874, 11);
					SEMI348=(IToken)Match(input,SEMI,Follow._SEMI_in_generic_interface_list8404); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI348);

					DebugLocation(874, 16);
					PushFollow(Follow._interface_constant_declaration_optional_class_in_generic_interface_list8406);
					interface_constant_declaration_optional_class349=interface_constant_declaration_optional_class();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_interface_constant_declaration_optional_class.Add(interface_constant_declaration_optional_class349.Tree);

					}
					break;

				default:
					goto loop115;
				}
			}

			loop115:
				;

			} finally { DebugExitSubRule(115); }



			{
			// AST REWRITE
			// elements: interface_constant_declaration_optional_class
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 875:9: -> ( interface_constant_declaration_optional_class )+
			{
				DebugLocation(875, 12);
				if (!(stream_interface_constant_declaration_optional_class.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_interface_constant_declaration_optional_class.HasNext )
				{
					DebugLocation(875, 12);
					adaptor.AddChild(root_0, stream_interface_constant_declaration_optional_class.NextTree());

				}
				stream_interface_constant_declaration_optional_class.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generic_interface_list", 97);
			LeaveRule("generic_interface_list", 97);
			LeaveRule_generic_interface_list();
			if (state.backtracking > 0) { Memoize(input, 97, generic_interface_list_StartIndex); }

		}
		DebugLocation(876, 4);
		} finally { DebugExitRule(GrammarFileName, "generic_interface_list"); }
		return retval;

	}
	// $ANTLR end "generic_interface_list"

	partial void EnterRule_generic_map_aspect();
	partial void LeaveRule_generic_map_aspect();

	// $ANTLR start "generic_map_aspect"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:878:1: generic_map_aspect : GENERIC MAP LPAREN generic_association_list= association_list RPAREN -> ^( GENERIC_MAP $generic_association_list) ;
	[GrammarRule("generic_map_aspect")]
	private AstParserRuleReturnScope<CommonTree, IToken> generic_map_aspect()
	{
		EnterRule_generic_map_aspect();
		EnterRule("generic_map_aspect", 98);
		TraceIn("generic_map_aspect", 98);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int generic_map_aspect_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GENERIC350 = default(IToken);
		IToken MAP351 = default(IToken);
		IToken LPAREN352 = default(IToken);
		IToken RPAREN353 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> generic_association_list = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GENERIC350_tree = default(CommonTree);
		CommonTree MAP351_tree = default(CommonTree);
		CommonTree LPAREN352_tree = default(CommonTree);
		CommonTree RPAREN353_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_GENERIC=new RewriteRuleITokenStream(adaptor,"token GENERIC");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_MAP=new RewriteRuleITokenStream(adaptor,"token MAP");
		RewriteRuleSubtreeStream stream_association_list=new RewriteRuleSubtreeStream(adaptor,"rule association_list");
		try { DebugEnterRule(GrammarFileName, "generic_map_aspect");
		DebugLocation(878, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 98)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:879:5: ( GENERIC MAP LPAREN generic_association_list= association_list RPAREN -> ^( GENERIC_MAP $generic_association_list) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:879:9: GENERIC MAP LPAREN generic_association_list= association_list RPAREN
			{
			DebugLocation(879, 9);
			GENERIC350=(IToken)Match(input,GENERIC,Follow._GENERIC_in_generic_map_aspect8441); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GENERIC.Add(GENERIC350);

			DebugLocation(879, 17);
			MAP351=(IToken)Match(input,MAP,Follow._MAP_in_generic_map_aspect8443); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_MAP.Add(MAP351);

			DebugLocation(879, 21);
			LPAREN352=(IToken)Match(input,LPAREN,Follow._LPAREN_in_generic_map_aspect8445); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN352);

			DebugLocation(879, 52);
			PushFollow(Follow._association_list_in_generic_map_aspect8449);
			generic_association_list=association_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_association_list.Add(generic_association_list.Tree);
			DebugLocation(879, 70);
			RPAREN353=(IToken)Match(input,RPAREN,Follow._RPAREN_in_generic_map_aspect8451); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN353);



			{
			// AST REWRITE
			// elements: generic_association_list
			// token labels: 
			// rule labels: retval, generic_association_list
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_generic_association_list=new RewriteRuleSubtreeStream(adaptor,"rule generic_association_list",generic_association_list!=null?generic_association_list.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 880:9: -> ^( GENERIC_MAP $generic_association_list)
			{
				DebugLocation(880, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:880:12: ^( GENERIC_MAP $generic_association_list)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(880, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GENERIC_MAP, "GENERIC_MAP"), root_1);

				DebugLocation(880, 28);
				adaptor.AddChild(root_1, stream_generic_association_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generic_map_aspect", 98);
			LeaveRule("generic_map_aspect", 98);
			LeaveRule_generic_map_aspect();
			if (state.backtracking > 0) { Memoize(input, 98, generic_map_aspect_StartIndex); }

		}
		DebugLocation(881, 4);
		} finally { DebugExitRule(GrammarFileName, "generic_map_aspect"); }
		return retval;

	}
	// $ANTLR end "generic_map_aspect"

	partial void EnterRule_group_constituent();
	partial void LeaveRule_group_constituent();

	// $ANTLR start "group_constituent"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:883:1: group_constituent : ( name | CHARACTER_LITERAL );
	[GrammarRule("group_constituent")]
	private AstParserRuleReturnScope<CommonTree, IToken> group_constituent()
	{
		EnterRule_group_constituent();
		EnterRule("group_constituent", 99);
		TraceIn("group_constituent", 99);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int group_constituent_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CHARACTER_LITERAL355 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> name354 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CHARACTER_LITERAL355_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "group_constituent");
		DebugLocation(883, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 99)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:884:5: ( name | CHARACTER_LITERAL )
			int alt116=2;
			try { DebugEnterDecision(116, false);
			int LA116_0 = input.LA(1);

			if ((LA116_0==BASIC_IDENTIFIER||LA116_0==EXTENDED_IDENTIFIER||LA116_0==STRING_LITERAL))
			{
				alt116 = 1;
			}
			else if ((LA116_0==CHARACTER_LITERAL))
			{
				alt116 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 116, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(116); }
			switch (alt116)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:884:9: name
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(884, 9);
				PushFollow(Follow._name_in_group_constituent8489);
				name354=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name354.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:885:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(885, 9);
				CHARACTER_LITERAL355=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_group_constituent8499); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL355_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL355);
				adaptor.AddChild(root_0, CHARACTER_LITERAL355_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group_constituent", 99);
			LeaveRule("group_constituent", 99);
			LeaveRule_group_constituent();
			if (state.backtracking > 0) { Memoize(input, 99, group_constituent_StartIndex); }

		}
		DebugLocation(886, 4);
		} finally { DebugExitRule(GrammarFileName, "group_constituent"); }
		return retval;

	}
	// $ANTLR end "group_constituent"

	partial void EnterRule_group_constituent_list();
	partial void LeaveRule_group_constituent_list();

	// $ANTLR start "group_constituent_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:888:1: group_constituent_list : group_constituent ( COMMA group_constituent )* -> group_constituent ;
	[GrammarRule("group_constituent_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> group_constituent_list()
	{
		EnterRule_group_constituent_list();
		EnterRule("group_constituent_list", 100);
		TraceIn("group_constituent_list", 100);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int group_constituent_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA357 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> group_constituent356 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_constituent358 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA357_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_group_constituent=new RewriteRuleSubtreeStream(adaptor,"rule group_constituent");
		try { DebugEnterRule(GrammarFileName, "group_constituent_list");
		DebugLocation(888, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 100)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:889:5: ( group_constituent ( COMMA group_constituent )* -> group_constituent )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:889:9: group_constituent ( COMMA group_constituent )*
			{
			DebugLocation(889, 9);
			PushFollow(Follow._group_constituent_in_group_constituent_list8518);
			group_constituent356=group_constituent();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_group_constituent.Add(group_constituent356.Tree);
			DebugLocation(889, 27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:889:27: ( COMMA group_constituent )*
			try { DebugEnterSubRule(117);
			while (true)
			{
				int alt117=2;
				try { DebugEnterDecision(117, false);
				int LA117_0 = input.LA(1);

				if ((LA117_0==COMMA))
				{
					alt117 = 1;
				}


				} finally { DebugExitDecision(117); }
				switch ( alt117 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:889:29: COMMA group_constituent
					{
					DebugLocation(889, 29);
					COMMA357=(IToken)Match(input,COMMA,Follow._COMMA_in_group_constituent_list8522); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA357);

					DebugLocation(889, 35);
					PushFollow(Follow._group_constituent_in_group_constituent_list8524);
					group_constituent358=group_constituent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_group_constituent.Add(group_constituent358.Tree);

					}
					break;

				default:
					goto loop117;
				}
			}

			loop117:
				;

			} finally { DebugExitSubRule(117); }



			{
			// AST REWRITE
			// elements: group_constituent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 890:9: -> group_constituent
			{
				DebugLocation(890, 12);
				adaptor.AddChild(root_0, stream_group_constituent.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group_constituent_list", 100);
			LeaveRule("group_constituent_list", 100);
			LeaveRule_group_constituent_list();
			if (state.backtracking > 0) { Memoize(input, 100, group_constituent_list_StartIndex); }

		}
		DebugLocation(891, 4);
		} finally { DebugExitRule(GrammarFileName, "group_constituent_list"); }
		return retval;

	}
	// $ANTLR end "group_constituent_list"

	partial void EnterRule_group_declaration();
	partial void LeaveRule_group_declaration();

	// $ANTLR start "group_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:893:1: group_declaration : GROUP identifier COLON group_template_name= name_without_parens LPAREN group_constituent_list RPAREN SEMI -> ^( GROUP_DECLARATION identifier $group_template_name group_constituent_list ) ;
	[GrammarRule("group_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> group_declaration()
	{
		EnterRule_group_declaration();
		EnterRule("group_declaration", 101);
		TraceIn("group_declaration", 101);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int group_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GROUP359 = default(IToken);
		IToken COLON361 = default(IToken);
		IToken LPAREN362 = default(IToken);
		IToken RPAREN364 = default(IToken);
		IToken SEMI365 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_name = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier360 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_constituent_list363 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GROUP359_tree = default(CommonTree);
		CommonTree COLON361_tree = default(CommonTree);
		CommonTree LPAREN362_tree = default(CommonTree);
		CommonTree RPAREN364_tree = default(CommonTree);
		CommonTree SEMI365_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_GROUP=new RewriteRuleITokenStream(adaptor,"token GROUP");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_group_constituent_list=new RewriteRuleSubtreeStream(adaptor,"rule group_constituent_list");
		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "group_declaration");
		DebugLocation(893, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 101)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:894:5: ( GROUP identifier COLON group_template_name= name_without_parens LPAREN group_constituent_list RPAREN SEMI -> ^( GROUP_DECLARATION identifier $group_template_name group_constituent_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:894:9: GROUP identifier COLON group_template_name= name_without_parens LPAREN group_constituent_list RPAREN SEMI
			{
			DebugLocation(894, 9);
			GROUP359=(IToken)Match(input,GROUP,Follow._GROUP_in_group_declaration8558); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GROUP.Add(GROUP359);

			DebugLocation(894, 15);
			PushFollow(Follow._identifier_in_group_declaration8560);
			identifier360=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier360.Tree);
			DebugLocation(894, 26);
			COLON361=(IToken)Match(input,COLON,Follow._COLON_in_group_declaration8562); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON361);

			DebugLocation(894, 51);
			PushFollow(Follow._name_without_parens_in_group_declaration8566);
			group_template_name=name_without_parens();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_without_parens.Add(group_template_name.Tree);
			DebugLocation(895, 9);
			LPAREN362=(IToken)Match(input,LPAREN,Follow._LPAREN_in_group_declaration8576); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN362);

			DebugLocation(895, 16);
			PushFollow(Follow._group_constituent_list_in_group_declaration8578);
			group_constituent_list363=group_constituent_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_group_constituent_list.Add(group_constituent_list363.Tree);
			DebugLocation(895, 39);
			RPAREN364=(IToken)Match(input,RPAREN,Follow._RPAREN_in_group_declaration8580); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN364);

			DebugLocation(895, 46);
			SEMI365=(IToken)Match(input,SEMI,Follow._SEMI_in_group_declaration8582); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI365);



			{
			// AST REWRITE
			// elements: identifier, group_template_name, group_constituent_list
			// token labels: 
			// rule labels: retval, group_template_name
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_group_template_name=new RewriteRuleSubtreeStream(adaptor,"rule group_template_name",group_template_name!=null?group_template_name.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 896:9: -> ^( GROUP_DECLARATION identifier $group_template_name group_constituent_list )
			{
				DebugLocation(896, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:896:12: ^( GROUP_DECLARATION identifier $group_template_name group_constituent_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(896, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GROUP_DECLARATION, "GROUP_DECLARATION"), root_1);

				DebugLocation(896, 33);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(896, 45);
				adaptor.AddChild(root_1, stream_group_template_name.NextTree());
				DebugLocation(896, 65);
				adaptor.AddChild(root_1, stream_group_constituent_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group_declaration", 101);
			LeaveRule("group_declaration", 101);
			LeaveRule_group_declaration();
			if (state.backtracking > 0) { Memoize(input, 101, group_declaration_StartIndex); }

		}
		DebugLocation(897, 4);
		} finally { DebugExitRule(GrammarFileName, "group_declaration"); }
		return retval;

	}
	// $ANTLR end "group_declaration"

	partial void EnterRule_group_template_declaration();
	partial void LeaveRule_group_template_declaration();

	// $ANTLR start "group_template_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:899:1: group_template_declaration : GROUP identifier IS LPAREN entity_class_entry_list RPAREN SEMI -> ^( GROUP_TEMPLATE_DECLARATION identifier entity_class_entry_list ) ;
	[GrammarRule("group_template_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration()
	{
		EnterRule_group_template_declaration();
		EnterRule("group_template_declaration", 102);
		TraceIn("group_template_declaration", 102);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int group_template_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GROUP366 = default(IToken);
		IToken IS368 = default(IToken);
		IToken LPAREN369 = default(IToken);
		IToken RPAREN371 = default(IToken);
		IToken SEMI372 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier367 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity_class_entry_list370 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GROUP366_tree = default(CommonTree);
		CommonTree IS368_tree = default(CommonTree);
		CommonTree LPAREN369_tree = default(CommonTree);
		CommonTree RPAREN371_tree = default(CommonTree);
		CommonTree SEMI372_tree = default(CommonTree);
		RewriteRuleITokenStream stream_GROUP=new RewriteRuleITokenStream(adaptor,"token GROUP");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_entity_class_entry_list=new RewriteRuleSubtreeStream(adaptor,"rule entity_class_entry_list");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "group_template_declaration");
		DebugLocation(899, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 102)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:900:5: ( GROUP identifier IS LPAREN entity_class_entry_list RPAREN SEMI -> ^( GROUP_TEMPLATE_DECLARATION identifier entity_class_entry_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:900:9: GROUP identifier IS LPAREN entity_class_entry_list RPAREN SEMI
			{
			DebugLocation(900, 9);
			GROUP366=(IToken)Match(input,GROUP,Follow._GROUP_in_group_template_declaration8624); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GROUP.Add(GROUP366);

			DebugLocation(900, 15);
			PushFollow(Follow._identifier_in_group_template_declaration8626);
			identifier367=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier367.Tree);
			DebugLocation(900, 26);
			IS368=(IToken)Match(input,IS,Follow._IS_in_group_template_declaration8628); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS368);

			DebugLocation(900, 29);
			LPAREN369=(IToken)Match(input,LPAREN,Follow._LPAREN_in_group_template_declaration8630); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN369);

			DebugLocation(900, 36);
			PushFollow(Follow._entity_class_entry_list_in_group_template_declaration8632);
			entity_class_entry_list370=entity_class_entry_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_entity_class_entry_list.Add(entity_class_entry_list370.Tree);
			DebugLocation(900, 60);
			RPAREN371=(IToken)Match(input,RPAREN,Follow._RPAREN_in_group_template_declaration8634); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN371);

			DebugLocation(900, 67);
			SEMI372=(IToken)Match(input,SEMI,Follow._SEMI_in_group_template_declaration8636); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI372);



			{
			// AST REWRITE
			// elements: identifier, entity_class_entry_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 901:9: -> ^( GROUP_TEMPLATE_DECLARATION identifier entity_class_entry_list )
			{
				DebugLocation(901, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:901:12: ^( GROUP_TEMPLATE_DECLARATION identifier entity_class_entry_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(901, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(GROUP_TEMPLATE_DECLARATION, "GROUP_TEMPLATE_DECLARATION"), root_1);

				DebugLocation(901, 42);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(901, 53);
				adaptor.AddChild(root_1, stream_entity_class_entry_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("group_template_declaration", 102);
			LeaveRule("group_template_declaration", 102);
			LeaveRule_group_template_declaration();
			if (state.backtracking > 0) { Memoize(input, 102, group_template_declaration_StartIndex); }

		}
		DebugLocation(902, 4);
		} finally { DebugExitRule(GrammarFileName, "group_template_declaration"); }
		return retval;

	}
	// $ANTLR end "group_template_declaration"

	partial void EnterRule_guarded_signal_specification();
	partial void LeaveRule_guarded_signal_specification();

	// $ANTLR start "guarded_signal_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:904:1: guarded_signal_specification : guarded_signal_list= signal_list COLON type_mark= name -> signal_list name ;
	[GrammarRule("guarded_signal_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> guarded_signal_specification()
	{
		EnterRule_guarded_signal_specification();
		EnterRule("guarded_signal_specification", 103);
		TraceIn("guarded_signal_specification", 103);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int guarded_signal_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON373 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> guarded_signal_list = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON373_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_signal_list=new RewriteRuleSubtreeStream(adaptor,"rule signal_list");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "guarded_signal_specification");
		DebugLocation(904, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 103)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:905:5: (guarded_signal_list= signal_list COLON type_mark= name -> signal_list name )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:905:9: guarded_signal_list= signal_list COLON type_mark= name
			{
			DebugLocation(905, 28);
			PushFollow(Follow._signal_list_in_guarded_signal_specification8677);
			guarded_signal_list=signal_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_signal_list.Add(guarded_signal_list.Tree);
			DebugLocation(905, 41);
			COLON373=(IToken)Match(input,COLON,Follow._COLON_in_guarded_signal_specification8679); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON373);

			DebugLocation(905, 56);
			PushFollow(Follow._name_in_guarded_signal_specification8683);
			type_mark=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(type_mark.Tree);


			{
			// AST REWRITE
			// elements: signal_list, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 906:9: -> signal_list name
			{
				DebugLocation(906, 12);
				adaptor.AddChild(root_0, stream_signal_list.NextTree());
				DebugLocation(906, 24);
				adaptor.AddChild(root_0, stream_name.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("guarded_signal_specification", 103);
			LeaveRule("guarded_signal_specification", 103);
			LeaveRule_guarded_signal_specification();
			if (state.backtracking > 0) { Memoize(input, 103, guarded_signal_specification_StartIndex); }

		}
		DebugLocation(907, 4);
		} finally { DebugExitRule(GrammarFileName, "guarded_signal_specification"); }
		return retval;

	}
	// $ANTLR end "guarded_signal_specification"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:909:1: identifier : ( BASIC_IDENTIFIER | EXTENDED_IDENTIFIER );
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 104);
		TraceIn("identifier", 104);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int identifier_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set374 = default(IToken);

		CommonTree set374_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(909, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 104)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:910:5: ( BASIC_IDENTIFIER | EXTENDED_IDENTIFIER )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(910, 5);

			set374=(IToken)input.LT(1);
			if (input.LA(1)==BASIC_IDENTIFIER||input.LA(1)==EXTENDED_IDENTIFIER)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set374));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 104);
			LeaveRule("identifier", 104);
			LeaveRule_identifier();
			if (state.backtracking > 0) { Memoize(input, 104, identifier_StartIndex); }

		}
		DebugLocation(912, 4);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_end_identifier();
	partial void LeaveRule_end_identifier();

	// $ANTLR start "end_identifier"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:913:2: end_identifier : identifier ;
	[GrammarRule("end_identifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> end_identifier()
	{
		EnterRule_end_identifier();
		EnterRule("end_identifier", 105);
		TraceIn("end_identifier", 105);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int end_identifier_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> identifier375 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "end_identifier");
		DebugLocation(913, 14);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 105)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:914:3: ( identifier )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:914:5: identifier
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(914, 5);
			PushFollow(Follow._identifier_in_end_identifier8741);
			identifier375=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, identifier375.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("end_identifier", 105);
			LeaveRule("end_identifier", 105);
			LeaveRule_end_identifier();
			if (state.backtracking > 0) { Memoize(input, 105, end_identifier_StartIndex); }

		}
		DebugLocation(914, 14);
		} finally { DebugExitRule(GrammarFileName, "end_identifier"); }
		return retval;

	}
	// $ANTLR end "end_identifier"

	partial void EnterRule_identifier_list();
	partial void LeaveRule_identifier_list();

	// $ANTLR start "identifier_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:916:1: identifier_list : identifier ( COMMA identifier )* -> ( identifier )+ ;
	[GrammarRule("identifier_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> identifier_list()
	{
		EnterRule_identifier_list();
		EnterRule("identifier_list", 106);
		TraceIn("identifier_list", 106);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int identifier_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA377 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier376 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier378 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA377_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "identifier_list");
		DebugLocation(916, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 106)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:917:5: ( identifier ( COMMA identifier )* -> ( identifier )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:917:9: identifier ( COMMA identifier )*
			{
			DebugLocation(917, 9);
			PushFollow(Follow._identifier_in_identifier_list8755);
			identifier376=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier376.Tree);
			DebugLocation(917, 20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:917:20: ( COMMA identifier )*
			try { DebugEnterSubRule(118);
			while (true)
			{
				int alt118=2;
				try { DebugEnterDecision(118, false);
				int LA118_0 = input.LA(1);

				if ((LA118_0==COMMA))
				{
					alt118 = 1;
				}


				} finally { DebugExitDecision(118); }
				switch ( alt118 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:917:22: COMMA identifier
					{
					DebugLocation(917, 22);
					COMMA377=(IToken)Match(input,COMMA,Follow._COMMA_in_identifier_list8759); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA377);

					DebugLocation(917, 28);
					PushFollow(Follow._identifier_in_identifier_list8761);
					identifier378=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier378.Tree);

					}
					break;

				default:
					goto loop118;
				}
			}

			loop118:
				;

			} finally { DebugExitSubRule(118); }



			{
			// AST REWRITE
			// elements: identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 918:9: -> ( identifier )+
			{
				DebugLocation(918, 12);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(918, 12);
					adaptor.AddChild(root_0, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier_list", 106);
			LeaveRule("identifier_list", 106);
			LeaveRule_identifier_list();
			if (state.backtracking > 0) { Memoize(input, 106, identifier_list_StartIndex); }

		}
		DebugLocation(919, 4);
		} finally { DebugExitRule(GrammarFileName, "identifier_list"); }
		return retval;

	}
	// $ANTLR end "identifier_list"

	partial void EnterRule_if_statement();
	partial void LeaveRule_if_statement();

	// $ANTLR start "if_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:922:1: if_statement : IF condition THEN sos= sequence_of_statements ( if_statement_elsif_part )* (isep= if_statement_else_part )? END IF ( end_identifier )? SEMI -> ^( IF condition ( $sos)? ( if_statement_elsif_part )* ( $isep)? ( end_identifier )? ) ;
	[GrammarRule("if_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> if_statement()
	{
		EnterRule_if_statement();
		EnterRule("if_statement", 107);
		TraceIn("if_statement", 107);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int if_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken IF379 = default(IToken);
		IToken THEN381 = default(IToken);
		IToken END383 = default(IToken);
		IToken IF384 = default(IToken);
		IToken SEMI386 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sos = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> isep = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition380 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> if_statement_elsif_part382 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier385 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IF379_tree = default(CommonTree);
		CommonTree THEN381_tree = default(CommonTree);
		CommonTree END383_tree = default(CommonTree);
		CommonTree IF384_tree = default(CommonTree);
		CommonTree SEMI386_tree = default(CommonTree);
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_if_statement_elsif_part=new RewriteRuleSubtreeStream(adaptor,"rule if_statement_elsif_part");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_if_statement_else_part=new RewriteRuleSubtreeStream(adaptor,"rule if_statement_else_part");
		RewriteRuleSubtreeStream stream_sequence_of_statements=new RewriteRuleSubtreeStream(adaptor,"rule sequence_of_statements");
		try { DebugEnterRule(GrammarFileName, "if_statement");
		DebugLocation(922, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 107)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:923:5: ( IF condition THEN sos= sequence_of_statements ( if_statement_elsif_part )* (isep= if_statement_else_part )? END IF ( end_identifier )? SEMI -> ^( IF condition ( $sos)? ( if_statement_elsif_part )* ( $isep)? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:923:9: IF condition THEN sos= sequence_of_statements ( if_statement_elsif_part )* (isep= if_statement_else_part )? END IF ( end_identifier )? SEMI
			{
			DebugLocation(923, 9);
			IF379=(IToken)Match(input,IF,Follow._IF_in_if_statement8797); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF379);

			DebugLocation(923, 12);
			PushFollow(Follow._condition_in_if_statement8799);
			condition380=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition380.Tree);
			DebugLocation(923, 22);
			THEN381=(IToken)Match(input,THEN,Follow._THEN_in_if_statement8801); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_THEN.Add(THEN381);

			DebugLocation(924, 12);
			PushFollow(Follow._sequence_of_statements_in_if_statement8813);
			sos=sequence_of_statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sequence_of_statements.Add(sos.Tree);
			DebugLocation(925, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:925:9: ( if_statement_elsif_part )*
			try { DebugEnterSubRule(119);
			while (true)
			{
				int alt119=2;
				try { DebugEnterDecision(119, false);
				int LA119_0 = input.LA(1);

				if ((LA119_0==ELSIF))
				{
					alt119 = 1;
				}


				} finally { DebugExitDecision(119); }
				switch ( alt119 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:925:9: if_statement_elsif_part
					{
					DebugLocation(925, 9);
					PushFollow(Follow._if_statement_elsif_part_in_if_statement8823);
					if_statement_elsif_part382=if_statement_elsif_part();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_if_statement_elsif_part.Add(if_statement_elsif_part382.Tree);

					}
					break;

				default:
					goto loop119;
				}
			}

			loop119:
				;

			} finally { DebugExitSubRule(119); }

			DebugLocation(926, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:926:13: (isep= if_statement_else_part )?
			int alt120=2;
			try { DebugEnterSubRule(120);
			try { DebugEnterDecision(120, false);
			int LA120_0 = input.LA(1);

			if ((LA120_0==ELSE))
			{
				alt120 = 1;
			}
			} finally { DebugExitDecision(120); }
			switch (alt120)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:926:13: isep= if_statement_else_part
				{
				DebugLocation(926, 13);
				PushFollow(Follow._if_statement_else_part_in_if_statement8836);
				isep=if_statement_else_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_if_statement_else_part.Add(isep.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(120); }

			DebugLocation(927, 9);
			END383=(IToken)Match(input,END,Follow._END_in_if_statement8847); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END383);

			DebugLocation(927, 13);
			IF384=(IToken)Match(input,IF,Follow._IF_in_if_statement8849); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF384);

			DebugLocation(927, 16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:927:16: ( end_identifier )?
			int alt121=2;
			try { DebugEnterSubRule(121);
			try { DebugEnterDecision(121, false);
			int LA121_0 = input.LA(1);

			if ((LA121_0==BASIC_IDENTIFIER||LA121_0==EXTENDED_IDENTIFIER))
			{
				alt121 = 1;
			}
			} finally { DebugExitDecision(121); }
			switch (alt121)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:927:16: end_identifier
				{
				DebugLocation(927, 16);
				PushFollow(Follow._end_identifier_in_if_statement8851);
				end_identifier385=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier385.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(121); }

			DebugLocation(927, 32);
			SEMI386=(IToken)Match(input,SEMI,Follow._SEMI_in_if_statement8854); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI386);



			{
			// AST REWRITE
			// elements: if_statement_elsif_part, condition, isep, IF, end_identifier, sos
			// token labels: 
			// rule labels: retval, isep, sos
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_isep=new RewriteRuleSubtreeStream(adaptor,"rule isep",isep!=null?isep.Tree:null);
			RewriteRuleSubtreeStream stream_sos=new RewriteRuleSubtreeStream(adaptor,"rule sos",sos!=null?sos.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 928:9: -> ^( IF condition ( $sos)? ( if_statement_elsif_part )* ( $isep)? ( end_identifier )? )
			{
				DebugLocation(928, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:928:12: ^( IF condition ( $sos)? ( if_statement_elsif_part )* ( $isep)? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(928, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(928, 18);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(928, 29);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:928:29: ( $sos)?
				if (stream_sos.HasNext)
				{
					DebugLocation(928, 29);
					adaptor.AddChild(root_1, stream_sos.NextTree());

				}
				stream_sos.Reset();
				DebugLocation(928, 34);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:928:34: ( if_statement_elsif_part )*
				while ( stream_if_statement_elsif_part.HasNext )
				{
					DebugLocation(928, 34);
					adaptor.AddChild(root_1, stream_if_statement_elsif_part.NextTree());

				}
				stream_if_statement_elsif_part.Reset();
				DebugLocation(928, 60);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:928:60: ( $isep)?
				if (stream_isep.HasNext)
				{
					DebugLocation(928, 60);
					adaptor.AddChild(root_1, stream_isep.NextTree());

				}
				stream_isep.Reset();
				DebugLocation(928, 66);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:928:66: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(928, 66);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if_statement", 107);
			LeaveRule("if_statement", 107);
			LeaveRule_if_statement();
			if (state.backtracking > 0) { Memoize(input, 107, if_statement_StartIndex); }

		}
		DebugLocation(929, 4);
		} finally { DebugExitRule(GrammarFileName, "if_statement"); }
		return retval;

	}
	// $ANTLR end "if_statement"

	partial void EnterRule_if_statement_elsif_part();
	partial void LeaveRule_if_statement_elsif_part();

	// $ANTLR start "if_statement_elsif_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:931:1: if_statement_elsif_part : ELSIF condition THEN sequence_of_statements -> ^( ELSIF condition ( sequence_of_statements )? ) ;
	[GrammarRule("if_statement_elsif_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> if_statement_elsif_part()
	{
		EnterRule_if_statement_elsif_part();
		EnterRule("if_statement_elsif_part", 108);
		TraceIn("if_statement_elsif_part", 108);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int if_statement_elsif_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ELSIF387 = default(IToken);
		IToken THEN389 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition388 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sequence_of_statements390 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ELSIF387_tree = default(CommonTree);
		CommonTree THEN389_tree = default(CommonTree);
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_ELSIF=new RewriteRuleITokenStream(adaptor,"token ELSIF");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_sequence_of_statements=new RewriteRuleSubtreeStream(adaptor,"rule sequence_of_statements");
		try { DebugEnterRule(GrammarFileName, "if_statement_elsif_part");
		DebugLocation(931, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 108)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:932:5: ( ELSIF condition THEN sequence_of_statements -> ^( ELSIF condition ( sequence_of_statements )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:932:9: ELSIF condition THEN sequence_of_statements
			{
			DebugLocation(932, 9);
			ELSIF387=(IToken)Match(input,ELSIF,Follow._ELSIF_in_if_statement_elsif_part8905); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSIF.Add(ELSIF387);

			DebugLocation(932, 15);
			PushFollow(Follow._condition_in_if_statement_elsif_part8907);
			condition388=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition388.Tree);
			DebugLocation(932, 25);
			THEN389=(IToken)Match(input,THEN,Follow._THEN_in_if_statement_elsif_part8909); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_THEN.Add(THEN389);

			DebugLocation(932, 30);
			PushFollow(Follow._sequence_of_statements_in_if_statement_elsif_part8911);
			sequence_of_statements390=sequence_of_statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sequence_of_statements.Add(sequence_of_statements390.Tree);


			{
			// AST REWRITE
			// elements: condition, ELSIF, sequence_of_statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 933:9: -> ^( ELSIF condition ( sequence_of_statements )? )
			{
				DebugLocation(933, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:933:12: ^( ELSIF condition ( sequence_of_statements )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(933, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ELSIF.NextNode(), root_1);

				DebugLocation(933, 21);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(933, 31);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:933:31: ( sequence_of_statements )?
				if (stream_sequence_of_statements.HasNext)
				{
					DebugLocation(933, 31);
					adaptor.AddChild(root_1, stream_sequence_of_statements.NextTree());

				}
				stream_sequence_of_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if_statement_elsif_part", 108);
			LeaveRule("if_statement_elsif_part", 108);
			LeaveRule_if_statement_elsif_part();
			if (state.backtracking > 0) { Memoize(input, 108, if_statement_elsif_part_StartIndex); }

		}
		DebugLocation(934, 4);
		} finally { DebugExitRule(GrammarFileName, "if_statement_elsif_part"); }
		return retval;

	}
	// $ANTLR end "if_statement_elsif_part"

	partial void EnterRule_if_statement_else_part();
	partial void LeaveRule_if_statement_else_part();

	// $ANTLR start "if_statement_else_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:936:1: if_statement_else_part : ELSE sequence_of_statements -> ^( ELSE ( sequence_of_statements )? ) ;
	[GrammarRule("if_statement_else_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> if_statement_else_part()
	{
		EnterRule_if_statement_else_part();
		EnterRule("if_statement_else_part", 109);
		TraceIn("if_statement_else_part", 109);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int if_statement_else_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ELSE391 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sequence_of_statements392 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ELSE391_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_sequence_of_statements=new RewriteRuleSubtreeStream(adaptor,"rule sequence_of_statements");
		try { DebugEnterRule(GrammarFileName, "if_statement_else_part");
		DebugLocation(936, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 109)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:937:5: ( ELSE sequence_of_statements -> ^( ELSE ( sequence_of_statements )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:937:9: ELSE sequence_of_statements
			{
			DebugLocation(937, 9);
			ELSE391=(IToken)Match(input,ELSE,Follow._ELSE_in_if_statement_else_part8951); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSE.Add(ELSE391);

			DebugLocation(937, 14);
			PushFollow(Follow._sequence_of_statements_in_if_statement_else_part8953);
			sequence_of_statements392=sequence_of_statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sequence_of_statements.Add(sequence_of_statements392.Tree);


			{
			// AST REWRITE
			// elements: ELSE, sequence_of_statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 938:9: -> ^( ELSE ( sequence_of_statements )? )
			{
				DebugLocation(938, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:938:12: ^( ELSE ( sequence_of_statements )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(938, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ELSE.NextNode(), root_1);

				DebugLocation(938, 20);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:938:20: ( sequence_of_statements )?
				if (stream_sequence_of_statements.HasNext)
				{
					DebugLocation(938, 20);
					adaptor.AddChild(root_1, stream_sequence_of_statements.NextTree());

				}
				stream_sequence_of_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if_statement_else_part", 109);
			LeaveRule("if_statement_else_part", 109);
			LeaveRule_if_statement_else_part();
			if (state.backtracking > 0) { Memoize(input, 109, if_statement_else_part_StartIndex); }

		}
		DebugLocation(939, 4);
		} finally { DebugExitRule(GrammarFileName, "if_statement_else_part"); }
		return retval;

	}
	// $ANTLR end "if_statement_else_part"

	partial void EnterRule_incomplete_type_declaration();
	partial void LeaveRule_incomplete_type_declaration();

	// $ANTLR start "incomplete_type_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:941:1: incomplete_type_declaration : TYPE identifier SEMI -> ^( INCOMPLETE_TYPE_DECLARATION identifier ) ;
	[GrammarRule("incomplete_type_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> incomplete_type_declaration()
	{
		EnterRule_incomplete_type_declaration();
		EnterRule("incomplete_type_declaration", 110);
		TraceIn("incomplete_type_declaration", 110);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int incomplete_type_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken TYPE393 = default(IToken);
		IToken SEMI395 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier394 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree TYPE393_tree = default(CommonTree);
		CommonTree SEMI395_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "incomplete_type_declaration");
		DebugLocation(941, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 110)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:942:5: ( TYPE identifier SEMI -> ^( INCOMPLETE_TYPE_DECLARATION identifier ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:942:9: TYPE identifier SEMI
			{
			DebugLocation(942, 9);
			TYPE393=(IToken)Match(input,TYPE,Follow._TYPE_in_incomplete_type_declaration8991); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE393);

			DebugLocation(942, 14);
			PushFollow(Follow._identifier_in_incomplete_type_declaration8993);
			identifier394=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier394.Tree);
			DebugLocation(942, 25);
			SEMI395=(IToken)Match(input,SEMI,Follow._SEMI_in_incomplete_type_declaration8995); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI395);



			{
			// AST REWRITE
			// elements: identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 943:9: -> ^( INCOMPLETE_TYPE_DECLARATION identifier )
			{
				DebugLocation(943, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:943:12: ^( INCOMPLETE_TYPE_DECLARATION identifier )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(943, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INCOMPLETE_TYPE_DECLARATION, "INCOMPLETE_TYPE_DECLARATION"), root_1);

				DebugLocation(943, 43);
				adaptor.AddChild(root_1, stream_identifier.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("incomplete_type_declaration", 110);
			LeaveRule("incomplete_type_declaration", 110);
			LeaveRule_incomplete_type_declaration();
			if (state.backtracking > 0) { Memoize(input, 110, incomplete_type_declaration_StartIndex); }

		}
		DebugLocation(944, 4);
		} finally { DebugExitRule(GrammarFileName, "incomplete_type_declaration"); }
		return retval;

	}
	// $ANTLR end "incomplete_type_declaration"

	partial void EnterRule_index_constraint();
	partial void LeaveRule_index_constraint();

	// $ANTLR start "index_constraint"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:946:1: index_constraint : LPAREN discrete_range ( COMMA discrete_range )* RPAREN -> ^( INDEX_CONSTRAINT ( discrete_range )+ ) ;
	[GrammarRule("index_constraint")]
	private AstParserRuleReturnScope<CommonTree, IToken> index_constraint()
	{
		EnterRule_index_constraint();
		EnterRule("index_constraint", 111);
		TraceIn("index_constraint", 111);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int index_constraint_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN396 = default(IToken);
		IToken COMMA398 = default(IToken);
		IToken RPAREN400 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> discrete_range397 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> discrete_range399 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN396_tree = default(CommonTree);
		CommonTree COMMA398_tree = default(CommonTree);
		CommonTree RPAREN400_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_discrete_range=new RewriteRuleSubtreeStream(adaptor,"rule discrete_range");
		try { DebugEnterRule(GrammarFileName, "index_constraint");
		DebugLocation(946, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 111)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:947:5: ( LPAREN discrete_range ( COMMA discrete_range )* RPAREN -> ^( INDEX_CONSTRAINT ( discrete_range )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:947:9: LPAREN discrete_range ( COMMA discrete_range )* RPAREN
			{
			DebugLocation(947, 9);
			LPAREN396=(IToken)Match(input,LPAREN,Follow._LPAREN_in_index_constraint9032); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN396);

			DebugLocation(947, 16);
			PushFollow(Follow._discrete_range_in_index_constraint9034);
			discrete_range397=discrete_range();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_discrete_range.Add(discrete_range397.Tree);
			DebugLocation(947, 31);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:947:31: ( COMMA discrete_range )*
			try { DebugEnterSubRule(122);
			while (true)
			{
				int alt122=2;
				try { DebugEnterDecision(122, false);
				int LA122_0 = input.LA(1);

				if ((LA122_0==COMMA))
				{
					alt122 = 1;
				}


				} finally { DebugExitDecision(122); }
				switch ( alt122 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:947:33: COMMA discrete_range
					{
					DebugLocation(947, 33);
					COMMA398=(IToken)Match(input,COMMA,Follow._COMMA_in_index_constraint9038); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA398);

					DebugLocation(947, 39);
					PushFollow(Follow._discrete_range_in_index_constraint9040);
					discrete_range399=discrete_range();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_discrete_range.Add(discrete_range399.Tree);

					}
					break;

				default:
					goto loop122;
				}
			}

			loop122:
				;

			} finally { DebugExitSubRule(122); }

			DebugLocation(947, 57);
			RPAREN400=(IToken)Match(input,RPAREN,Follow._RPAREN_in_index_constraint9045); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN400);



			{
			// AST REWRITE
			// elements: discrete_range
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 948:9: -> ^( INDEX_CONSTRAINT ( discrete_range )+ )
			{
				DebugLocation(948, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:948:12: ^( INDEX_CONSTRAINT ( discrete_range )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(948, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INDEX_CONSTRAINT, "INDEX_CONSTRAINT"), root_1);

				DebugLocation(948, 32);
				if (!(stream_discrete_range.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_discrete_range.HasNext )
				{
					DebugLocation(948, 32);
					adaptor.AddChild(root_1, stream_discrete_range.NextTree());

				}
				stream_discrete_range.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("index_constraint", 111);
			LeaveRule("index_constraint", 111);
			LeaveRule_index_constraint();
			if (state.backtracking > 0) { Memoize(input, 111, index_constraint_StartIndex); }

		}
		DebugLocation(949, 4);
		} finally { DebugExitRule(GrammarFileName, "index_constraint"); }
		return retval;

	}
	// $ANTLR end "index_constraint"

	partial void EnterRule_index_subtype_definition();
	partial void LeaveRule_index_subtype_definition();

	// $ANTLR start "index_subtype_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:951:1: index_subtype_definition : type_mark= name RANGETOK BOX -> $type_mark;
	[GrammarRule("index_subtype_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> index_subtype_definition()
	{
		EnterRule_index_subtype_definition();
		EnterRule("index_subtype_definition", 112);
		TraceIn("index_subtype_definition", 112);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int index_subtype_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken RANGETOK401 = default(IToken);
		IToken BOX402 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RANGETOK401_tree = default(CommonTree);
		CommonTree BOX402_tree = default(CommonTree);
		RewriteRuleITokenStream stream_BOX=new RewriteRuleITokenStream(adaptor,"token BOX");
		RewriteRuleITokenStream stream_RANGETOK=new RewriteRuleITokenStream(adaptor,"token RANGETOK");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "index_subtype_definition");
		DebugLocation(951, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 112)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:952:5: (type_mark= name RANGETOK BOX -> $type_mark)
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:952:9: type_mark= name RANGETOK BOX
			{
			DebugLocation(952, 18);
			PushFollow(Follow._name_in_index_subtype_definition9085);
			type_mark=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(type_mark.Tree);
			DebugLocation(952, 24);
			RANGETOK401=(IToken)Match(input,RANGETOK,Follow._RANGETOK_in_index_subtype_definition9087); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RANGETOK.Add(RANGETOK401);

			DebugLocation(952, 33);
			BOX402=(IToken)Match(input,BOX,Follow._BOX_in_index_subtype_definition9089); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BOX.Add(BOX402);



			{
			// AST REWRITE
			// elements: type_mark
			// token labels: 
			// rule labels: retval, type_mark
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_type_mark=new RewriteRuleSubtreeStream(adaptor,"rule type_mark",type_mark!=null?type_mark.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 953:9: -> $type_mark
			{
				DebugLocation(953, 13);
				adaptor.AddChild(root_0, stream_type_mark.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("index_subtype_definition", 112);
			LeaveRule("index_subtype_definition", 112);
			LeaveRule_index_subtype_definition();
			if (state.backtracking > 0) { Memoize(input, 112, index_subtype_definition_StartIndex); }

		}
		DebugLocation(954, 4);
		} finally { DebugExitRule(GrammarFileName, "index_subtype_definition"); }
		return retval;

	}
	// $ANTLR end "index_subtype_definition"

	partial void EnterRule_instantiated_unit();
	partial void LeaveRule_instantiated_unit();

	// $ANTLR start "instantiated_unit"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:956:1: instantiated_unit : ( ( COMPONENT )? component= name_without_parens -> ^( COMPONENT_INSTANCE ( COMPONENT )? $component) | ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )? -> ^( ENTITY $entity ( $architecture)? ) | CONFIGURATION configuration= name_without_parens -> ^( CONFIGURATION $configuration) );
	[GrammarRule("instantiated_unit")]
	private AstParserRuleReturnScope<CommonTree, IToken> instantiated_unit()
	{
		EnterRule_instantiated_unit();
		EnterRule("instantiated_unit", 113);
		TraceIn("instantiated_unit", 113);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int instantiated_unit_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMPONENT403 = default(IToken);
		IToken ENTITY404 = default(IToken);
		IToken LPAREN405 = default(IToken);
		IToken RPAREN406 = default(IToken);
		IToken CONFIGURATION407 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> component = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> entity = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> architecture = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> configuration = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMPONENT403_tree = default(CommonTree);
		CommonTree ENTITY404_tree = default(CommonTree);
		CommonTree LPAREN405_tree = default(CommonTree);
		CommonTree RPAREN406_tree = default(CommonTree);
		CommonTree CONFIGURATION407_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_CONFIGURATION=new RewriteRuleITokenStream(adaptor,"token CONFIGURATION");
		RewriteRuleITokenStream stream_COMPONENT=new RewriteRuleITokenStream(adaptor,"token COMPONENT");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_ENTITY=new RewriteRuleITokenStream(adaptor,"token ENTITY");
		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "instantiated_unit");
		DebugLocation(956, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 113)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:957:5: ( ( COMPONENT )? component= name_without_parens -> ^( COMPONENT_INSTANCE ( COMPONENT )? $component) | ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )? -> ^( ENTITY $entity ( $architecture)? ) | CONFIGURATION configuration= name_without_parens -> ^( CONFIGURATION $configuration) )
			int alt125=3;
			try { DebugEnterDecision(125, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case COMPONENT:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt125 = 1;
				}
				break;
			case ENTITY:
				{
				alt125 = 2;
				}
				break;
			case CONFIGURATION:
				{
				alt125 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 125, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(125); }
			switch (alt125)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:957:9: ( COMPONENT )? component= name_without_parens
				{
				DebugLocation(957, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:957:9: ( COMPONENT )?
				int alt123=2;
				try { DebugEnterSubRule(123);
				try { DebugEnterDecision(123, false);
				int LA123_0 = input.LA(1);

				if ((LA123_0==COMPONENT))
				{
					alt123 = 1;
				}
				} finally { DebugExitDecision(123); }
				switch (alt123)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:957:9: COMPONENT
					{
					DebugLocation(957, 9);
					COMPONENT403=(IToken)Match(input,COMPONENT,Follow._COMPONENT_in_instantiated_unit9121); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMPONENT.Add(COMPONENT403);


					}
					break;

				}
				} finally { DebugExitSubRule(123); }

				DebugLocation(957, 29);
				PushFollow(Follow._name_without_parens_in_instantiated_unit9126);
				component=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(component.Tree);


				{
				// AST REWRITE
				// elements: COMPONENT, component
				// token labels: 
				// rule labels: retval, component
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_component=new RewriteRuleSubtreeStream(adaptor,"rule component",component!=null?component.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 958:9: -> ^( COMPONENT_INSTANCE ( COMPONENT )? $component)
				{
					DebugLocation(958, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:958:12: ^( COMPONENT_INSTANCE ( COMPONENT )? $component)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(958, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMPONENT_INSTANCE, "COMPONENT_INSTANCE"), root_1);

					DebugLocation(958, 34);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:958:34: ( COMPONENT )?
					if (stream_COMPONENT.HasNext)
					{
						DebugLocation(958, 34);
						adaptor.AddChild(root_1, stream_COMPONENT.NextNode());

					}
					stream_COMPONENT.Reset();
					DebugLocation(958, 46);
					adaptor.AddChild(root_1, stream_component.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:959:9: ENTITY entity= name_without_parens ( LPAREN architecture= identifier RPAREN )?
				{
				DebugLocation(959, 9);
				ENTITY404=(IToken)Match(input,ENTITY,Follow._ENTITY_in_instantiated_unit9158); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ENTITY.Add(ENTITY404);

				DebugLocation(959, 22);
				PushFollow(Follow._name_without_parens_in_instantiated_unit9162);
				entity=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(entity.Tree);
				DebugLocation(959, 43);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:959:43: ( LPAREN architecture= identifier RPAREN )?
				int alt124=2;
				try { DebugEnterSubRule(124);
				try { DebugEnterDecision(124, false);
				int LA124_0 = input.LA(1);

				if ((LA124_0==LPAREN))
				{
					alt124 = 1;
				}
				} finally { DebugExitDecision(124); }
				switch (alt124)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:959:45: LPAREN architecture= identifier RPAREN
					{
					DebugLocation(959, 45);
					LPAREN405=(IToken)Match(input,LPAREN,Follow._LPAREN_in_instantiated_unit9166); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LPAREN.Add(LPAREN405);

					DebugLocation(959, 64);
					PushFollow(Follow._identifier_in_instantiated_unit9170);
					architecture=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(architecture.Tree);
					DebugLocation(959, 76);
					RPAREN406=(IToken)Match(input,RPAREN,Follow._RPAREN_in_instantiated_unit9172); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RPAREN.Add(RPAREN406);


					}
					break;

				}
				} finally { DebugExitSubRule(124); }



				{
				// AST REWRITE
				// elements: ENTITY, entity, architecture
				// token labels: 
				// rule labels: retval, entity, architecture
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_entity=new RewriteRuleSubtreeStream(adaptor,"rule entity",entity!=null?entity.Tree:null);
				RewriteRuleSubtreeStream stream_architecture=new RewriteRuleSubtreeStream(adaptor,"rule architecture",architecture!=null?architecture.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 960:9: -> ^( ENTITY $entity ( $architecture)? )
				{
					DebugLocation(960, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:960:12: ^( ENTITY $entity ( $architecture)? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(960, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_ENTITY.NextNode(), root_1);

					DebugLocation(960, 23);
					adaptor.AddChild(root_1, stream_entity.NextTree());
					DebugLocation(960, 31);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:960:31: ( $architecture)?
					if (stream_architecture.HasNext)
					{
						DebugLocation(960, 31);
						adaptor.AddChild(root_1, stream_architecture.NextTree());

					}
					stream_architecture.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:961:9: CONFIGURATION configuration= name_without_parens
				{
				DebugLocation(961, 9);
				CONFIGURATION407=(IToken)Match(input,CONFIGURATION,Follow._CONFIGURATION_in_instantiated_unit9208); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONFIGURATION.Add(CONFIGURATION407);

				DebugLocation(961, 36);
				PushFollow(Follow._name_without_parens_in_instantiated_unit9212);
				configuration=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(configuration.Tree);


				{
				// AST REWRITE
				// elements: configuration, CONFIGURATION
				// token labels: 
				// rule labels: retval, configuration
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_configuration=new RewriteRuleSubtreeStream(adaptor,"rule configuration",configuration!=null?configuration.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 962:9: -> ^( CONFIGURATION $configuration)
				{
					DebugLocation(962, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:962:12: ^( CONFIGURATION $configuration)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(962, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_CONFIGURATION.NextNode(), root_1);

					DebugLocation(962, 30);
					adaptor.AddChild(root_1, stream_configuration.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("instantiated_unit", 113);
			LeaveRule("instantiated_unit", 113);
			LeaveRule_instantiated_unit();
			if (state.backtracking > 0) { Memoize(input, 113, instantiated_unit_StartIndex); }

		}
		DebugLocation(963, 4);
		} finally { DebugExitRule(GrammarFileName, "instantiated_unit"); }
		return retval;

	}
	// $ANTLR end "instantiated_unit"

	partial void EnterRule_instantiation_list();
	partial void LeaveRule_instantiation_list();

	// $ANTLR start "instantiation_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:965:1: instantiation_list : (instantiation_label1= identifier ( COMMA instantiation_label2= identifier )* -> ^( INSTANTIATION_LIST ( identifier )+ ) | OTHERS | ALL );
	[GrammarRule("instantiation_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> instantiation_list()
	{
		EnterRule_instantiation_list();
		EnterRule("instantiation_list", 114);
		TraceIn("instantiation_list", 114);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int instantiation_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA408 = default(IToken);
		IToken OTHERS409 = default(IToken);
		IToken ALL410 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> instantiation_label1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> instantiation_label2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA408_tree = default(CommonTree);
		CommonTree OTHERS409_tree = default(CommonTree);
		CommonTree ALL410_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "instantiation_list");
		DebugLocation(965, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 114)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:966:5: (instantiation_label1= identifier ( COMMA instantiation_label2= identifier )* -> ^( INSTANTIATION_LIST ( identifier )+ ) | OTHERS | ALL )
			int alt127=3;
			try { DebugEnterDecision(127, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				alt127 = 1;
				}
				break;
			case OTHERS:
				{
				alt127 = 2;
				}
				break;
			case ALL:
				{
				alt127 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 127, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(127); }
			switch (alt127)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:966:9: instantiation_label1= identifier ( COMMA instantiation_label2= identifier )*
				{
				DebugLocation(966, 29);
				PushFollow(Follow._identifier_in_instantiation_list9252);
				instantiation_label1=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(instantiation_label1.Tree);
				DebugLocation(966, 41);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:966:41: ( COMMA instantiation_label2= identifier )*
				try { DebugEnterSubRule(126);
				while (true)
				{
					int alt126=2;
					try { DebugEnterDecision(126, false);
					int LA126_0 = input.LA(1);

					if ((LA126_0==COMMA))
					{
						alt126 = 1;
					}


					} finally { DebugExitDecision(126); }
					switch ( alt126 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:966:43: COMMA instantiation_label2= identifier
						{
						DebugLocation(966, 43);
						COMMA408=(IToken)Match(input,COMMA,Follow._COMMA_in_instantiation_list9256); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA408);

						DebugLocation(966, 69);
						PushFollow(Follow._identifier_in_instantiation_list9260);
						instantiation_label2=identifier();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_identifier.Add(instantiation_label2.Tree);

						}
						break;

					default:
						goto loop126;
					}
				}

				loop126:
					;

				} finally { DebugExitSubRule(126); }



				{
				// AST REWRITE
				// elements: identifier
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 967:9: -> ^( INSTANTIATION_LIST ( identifier )+ )
				{
					DebugLocation(967, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:967:12: ^( INSTANTIATION_LIST ( identifier )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(967, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INSTANTIATION_LIST, "INSTANTIATION_LIST"), root_1);

					DebugLocation(967, 34);
					if (!(stream_identifier.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_identifier.HasNext )
					{
						DebugLocation(967, 34);
						adaptor.AddChild(root_1, stream_identifier.NextTree());

					}
					stream_identifier.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:968:9: OTHERS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(968, 9);
				OTHERS409=(IToken)Match(input,OTHERS,Follow._OTHERS_in_instantiation_list9292); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OTHERS409_tree = (CommonTree)adaptor.Create(OTHERS409);
				adaptor.AddChild(root_0, OTHERS409_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:969:9: ALL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(969, 9);
				ALL410=(IToken)Match(input,ALL,Follow._ALL_in_instantiation_list9302); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ALL410_tree = (CommonTree)adaptor.Create(ALL410);
				adaptor.AddChild(root_0, ALL410_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("instantiation_list", 114);
			LeaveRule("instantiation_list", 114);
			LeaveRule_instantiation_list();
			if (state.backtracking > 0) { Memoize(input, 114, instantiation_list_StartIndex); }

		}
		DebugLocation(970, 4);
		} finally { DebugExitRule(GrammarFileName, "instantiation_list"); }
		return retval;

	}
	// $ANTLR end "instantiation_list"

	partial void EnterRule_integer_or_floating_type_definition();
	partial void LeaveRule_integer_or_floating_type_definition();

	// $ANTLR start "integer_or_floating_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:974:1: integer_or_floating_type_definition : range_constraint -> ^( INTEGER_OR_FLOAT_TYPE_DEFINITION range_constraint ) ;
	[GrammarRule("integer_or_floating_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> integer_or_floating_type_definition()
	{
		EnterRule_integer_or_floating_type_definition();
		EnterRule("integer_or_floating_type_definition", 115);
		TraceIn("integer_or_floating_type_definition", 115);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int integer_or_floating_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> range_constraint411 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_range_constraint=new RewriteRuleSubtreeStream(adaptor,"rule range_constraint");
		try { DebugEnterRule(GrammarFileName, "integer_or_floating_type_definition");
		DebugLocation(974, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 115)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:975:5: ( range_constraint -> ^( INTEGER_OR_FLOAT_TYPE_DEFINITION range_constraint ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:975:9: range_constraint
			{
			DebugLocation(975, 9);
			PushFollow(Follow._range_constraint_in_integer_or_floating_type_definition9323);
			range_constraint411=range_constraint();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_range_constraint.Add(range_constraint411.Tree);


			{
			// AST REWRITE
			// elements: range_constraint
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 976:9: -> ^( INTEGER_OR_FLOAT_TYPE_DEFINITION range_constraint )
			{
				DebugLocation(976, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:976:12: ^( INTEGER_OR_FLOAT_TYPE_DEFINITION range_constraint )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(976, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTEGER_OR_FLOAT_TYPE_DEFINITION, "INTEGER_OR_FLOAT_TYPE_DEFINITION"), root_1);

				DebugLocation(976, 48);
				adaptor.AddChild(root_1, stream_range_constraint.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer_or_floating_type_definition", 115);
			LeaveRule("integer_or_floating_type_definition", 115);
			LeaveRule_integer_or_floating_type_definition();
			if (state.backtracking > 0) { Memoize(input, 115, integer_or_floating_type_definition_StartIndex); }

		}
		DebugLocation(977, 4);
		} finally { DebugExitRule(GrammarFileName, "integer_or_floating_type_definition"); }
		return retval;

	}
	// $ANTLR end "integer_or_floating_type_definition"

	partial void EnterRule_interface_ambigous_declaration_procedure();
	partial void LeaveRule_interface_ambigous_declaration_procedure();

	// $ANTLR start "interface_ambigous_declaration_procedure"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:979:1: interface_ambigous_declaration_procedure : identifier_list COLON ( ( IN )? si1= subtype_indication ( VARASGN static_expression1= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? ) | (m= OUT |m= INOUT ) si2= subtype_indication ( VARASGN static_expression2= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? ) ) ;
	[GrammarRule("interface_ambigous_declaration_procedure")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_ambigous_declaration_procedure()
	{
		EnterRule_interface_ambigous_declaration_procedure();
		EnterRule("interface_ambigous_declaration_procedure", 116);
		TraceIn("interface_ambigous_declaration_procedure", 116);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_ambigous_declaration_procedure_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken m = default(IToken);
		IToken COLON413 = default(IToken);
		IToken IN414 = default(IToken);
		IToken VARASGN415 = default(IToken);
		IToken VARASGN416 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> si1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> si2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list412 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree m_tree = default(CommonTree);
		CommonTree COLON413_tree = default(CommonTree);
		CommonTree IN414_tree = default(CommonTree);
		CommonTree VARASGN415_tree = default(CommonTree);
		CommonTree VARASGN416_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_OUT=new RewriteRuleITokenStream(adaptor,"token OUT");
		RewriteRuleITokenStream stream_INOUT=new RewriteRuleITokenStream(adaptor,"token INOUT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "interface_ambigous_declaration_procedure");
		DebugLocation(979, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 116)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:980:5: ( identifier_list COLON ( ( IN )? si1= subtype_indication ( VARASGN static_expression1= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? ) | (m= OUT |m= INOUT ) si2= subtype_indication ( VARASGN static_expression2= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? ) ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:980:9: identifier_list COLON ( ( IN )? si1= subtype_indication ( VARASGN static_expression1= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? ) | (m= OUT |m= INOUT ) si2= subtype_indication ( VARASGN static_expression2= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? ) )
			{
			DebugLocation(980, 9);
			PushFollow(Follow._identifier_list_in_interface_ambigous_declaration_procedure9360);
			identifier_list412=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list412.Tree);
			DebugLocation(980, 25);
			COLON413=(IToken)Match(input,COLON,Follow._COLON_in_interface_ambigous_declaration_procedure9362); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON413);

			DebugLocation(981, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:981:9: ( ( IN )? si1= subtype_indication ( VARASGN static_expression1= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? ) | (m= OUT |m= INOUT ) si2= subtype_indication ( VARASGN static_expression2= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? ) )
			int alt132=2;
			try { DebugEnterSubRule(132);
			try { DebugEnterDecision(132, false);
			int LA132_0 = input.LA(1);

			if ((LA132_0==BASIC_IDENTIFIER||LA132_0==EXTENDED_IDENTIFIER||LA132_0==IN||LA132_0==STRING_LITERAL))
			{
				alt132 = 1;
			}
			else if ((LA132_0==INOUT||LA132_0==OUT))
			{
				alt132 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 132, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(132); }
			switch (alt132)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:982:17: ( IN )? si1= subtype_indication ( VARASGN static_expression1= expression )?
				{
				DebugLocation(982, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:982:17: ( IN )?
				int alt128=2;
				try { DebugEnterSubRule(128);
				try { DebugEnterDecision(128, false);
				int LA128_0 = input.LA(1);

				if ((LA128_0==IN))
				{
					alt128 = 1;
				}
				} finally { DebugExitDecision(128); }
				switch (alt128)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:982:17: IN
					{
					DebugLocation(982, 17);
					IN414=(IToken)Match(input,IN,Follow._IN_in_interface_ambigous_declaration_procedure9390); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_IN.Add(IN414);


					}
					break;

				}
				} finally { DebugExitSubRule(128); }

				DebugLocation(982, 24);
				PushFollow(Follow._subtype_indication_in_interface_ambigous_declaration_procedure9395);
				si1=subtype_indication();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subtype_indication.Add(si1.Tree);
				DebugLocation(982, 44);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:982:44: ( VARASGN static_expression1= expression )?
				int alt129=2;
				try { DebugEnterSubRule(129);
				try { DebugEnterDecision(129, false);
				int LA129_0 = input.LA(1);

				if ((LA129_0==VARASGN))
				{
					alt129 = 1;
				}
				} finally { DebugExitDecision(129); }
				switch (alt129)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:982:46: VARASGN static_expression1= expression
					{
					DebugLocation(982, 46);
					VARASGN415=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_ambigous_declaration_procedure9399); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_VARASGN.Add(VARASGN415);

					DebugLocation(982, 72);
					PushFollow(Follow._expression_in_interface_ambigous_declaration_procedure9403);
					static_expression1=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(static_expression1.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(129); }



				{
				// AST REWRITE
				// elements: si1, static_expression1, IN, identifier_list
				// token labels: 
				// rule labels: static_expression1, si1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_static_expression1=new RewriteRuleSubtreeStream(adaptor,"rule static_expression1",static_expression1!=null?static_expression1.Tree:null);
				RewriteRuleSubtreeStream stream_si1=new RewriteRuleSubtreeStream(adaptor,"rule si1",si1!=null?si1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 983:17: -> ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? )
				{
					DebugLocation(983, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:983:20: ^( INTERFACE_CONSTANT_DECLARATION identifier_list ( IN )? $si1 ( $static_expression1)? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(983, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_CONSTANT_DECLARATION, "INTERFACE_CONSTANT_DECLARATION"), root_1);

					DebugLocation(983, 54);
					adaptor.AddChild(root_1, stream_identifier_list.NextTree());
					DebugLocation(983, 70);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:983:70: ( IN )?
					if (stream_IN.HasNext)
					{
						DebugLocation(983, 70);
						adaptor.AddChild(root_1, stream_IN.NextNode());

					}
					stream_IN.Reset();
					DebugLocation(983, 75);
					adaptor.AddChild(root_1, stream_si1.NextTree());
					DebugLocation(983, 80);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:983:80: ( $static_expression1)?
					if (stream_static_expression1.HasNext)
					{
						DebugLocation(983, 80);
						adaptor.AddChild(root_1, stream_static_expression1.NextTree());

					}
					stream_static_expression1.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:17: (m= OUT |m= INOUT ) si2= subtype_indication ( VARASGN static_expression2= expression )?
				{
				DebugLocation(984, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:17: (m= OUT |m= INOUT )
				int alt130=2;
				try { DebugEnterSubRule(130);
				try { DebugEnterDecision(130, false);
				int LA130_0 = input.LA(1);

				if ((LA130_0==OUT))
				{
					alt130 = 1;
				}
				else if ((LA130_0==INOUT))
				{
					alt130 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 130, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(130); }
				switch (alt130)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:19: m= OUT
					{
					DebugLocation(984, 20);
					m=(IToken)Match(input,OUT,Follow._OUT_in_interface_ambigous_declaration_procedure9464); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_OUT.Add(m);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:27: m= INOUT
					{
					DebugLocation(984, 28);
					m=(IToken)Match(input,INOUT,Follow._INOUT_in_interface_ambigous_declaration_procedure9470); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_INOUT.Add(m);


					}
					break;

				}
				} finally { DebugExitSubRule(130); }

				DebugLocation(984, 40);
				PushFollow(Follow._subtype_indication_in_interface_ambigous_declaration_procedure9476);
				si2=subtype_indication();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subtype_indication.Add(si2.Tree);
				DebugLocation(984, 60);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:60: ( VARASGN static_expression2= expression )?
				int alt131=2;
				try { DebugEnterSubRule(131);
				try { DebugEnterDecision(131, false);
				int LA131_0 = input.LA(1);

				if ((LA131_0==VARASGN))
				{
					alt131 = 1;
				}
				} finally { DebugExitDecision(131); }
				switch (alt131)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:984:62: VARASGN static_expression2= expression
					{
					DebugLocation(984, 62);
					VARASGN416=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_ambigous_declaration_procedure9480); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_VARASGN.Add(VARASGN416);

					DebugLocation(984, 88);
					PushFollow(Follow._expression_in_interface_ambigous_declaration_procedure9484);
					static_expression2=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(static_expression2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(131); }



				{
				// AST REWRITE
				// elements: si2, m, identifier_list, static_expression2
				// token labels: m
				// rule labels: static_expression2, retval, si2
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_m=new RewriteRuleITokenStream(adaptor,"token m",m);
				RewriteRuleSubtreeStream stream_static_expression2=new RewriteRuleSubtreeStream(adaptor,"rule static_expression2",static_expression2!=null?static_expression2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_si2=new RewriteRuleSubtreeStream(adaptor,"rule si2",si2!=null?si2.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 985:17: -> ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? )
				{
					DebugLocation(985, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:985:20: ^( INTERFACE_VARIABLE_DECLARATION identifier_list $m $si2 ( $static_expression2)? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(985, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_VARIABLE_DECLARATION, "INTERFACE_VARIABLE_DECLARATION"), root_1);

					DebugLocation(985, 54);
					adaptor.AddChild(root_1, stream_identifier_list.NextTree());
					DebugLocation(985, 71);
					adaptor.AddChild(root_1, stream_m.NextNode());
					DebugLocation(985, 74);
					adaptor.AddChild(root_1, stream_si2.NextTree());
					DebugLocation(985, 79);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:985:79: ( $static_expression2)?
					if (stream_static_expression2.HasNext)
					{
						DebugLocation(985, 79);
						adaptor.AddChild(root_1, stream_static_expression2.NextTree());

					}
					stream_static_expression2.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(132); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_ambigous_declaration_procedure", 116);
			LeaveRule("interface_ambigous_declaration_procedure", 116);
			LeaveRule_interface_ambigous_declaration_procedure();
			if (state.backtracking > 0) { Memoize(input, 116, interface_ambigous_declaration_procedure_StartIndex); }

		}
		DebugLocation(987, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_ambigous_declaration_procedure"); }
		return retval;

	}
	// $ANTLR end "interface_ambigous_declaration_procedure"

	partial void EnterRule_interface_constant_declaration();
	partial void LeaveRule_interface_constant_declaration();

	// $ANTLR start "interface_constant_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:990:1: interface_constant_declaration : CONSTANT identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION CONSTANT identifier_list ( IN )? subtype_indication ( $static_expression)? ) ;
	[GrammarRule("interface_constant_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration()
	{
		EnterRule_interface_constant_declaration();
		EnterRule("interface_constant_declaration", 117);
		TraceIn("interface_constant_declaration", 117);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_constant_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CONSTANT417 = default(IToken);
		IToken COLON419 = default(IToken);
		IToken IN420 = default(IToken);
		IToken VARASGN422 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list418 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication421 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONSTANT417_tree = default(CommonTree);
		CommonTree COLON419_tree = default(CommonTree);
		CommonTree IN420_tree = default(CommonTree);
		CommonTree VARASGN422_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_CONSTANT=new RewriteRuleITokenStream(adaptor,"token CONSTANT");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "interface_constant_declaration");
		DebugLocation(990, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 117)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:991:5: ( CONSTANT identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION CONSTANT identifier_list ( IN )? subtype_indication ( $static_expression)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:991:9: CONSTANT identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )?
			{
			DebugLocation(991, 9);
			CONSTANT417=(IToken)Match(input,CONSTANT,Follow._CONSTANT_in_interface_constant_declaration9553); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONSTANT.Add(CONSTANT417);

			DebugLocation(991, 18);
			PushFollow(Follow._identifier_list_in_interface_constant_declaration9555);
			identifier_list418=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list418.Tree);
			DebugLocation(991, 34);
			COLON419=(IToken)Match(input,COLON,Follow._COLON_in_interface_constant_declaration9557); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON419);

			DebugLocation(991, 40);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:991:40: ( IN )?
			int alt133=2;
			try { DebugEnterSubRule(133);
			try { DebugEnterDecision(133, false);
			int LA133_0 = input.LA(1);

			if ((LA133_0==IN))
			{
				alt133 = 1;
			}
			} finally { DebugExitDecision(133); }
			switch (alt133)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:991:40: IN
				{
				DebugLocation(991, 40);
				IN420=(IToken)Match(input,IN,Follow._IN_in_interface_constant_declaration9559); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IN.Add(IN420);


				}
				break;

			}
			} finally { DebugExitSubRule(133); }

			DebugLocation(991, 44);
			PushFollow(Follow._subtype_indication_in_interface_constant_declaration9562);
			subtype_indication421=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication421.Tree);
			DebugLocation(992, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:992:9: ( VARASGN static_expression= expression )?
			int alt134=2;
			try { DebugEnterSubRule(134);
			try { DebugEnterDecision(134, false);
			int LA134_0 = input.LA(1);

			if ((LA134_0==VARASGN))
			{
				alt134 = 1;
			}
			} finally { DebugExitDecision(134); }
			switch (alt134)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:992:11: VARASGN static_expression= expression
				{
				DebugLocation(992, 11);
				VARASGN422=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_constant_declaration9574); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN422);

				DebugLocation(992, 36);
				PushFollow(Follow._expression_in_interface_constant_declaration9578);
				static_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(static_expression.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(134); }



			{
			// AST REWRITE
			// elements: identifier_list, CONSTANT, IN, static_expression, subtype_indication
			// token labels: 
			// rule labels: retval, static_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_static_expression=new RewriteRuleSubtreeStream(adaptor,"rule static_expression",static_expression!=null?static_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 993:9: -> ^( INTERFACE_CONSTANT_DECLARATION CONSTANT identifier_list ( IN )? subtype_indication ( $static_expression)? )
			{
				DebugLocation(993, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:993:12: ^( INTERFACE_CONSTANT_DECLARATION CONSTANT identifier_list ( IN )? subtype_indication ( $static_expression)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(993, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_CONSTANT_DECLARATION, "INTERFACE_CONSTANT_DECLARATION"), root_1);

				DebugLocation(993, 46);
				adaptor.AddChild(root_1, stream_CONSTANT.NextNode());
				DebugLocation(993, 55);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(993, 71);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:993:71: ( IN )?
				if (stream_IN.HasNext)
				{
					DebugLocation(993, 71);
					adaptor.AddChild(root_1, stream_IN.NextNode());

				}
				stream_IN.Reset();
				DebugLocation(993, 75);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(994, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:994:18: ( $static_expression)?
				if (stream_static_expression.HasNext)
				{
					DebugLocation(994, 18);
					adaptor.AddChild(root_1, stream_static_expression.NextTree());

				}
				stream_static_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_constant_declaration", 117);
			LeaveRule("interface_constant_declaration", 117);
			LeaveRule_interface_constant_declaration();
			if (state.backtracking > 0) { Memoize(input, 117, interface_constant_declaration_StartIndex); }

		}
		DebugLocation(995, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_constant_declaration"); }
		return retval;

	}
	// $ANTLR end "interface_constant_declaration"

	partial void EnterRule_interface_constant_declaration_optional_class();
	partial void LeaveRule_interface_constant_declaration_optional_class();

	// $ANTLR start "interface_constant_declaration_optional_class"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:997:1: interface_constant_declaration_optional_class : ( CONSTANT )? identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION ( CONSTANT )? identifier_list ( IN )? subtype_indication ( $static_expression)? ) ;
	[GrammarRule("interface_constant_declaration_optional_class")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration_optional_class()
	{
		EnterRule_interface_constant_declaration_optional_class();
		EnterRule("interface_constant_declaration_optional_class", 118);
		TraceIn("interface_constant_declaration_optional_class", 118);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_constant_declaration_optional_class_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken CONSTANT423 = default(IToken);
		IToken COLON425 = default(IToken);
		IToken IN426 = default(IToken);
		IToken VARASGN428 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list424 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication427 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONSTANT423_tree = default(CommonTree);
		CommonTree COLON425_tree = default(CommonTree);
		CommonTree IN426_tree = default(CommonTree);
		CommonTree VARASGN428_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_CONSTANT=new RewriteRuleITokenStream(adaptor,"token CONSTANT");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "interface_constant_declaration_optional_class");
		DebugLocation(997, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 118)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:5: ( ( CONSTANT )? identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_CONSTANT_DECLARATION ( CONSTANT )? identifier_list ( IN )? subtype_indication ( $static_expression)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:9: ( CONSTANT )? identifier_list COLON ( IN )? subtype_indication ( VARASGN static_expression= expression )?
			{
			DebugLocation(998, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:9: ( CONSTANT )?
			int alt135=2;
			try { DebugEnterSubRule(135);
			try { DebugEnterDecision(135, false);
			int LA135_0 = input.LA(1);

			if ((LA135_0==CONSTANT))
			{
				alt135 = 1;
			}
			} finally { DebugExitDecision(135); }
			switch (alt135)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:9: CONSTANT
				{
				DebugLocation(998, 9);
				CONSTANT423=(IToken)Match(input,CONSTANT,Follow._CONSTANT_in_interface_constant_declaration_optional_class9645); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONSTANT.Add(CONSTANT423);


				}
				break;

			}
			} finally { DebugExitSubRule(135); }

			DebugLocation(998, 19);
			PushFollow(Follow._identifier_list_in_interface_constant_declaration_optional_class9648);
			identifier_list424=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list424.Tree);
			DebugLocation(998, 35);
			COLON425=(IToken)Match(input,COLON,Follow._COLON_in_interface_constant_declaration_optional_class9650); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON425);

			DebugLocation(998, 41);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:41: ( IN )?
			int alt136=2;
			try { DebugEnterSubRule(136);
			try { DebugEnterDecision(136, false);
			int LA136_0 = input.LA(1);

			if ((LA136_0==IN))
			{
				alt136 = 1;
			}
			} finally { DebugExitDecision(136); }
			switch (alt136)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:998:41: IN
				{
				DebugLocation(998, 41);
				IN426=(IToken)Match(input,IN,Follow._IN_in_interface_constant_declaration_optional_class9652); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IN.Add(IN426);


				}
				break;

			}
			} finally { DebugExitSubRule(136); }

			DebugLocation(998, 45);
			PushFollow(Follow._subtype_indication_in_interface_constant_declaration_optional_class9655);
			subtype_indication427=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication427.Tree);
			DebugLocation(999, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:999:9: ( VARASGN static_expression= expression )?
			int alt137=2;
			try { DebugEnterSubRule(137);
			try { DebugEnterDecision(137, false);
			int LA137_0 = input.LA(1);

			if ((LA137_0==VARASGN))
			{
				alt137 = 1;
			}
			} finally { DebugExitDecision(137); }
			switch (alt137)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:999:11: VARASGN static_expression= expression
				{
				DebugLocation(999, 11);
				VARASGN428=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_constant_declaration_optional_class9667); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN428);

				DebugLocation(999, 36);
				PushFollow(Follow._expression_in_interface_constant_declaration_optional_class9671);
				static_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(static_expression.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(137); }



			{
			// AST REWRITE
			// elements: CONSTANT, static_expression, subtype_indication, identifier_list, IN
			// token labels: 
			// rule labels: retval, static_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_static_expression=new RewriteRuleSubtreeStream(adaptor,"rule static_expression",static_expression!=null?static_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1000:9: -> ^( INTERFACE_CONSTANT_DECLARATION ( CONSTANT )? identifier_list ( IN )? subtype_indication ( $static_expression)? )
			{
				DebugLocation(1000, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1000:12: ^( INTERFACE_CONSTANT_DECLARATION ( CONSTANT )? identifier_list ( IN )? subtype_indication ( $static_expression)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1000, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_CONSTANT_DECLARATION, "INTERFACE_CONSTANT_DECLARATION"), root_1);

				DebugLocation(1000, 46);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1000:46: ( CONSTANT )?
				if (stream_CONSTANT.HasNext)
				{
					DebugLocation(1000, 46);
					adaptor.AddChild(root_1, stream_CONSTANT.NextNode());

				}
				stream_CONSTANT.Reset();
				DebugLocation(1000, 56);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1000, 72);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1000:72: ( IN )?
				if (stream_IN.HasNext)
				{
					DebugLocation(1000, 72);
					adaptor.AddChild(root_1, stream_IN.NextNode());

				}
				stream_IN.Reset();
				DebugLocation(1000, 76);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1001, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1001:18: ( $static_expression)?
				if (stream_static_expression.HasNext)
				{
					DebugLocation(1001, 18);
					adaptor.AddChild(root_1, stream_static_expression.NextTree());

				}
				stream_static_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_constant_declaration_optional_class", 118);
			LeaveRule("interface_constant_declaration_optional_class", 118);
			LeaveRule_interface_constant_declaration_optional_class();
			if (state.backtracking > 0) { Memoize(input, 118, interface_constant_declaration_optional_class_StartIndex); }

		}
		DebugLocation(1002, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_constant_declaration_optional_class"); }
		return retval;

	}
	// $ANTLR end "interface_constant_declaration_optional_class"

	partial void EnterRule_interface_element_function();
	partial void LeaveRule_interface_element_function();

	// $ANTLR start "interface_element_function"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1004:1: interface_element_function : ( interface_constant_declaration_optional_class | interface_signal_declaration | interface_variable_declaration | interface_file_declaration );
	[GrammarRule("interface_element_function")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_element_function()
	{
		EnterRule_interface_element_function();
		EnterRule("interface_element_function", 119);
		TraceIn("interface_element_function", 119);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_element_function_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration_optional_class429 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration430 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_variable_declaration431 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_file_declaration432 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "interface_element_function");
		DebugLocation(1004, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 119)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1005:5: ( interface_constant_declaration_optional_class | interface_signal_declaration | interface_variable_declaration | interface_file_declaration )
			int alt138=4;
			try { DebugEnterDecision(138, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case CONSTANT:
			case EXTENDED_IDENTIFIER:
				{
				alt138 = 1;
				}
				break;
			case SIGNAL:
				{
				alt138 = 2;
				}
				break;
			case VARIABLE:
				{
				alt138 = 3;
				}
				break;
			case FILE:
				{
				alt138 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 138, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(138); }
			switch (alt138)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1005:9: interface_constant_declaration_optional_class
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1005, 9);
				PushFollow(Follow._interface_constant_declaration_optional_class_in_interface_element_function9739);
				interface_constant_declaration_optional_class429=interface_constant_declaration_optional_class();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_constant_declaration_optional_class429.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1006:9: interface_signal_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1006, 9);
				PushFollow(Follow._interface_signal_declaration_in_interface_element_function9749);
				interface_signal_declaration430=interface_signal_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_signal_declaration430.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1007:9: interface_variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1007, 9);
				PushFollow(Follow._interface_variable_declaration_in_interface_element_function9759);
				interface_variable_declaration431=interface_variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_variable_declaration431.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1008:9: interface_file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1008, 9);
				PushFollow(Follow._interface_file_declaration_in_interface_element_function9769);
				interface_file_declaration432=interface_file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_file_declaration432.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_element_function", 119);
			LeaveRule("interface_element_function", 119);
			LeaveRule_interface_element_function();
			if (state.backtracking > 0) { Memoize(input, 119, interface_element_function_StartIndex); }

		}
		DebugLocation(1009, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_element_function"); }
		return retval;

	}
	// $ANTLR end "interface_element_function"

	partial void EnterRule_interface_element_procedure();
	partial void LeaveRule_interface_element_procedure();

	// $ANTLR start "interface_element_procedure"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1011:1: interface_element_procedure : ( interface_constant_declaration | interface_signal_declaration | interface_variable_declaration | interface_file_declaration | interface_ambigous_declaration_procedure );
	[GrammarRule("interface_element_procedure")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_element_procedure()
	{
		EnterRule_interface_element_procedure();
		EnterRule("interface_element_procedure", 120);
		TraceIn("interface_element_procedure", 120);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_element_procedure_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> interface_constant_declaration433 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration434 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_variable_declaration435 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_file_declaration436 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_ambigous_declaration_procedure437 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "interface_element_procedure");
		DebugLocation(1011, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 120)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1012:5: ( interface_constant_declaration | interface_signal_declaration | interface_variable_declaration | interface_file_declaration | interface_ambigous_declaration_procedure )
			int alt139=5;
			try { DebugEnterDecision(139, false);
			switch (input.LA(1))
			{
			case CONSTANT:
				{
				alt139 = 1;
				}
				break;
			case SIGNAL:
				{
				alt139 = 2;
				}
				break;
			case VARIABLE:
				{
				alt139 = 3;
				}
				break;
			case FILE:
				{
				alt139 = 4;
				}
				break;
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				alt139 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 139, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(139); }
			switch (alt139)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1012:9: interface_constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1012, 9);
				PushFollow(Follow._interface_constant_declaration_in_interface_element_procedure9788);
				interface_constant_declaration433=interface_constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_constant_declaration433.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1013:9: interface_signal_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1013, 9);
				PushFollow(Follow._interface_signal_declaration_in_interface_element_procedure9798);
				interface_signal_declaration434=interface_signal_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_signal_declaration434.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1014:9: interface_variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1014, 9);
				PushFollow(Follow._interface_variable_declaration_in_interface_element_procedure9808);
				interface_variable_declaration435=interface_variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_variable_declaration435.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1015:9: interface_file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1015, 9);
				PushFollow(Follow._interface_file_declaration_in_interface_element_procedure9818);
				interface_file_declaration436=interface_file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_file_declaration436.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1016:9: interface_ambigous_declaration_procedure
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1016, 9);
				PushFollow(Follow._interface_ambigous_declaration_procedure_in_interface_element_procedure9828);
				interface_ambigous_declaration_procedure437=interface_ambigous_declaration_procedure();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interface_ambigous_declaration_procedure437.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_element_procedure", 120);
			LeaveRule("interface_element_procedure", 120);
			LeaveRule_interface_element_procedure();
			if (state.backtracking > 0) { Memoize(input, 120, interface_element_procedure_StartIndex); }

		}
		DebugLocation(1017, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_element_procedure"); }
		return retval;

	}
	// $ANTLR end "interface_element_procedure"

	partial void EnterRule_interface_file_declaration();
	partial void LeaveRule_interface_file_declaration();

	// $ANTLR start "interface_file_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1019:1: interface_file_declaration : FILE identifier_list COLON subtype_indication -> ^( INTERFACE_FILE_DECLARATION FILE identifier_list subtype_indication ) ;
	[GrammarRule("interface_file_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_file_declaration()
	{
		EnterRule_interface_file_declaration();
		EnterRule("interface_file_declaration", 121);
		TraceIn("interface_file_declaration", 121);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_file_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FILE438 = default(IToken);
		IToken COLON440 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list439 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication441 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FILE438_tree = default(CommonTree);
		CommonTree COLON440_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_FILE=new RewriteRuleITokenStream(adaptor,"token FILE");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "interface_file_declaration");
		DebugLocation(1019, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 121)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1020:5: ( FILE identifier_list COLON subtype_indication -> ^( INTERFACE_FILE_DECLARATION FILE identifier_list subtype_indication ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1020:9: FILE identifier_list COLON subtype_indication
			{
			DebugLocation(1020, 9);
			FILE438=(IToken)Match(input,FILE,Follow._FILE_in_interface_file_declaration9847); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FILE.Add(FILE438);

			DebugLocation(1020, 14);
			PushFollow(Follow._identifier_list_in_interface_file_declaration9849);
			identifier_list439=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list439.Tree);
			DebugLocation(1020, 30);
			COLON440=(IToken)Match(input,COLON,Follow._COLON_in_interface_file_declaration9851); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON440);

			DebugLocation(1020, 36);
			PushFollow(Follow._subtype_indication_in_interface_file_declaration9853);
			subtype_indication441=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication441.Tree);


			{
			// AST REWRITE
			// elements: subtype_indication, FILE, identifier_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1021:9: -> ^( INTERFACE_FILE_DECLARATION FILE identifier_list subtype_indication )
			{
				DebugLocation(1021, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1021:12: ^( INTERFACE_FILE_DECLARATION FILE identifier_list subtype_indication )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1021, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_FILE_DECLARATION, "INTERFACE_FILE_DECLARATION"), root_1);

				DebugLocation(1021, 42);
				adaptor.AddChild(root_1, stream_FILE.NextNode());
				DebugLocation(1021, 47);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1021, 63);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_file_declaration", 121);
			LeaveRule("interface_file_declaration", 121);
			LeaveRule_interface_file_declaration();
			if (state.backtracking > 0) { Memoize(input, 121, interface_file_declaration_StartIndex); }

		}
		DebugLocation(1022, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_file_declaration"); }
		return retval;

	}
	// $ANTLR end "interface_file_declaration"

	partial void EnterRule_interface_signal_declaration();
	partial void LeaveRule_interface_signal_declaration();

	// $ANTLR start "interface_signal_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1025:1: interface_signal_declaration : SIGNAL identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )? -> ^( INTERFACE_SIGNAL_DECLARATION SIGNAL identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? ) ;
	[GrammarRule("interface_signal_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration()
	{
		EnterRule_interface_signal_declaration();
		EnterRule("interface_signal_declaration", 122);
		TraceIn("interface_signal_declaration", 122);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_signal_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SIGNAL442 = default(IToken);
		IToken COLON444 = default(IToken);
		IToken BUS447 = default(IToken);
		IToken VARASGN448 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list443 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mode445 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication446 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SIGNAL442_tree = default(CommonTree);
		CommonTree COLON444_tree = default(CommonTree);
		CommonTree BUS447_tree = default(CommonTree);
		CommonTree VARASGN448_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_BUS=new RewriteRuleITokenStream(adaptor,"token BUS");
		RewriteRuleITokenStream stream_SIGNAL=new RewriteRuleITokenStream(adaptor,"token SIGNAL");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		RewriteRuleSubtreeStream stream_mode=new RewriteRuleSubtreeStream(adaptor,"rule mode");
		try { DebugEnterRule(GrammarFileName, "interface_signal_declaration");
		DebugLocation(1025, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 122)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:5: ( SIGNAL identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )? -> ^( INTERFACE_SIGNAL_DECLARATION SIGNAL identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:9: SIGNAL identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )?
			{
			DebugLocation(1026, 9);
			SIGNAL442=(IToken)Match(input,SIGNAL,Follow._SIGNAL_in_interface_signal_declaration9895); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SIGNAL.Add(SIGNAL442);

			DebugLocation(1026, 16);
			PushFollow(Follow._identifier_list_in_interface_signal_declaration9897);
			identifier_list443=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list443.Tree);
			DebugLocation(1026, 32);
			COLON444=(IToken)Match(input,COLON,Follow._COLON_in_interface_signal_declaration9899); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON444);

			DebugLocation(1026, 38);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:38: ( mode )?
			int alt140=2;
			try { DebugEnterSubRule(140);
			try { DebugEnterDecision(140, false);
			int LA140_0 = input.LA(1);

			if ((LA140_0==BUFFER||LA140_0==IN||LA140_0==INOUT||LA140_0==LINKAGE||LA140_0==OUT))
			{
				alt140 = 1;
			}
			} finally { DebugExitDecision(140); }
			switch (alt140)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:38: mode
				{
				DebugLocation(1026, 38);
				PushFollow(Follow._mode_in_interface_signal_declaration9901);
				mode445=mode();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_mode.Add(mode445.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(140); }

			DebugLocation(1026, 44);
			PushFollow(Follow._subtype_indication_in_interface_signal_declaration9904);
			subtype_indication446=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication446.Tree);
			DebugLocation(1026, 63);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:63: ( BUS )?
			int alt141=2;
			try { DebugEnterSubRule(141);
			try { DebugEnterDecision(141, false);
			int LA141_0 = input.LA(1);

			if ((LA141_0==BUS))
			{
				alt141 = 1;
			}
			} finally { DebugExitDecision(141); }
			switch (alt141)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1026:63: BUS
				{
				DebugLocation(1026, 63);
				BUS447=(IToken)Match(input,BUS,Follow._BUS_in_interface_signal_declaration9906); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BUS.Add(BUS447);


				}
				break;

			}
			} finally { DebugExitSubRule(141); }

			DebugLocation(1027, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1027:9: ( VARASGN static_expression= expression )?
			int alt142=2;
			try { DebugEnterSubRule(142);
			try { DebugEnterDecision(142, false);
			int LA142_0 = input.LA(1);

			if ((LA142_0==VARASGN))
			{
				alt142 = 1;
			}
			} finally { DebugExitDecision(142); }
			switch (alt142)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1027:11: VARASGN static_expression= expression
				{
				DebugLocation(1027, 11);
				VARASGN448=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_signal_declaration9919); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN448);

				DebugLocation(1027, 36);
				PushFollow(Follow._expression_in_interface_signal_declaration9923);
				static_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(static_expression.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(142); }



			{
			// AST REWRITE
			// elements: mode, identifier_list, subtype_indication, static_expression, SIGNAL, BUS
			// token labels: 
			// rule labels: retval, static_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_static_expression=new RewriteRuleSubtreeStream(adaptor,"rule static_expression",static_expression!=null?static_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1028:9: -> ^( INTERFACE_SIGNAL_DECLARATION SIGNAL identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? )
			{
				DebugLocation(1028, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1028:12: ^( INTERFACE_SIGNAL_DECLARATION SIGNAL identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1028, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_SIGNAL_DECLARATION, "INTERFACE_SIGNAL_DECLARATION"), root_1);

				DebugLocation(1028, 44);
				adaptor.AddChild(root_1, stream_SIGNAL.NextNode());
				DebugLocation(1028, 51);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1028, 67);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1028:67: ( mode )?
				if (stream_mode.HasNext)
				{
					DebugLocation(1028, 67);
					adaptor.AddChild(root_1, stream_mode.NextTree());

				}
				stream_mode.Reset();
				DebugLocation(1028, 73);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1029, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1029:17: ( BUS )?
				if (stream_BUS.HasNext)
				{
					DebugLocation(1029, 17);
					adaptor.AddChild(root_1, stream_BUS.NextNode());

				}
				stream_BUS.Reset();
				DebugLocation(1029, 23);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1029:23: ( $static_expression)?
				if (stream_static_expression.HasNext)
				{
					DebugLocation(1029, 23);
					adaptor.AddChild(root_1, stream_static_expression.NextTree());

				}
				stream_static_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_signal_declaration", 122);
			LeaveRule("interface_signal_declaration", 122);
			LeaveRule_interface_signal_declaration();
			if (state.backtracking > 0) { Memoize(input, 122, interface_signal_declaration_StartIndex); }

		}
		DebugLocation(1030, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_signal_declaration"); }
		return retval;

	}
	// $ANTLR end "interface_signal_declaration"

	partial void EnterRule_interface_signal_declaration_for_port();
	partial void LeaveRule_interface_signal_declaration_for_port();

	// $ANTLR start "interface_signal_declaration_for_port"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1032:1: interface_signal_declaration_for_port : ( SIGNAL )? identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )? -> ^( INTERFACE_SIGNAL_DECLARATION ( SIGNAL )? identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? ) ;
	[GrammarRule("interface_signal_declaration_for_port")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration_for_port()
	{
		EnterRule_interface_signal_declaration_for_port();
		EnterRule("interface_signal_declaration_for_port", 123);
		TraceIn("interface_signal_declaration_for_port", 123);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_signal_declaration_for_port_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SIGNAL449 = default(IToken);
		IToken COLON451 = default(IToken);
		IToken BUS454 = default(IToken);
		IToken VARASGN455 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list450 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mode452 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication453 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SIGNAL449_tree = default(CommonTree);
		CommonTree COLON451_tree = default(CommonTree);
		CommonTree BUS454_tree = default(CommonTree);
		CommonTree VARASGN455_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_BUS=new RewriteRuleITokenStream(adaptor,"token BUS");
		RewriteRuleITokenStream stream_SIGNAL=new RewriteRuleITokenStream(adaptor,"token SIGNAL");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		RewriteRuleSubtreeStream stream_mode=new RewriteRuleSubtreeStream(adaptor,"rule mode");
		try { DebugEnterRule(GrammarFileName, "interface_signal_declaration_for_port");
		DebugLocation(1032, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 123)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:5: ( ( SIGNAL )? identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )? -> ^( INTERFACE_SIGNAL_DECLARATION ( SIGNAL )? identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:9: ( SIGNAL )? identifier_list COLON ( mode )? subtype_indication ( BUS )? ( VARASGN static_expression= expression )?
			{
			DebugLocation(1033, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:9: ( SIGNAL )?
			int alt143=2;
			try { DebugEnterSubRule(143);
			try { DebugEnterDecision(143, false);
			int LA143_0 = input.LA(1);

			if ((LA143_0==SIGNAL))
			{
				alt143 = 1;
			}
			} finally { DebugExitDecision(143); }
			switch (alt143)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:9: SIGNAL
				{
				DebugLocation(1033, 9);
				SIGNAL449=(IToken)Match(input,SIGNAL,Follow._SIGNAL_in_interface_signal_declaration_for_port9993); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SIGNAL.Add(SIGNAL449);


				}
				break;

			}
			} finally { DebugExitSubRule(143); }

			DebugLocation(1033, 17);
			PushFollow(Follow._identifier_list_in_interface_signal_declaration_for_port9996);
			identifier_list450=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list450.Tree);
			DebugLocation(1033, 33);
			COLON451=(IToken)Match(input,COLON,Follow._COLON_in_interface_signal_declaration_for_port9998); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON451);

			DebugLocation(1033, 39);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:39: ( mode )?
			int alt144=2;
			try { DebugEnterSubRule(144);
			try { DebugEnterDecision(144, false);
			int LA144_0 = input.LA(1);

			if ((LA144_0==BUFFER||LA144_0==IN||LA144_0==INOUT||LA144_0==LINKAGE||LA144_0==OUT))
			{
				alt144 = 1;
			}
			} finally { DebugExitDecision(144); }
			switch (alt144)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:39: mode
				{
				DebugLocation(1033, 39);
				PushFollow(Follow._mode_in_interface_signal_declaration_for_port10000);
				mode452=mode();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_mode.Add(mode452.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(144); }

			DebugLocation(1033, 45);
			PushFollow(Follow._subtype_indication_in_interface_signal_declaration_for_port10003);
			subtype_indication453=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication453.Tree);
			DebugLocation(1033, 64);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:64: ( BUS )?
			int alt145=2;
			try { DebugEnterSubRule(145);
			try { DebugEnterDecision(145, false);
			int LA145_0 = input.LA(1);

			if ((LA145_0==BUS))
			{
				alt145 = 1;
			}
			} finally { DebugExitDecision(145); }
			switch (alt145)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1033:64: BUS
				{
				DebugLocation(1033, 64);
				BUS454=(IToken)Match(input,BUS,Follow._BUS_in_interface_signal_declaration_for_port10005); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BUS.Add(BUS454);


				}
				break;

			}
			} finally { DebugExitSubRule(145); }

			DebugLocation(1034, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1034:9: ( VARASGN static_expression= expression )?
			int alt146=2;
			try { DebugEnterSubRule(146);
			try { DebugEnterDecision(146, false);
			int LA146_0 = input.LA(1);

			if ((LA146_0==VARASGN))
			{
				alt146 = 1;
			}
			} finally { DebugExitDecision(146); }
			switch (alt146)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1034:11: VARASGN static_expression= expression
				{
				DebugLocation(1034, 11);
				VARASGN455=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_signal_declaration_for_port10018); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN455);

				DebugLocation(1034, 36);
				PushFollow(Follow._expression_in_interface_signal_declaration_for_port10022);
				static_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(static_expression.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(146); }



			{
			// AST REWRITE
			// elements: subtype_indication, BUS, mode, SIGNAL, static_expression, identifier_list
			// token labels: 
			// rule labels: retval, static_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_static_expression=new RewriteRuleSubtreeStream(adaptor,"rule static_expression",static_expression!=null?static_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1035:9: -> ^( INTERFACE_SIGNAL_DECLARATION ( SIGNAL )? identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? )
			{
				DebugLocation(1035, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1035:12: ^( INTERFACE_SIGNAL_DECLARATION ( SIGNAL )? identifier_list ( mode )? subtype_indication ( BUS )? ( $static_expression)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1035, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_SIGNAL_DECLARATION, "INTERFACE_SIGNAL_DECLARATION"), root_1);

				DebugLocation(1035, 44);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1035:44: ( SIGNAL )?
				if (stream_SIGNAL.HasNext)
				{
					DebugLocation(1035, 44);
					adaptor.AddChild(root_1, stream_SIGNAL.NextNode());

				}
				stream_SIGNAL.Reset();
				DebugLocation(1035, 52);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1035, 68);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1035:68: ( mode )?
				if (stream_mode.HasNext)
				{
					DebugLocation(1035, 68);
					adaptor.AddChild(root_1, stream_mode.NextTree());

				}
				stream_mode.Reset();
				DebugLocation(1035, 74);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1036, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1036:17: ( BUS )?
				if (stream_BUS.HasNext)
				{
					DebugLocation(1036, 17);
					adaptor.AddChild(root_1, stream_BUS.NextNode());

				}
				stream_BUS.Reset();
				DebugLocation(1036, 23);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1036:23: ( $static_expression)?
				if (stream_static_expression.HasNext)
				{
					DebugLocation(1036, 23);
					adaptor.AddChild(root_1, stream_static_expression.NextTree());

				}
				stream_static_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_signal_declaration_for_port", 123);
			LeaveRule("interface_signal_declaration_for_port", 123);
			LeaveRule_interface_signal_declaration_for_port();
			if (state.backtracking > 0) { Memoize(input, 123, interface_signal_declaration_for_port_StartIndex); }

		}
		DebugLocation(1037, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_signal_declaration_for_port"); }
		return retval;

	}
	// $ANTLR end "interface_signal_declaration_for_port"

	partial void EnterRule_interface_variable_declaration();
	partial void LeaveRule_interface_variable_declaration();

	// $ANTLR start "interface_variable_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1040:1: interface_variable_declaration : VARIABLE identifier_list COLON ( mode )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION VARIABLE identifier_list ( mode )? subtype_indication ( $static_expression)? ) ;
	[GrammarRule("interface_variable_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> interface_variable_declaration()
	{
		EnterRule_interface_variable_declaration();
		EnterRule("interface_variable_declaration", 124);
		TraceIn("interface_variable_declaration", 124);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int interface_variable_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken VARIABLE456 = default(IToken);
		IToken COLON458 = default(IToken);
		IToken VARASGN461 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> static_expression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list457 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mode459 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication460 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree VARIABLE456_tree = default(CommonTree);
		CommonTree COLON458_tree = default(CommonTree);
		CommonTree VARASGN461_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_VARIABLE=new RewriteRuleITokenStream(adaptor,"token VARIABLE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		RewriteRuleSubtreeStream stream_mode=new RewriteRuleSubtreeStream(adaptor,"rule mode");
		try { DebugEnterRule(GrammarFileName, "interface_variable_declaration");
		DebugLocation(1040, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 124)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1041:5: ( VARIABLE identifier_list COLON ( mode )? subtype_indication ( VARASGN static_expression= expression )? -> ^( INTERFACE_VARIABLE_DECLARATION VARIABLE identifier_list ( mode )? subtype_indication ( $static_expression)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1041:9: VARIABLE identifier_list COLON ( mode )? subtype_indication ( VARASGN static_expression= expression )?
			{
			DebugLocation(1041, 9);
			VARIABLE456=(IToken)Match(input,VARIABLE,Follow._VARIABLE_in_interface_variable_declaration10094); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VARIABLE.Add(VARIABLE456);

			DebugLocation(1041, 18);
			PushFollow(Follow._identifier_list_in_interface_variable_declaration10096);
			identifier_list457=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list457.Tree);
			DebugLocation(1041, 34);
			COLON458=(IToken)Match(input,COLON,Follow._COLON_in_interface_variable_declaration10098); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON458);

			DebugLocation(1041, 40);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1041:40: ( mode )?
			int alt147=2;
			try { DebugEnterSubRule(147);
			try { DebugEnterDecision(147, false);
			int LA147_0 = input.LA(1);

			if ((LA147_0==BUFFER||LA147_0==IN||LA147_0==INOUT||LA147_0==LINKAGE||LA147_0==OUT))
			{
				alt147 = 1;
			}
			} finally { DebugExitDecision(147); }
			switch (alt147)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1041:40: mode
				{
				DebugLocation(1041, 40);
				PushFollow(Follow._mode_in_interface_variable_declaration10100);
				mode459=mode();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_mode.Add(mode459.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(147); }

			DebugLocation(1041, 46);
			PushFollow(Follow._subtype_indication_in_interface_variable_declaration10103);
			subtype_indication460=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication460.Tree);
			DebugLocation(1042, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1042:9: ( VARASGN static_expression= expression )?
			int alt148=2;
			try { DebugEnterSubRule(148);
			try { DebugEnterDecision(148, false);
			int LA148_0 = input.LA(1);

			if ((LA148_0==VARASGN))
			{
				alt148 = 1;
			}
			} finally { DebugExitDecision(148); }
			switch (alt148)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1042:11: VARASGN static_expression= expression
				{
				DebugLocation(1042, 11);
				VARASGN461=(IToken)Match(input,VARASGN,Follow._VARASGN_in_interface_variable_declaration10115); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN461);

				DebugLocation(1042, 36);
				PushFollow(Follow._expression_in_interface_variable_declaration10119);
				static_expression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(static_expression.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(148); }



			{
			// AST REWRITE
			// elements: identifier_list, static_expression, subtype_indication, mode, VARIABLE
			// token labels: 
			// rule labels: retval, static_expression
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_static_expression=new RewriteRuleSubtreeStream(adaptor,"rule static_expression",static_expression!=null?static_expression.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1043:9: -> ^( INTERFACE_VARIABLE_DECLARATION VARIABLE identifier_list ( mode )? subtype_indication ( $static_expression)? )
			{
				DebugLocation(1043, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1043:12: ^( INTERFACE_VARIABLE_DECLARATION VARIABLE identifier_list ( mode )? subtype_indication ( $static_expression)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1043, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_VARIABLE_DECLARATION, "INTERFACE_VARIABLE_DECLARATION"), root_1);

				DebugLocation(1043, 46);
				adaptor.AddChild(root_1, stream_VARIABLE.NextNode());
				DebugLocation(1043, 55);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1043, 71);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1043:71: ( mode )?
				if (stream_mode.HasNext)
				{
					DebugLocation(1043, 71);
					adaptor.AddChild(root_1, stream_mode.NextTree());

				}
				stream_mode.Reset();
				DebugLocation(1043, 77);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1044, 18);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1044:18: ( $static_expression)?
				if (stream_static_expression.HasNext)
				{
					DebugLocation(1044, 18);
					adaptor.AddChild(root_1, stream_static_expression.NextTree());

				}
				stream_static_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interface_variable_declaration", 124);
			LeaveRule("interface_variable_declaration", 124);
			LeaveRule_interface_variable_declaration();
			if (state.backtracking > 0) { Memoize(input, 124, interface_variable_declaration_StartIndex); }

		}
		DebugLocation(1045, 4);
		} finally { DebugExitRule(GrammarFileName, "interface_variable_declaration"); }
		return retval;

	}
	// $ANTLR end "interface_variable_declaration"

	partial void EnterRule_iteration_scheme();
	partial void LeaveRule_iteration_scheme();

	// $ANTLR start "iteration_scheme"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1047:1: iteration_scheme : ( WHILE condition -> ^( WHILE condition ) | FOR loop_parameter_specification= parameter_specification -> ^( FOR $loop_parameter_specification) | -> UNCONDITIONAL_LOOP );
	[GrammarRule("iteration_scheme")]
	private AstParserRuleReturnScope<CommonTree, IToken> iteration_scheme()
	{
		EnterRule_iteration_scheme();
		EnterRule("iteration_scheme", 125);
		TraceIn("iteration_scheme", 125);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int iteration_scheme_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WHILE462 = default(IToken);
		IToken FOR464 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> loop_parameter_specification = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition463 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHILE462_tree = default(CommonTree);
		CommonTree FOR464_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_parameter_specification=new RewriteRuleSubtreeStream(adaptor,"rule parameter_specification");
		try { DebugEnterRule(GrammarFileName, "iteration_scheme");
		DebugLocation(1047, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 125)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1048:5: ( WHILE condition -> ^( WHILE condition ) | FOR loop_parameter_specification= parameter_specification -> ^( FOR $loop_parameter_specification) | -> UNCONDITIONAL_LOOP )
			int alt149=3;
			try { DebugEnterDecision(149, false);
			switch (input.LA(1))
			{
			case WHILE:
				{
				alt149 = 1;
				}
				break;
			case FOR:
				{
				alt149 = 2;
				}
				break;
			case LOOP:
				{
				alt149 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 149, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(149); }
			switch (alt149)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1048:9: WHILE condition
				{
				DebugLocation(1048, 9);
				WHILE462=(IToken)Match(input,WHILE,Follow._WHILE_in_iteration_scheme10186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHILE.Add(WHILE462);

				DebugLocation(1048, 15);
				PushFollow(Follow._condition_in_iteration_scheme10188);
				condition463=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition463.Tree);


				{
				// AST REWRITE
				// elements: condition, WHILE
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1049:9: -> ^( WHILE condition )
				{
					DebugLocation(1049, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1049:12: ^( WHILE condition )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1049, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

					DebugLocation(1049, 21);
					adaptor.AddChild(root_1, stream_condition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1050:9: FOR loop_parameter_specification= parameter_specification
				{
				DebugLocation(1050, 9);
				FOR464=(IToken)Match(input,FOR,Follow._FOR_in_iteration_scheme10216); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FOR.Add(FOR464);

				DebugLocation(1050, 41);
				PushFollow(Follow._parameter_specification_in_iteration_scheme10220);
				loop_parameter_specification=parameter_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameter_specification.Add(loop_parameter_specification.Tree);


				{
				// AST REWRITE
				// elements: FOR, loop_parameter_specification
				// token labels: 
				// rule labels: retval, loop_parameter_specification
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_loop_parameter_specification=new RewriteRuleSubtreeStream(adaptor,"rule loop_parameter_specification",loop_parameter_specification!=null?loop_parameter_specification.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1051:9: -> ^( FOR $loop_parameter_specification)
				{
					DebugLocation(1051, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1051:12: ^( FOR $loop_parameter_specification)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1051, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(1051, 20);
					adaptor.AddChild(root_1, stream_loop_parameter_specification.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1053:9: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1053:9: -> UNCONDITIONAL_LOOP
				{
					DebugLocation(1053, 12);
					adaptor.AddChild(root_0, (CommonTree)adaptor.Create(UNCONDITIONAL_LOOP, "UNCONDITIONAL_LOOP"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iteration_scheme", 125);
			LeaveRule("iteration_scheme", 125);
			LeaveRule_iteration_scheme();
			if (state.backtracking > 0) { Memoize(input, 125, iteration_scheme_StartIndex); }

		}
		DebugLocation(1054, 4);
		} finally { DebugExitRule(GrammarFileName, "iteration_scheme"); }
		return retval;

	}
	// $ANTLR end "iteration_scheme"

	partial void EnterRule_library_clause();
	partial void LeaveRule_library_clause();

	// $ANTLR start "library_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1056:1: library_clause : LIBRARY logical_name_list SEMI -> ^( LIBRARY logical_name_list ) ;
	[GrammarRule("library_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> library_clause()
	{
		EnterRule_library_clause();
		EnterRule("library_clause", 126);
		TraceIn("library_clause", 126);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int library_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LIBRARY465 = default(IToken);
		IToken SEMI467 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logical_name_list466 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LIBRARY465_tree = default(CommonTree);
		CommonTree SEMI467_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LIBRARY=new RewriteRuleITokenStream(adaptor,"token LIBRARY");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_logical_name_list=new RewriteRuleSubtreeStream(adaptor,"rule logical_name_list");
		try { DebugEnterRule(GrammarFileName, "library_clause");
		DebugLocation(1056, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 126)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1057:5: ( LIBRARY logical_name_list SEMI -> ^( LIBRARY logical_name_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1057:9: LIBRARY logical_name_list SEMI
			{
			DebugLocation(1057, 9);
			LIBRARY465=(IToken)Match(input,LIBRARY,Follow._LIBRARY_in_library_clause10279); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LIBRARY.Add(LIBRARY465);

			DebugLocation(1057, 17);
			PushFollow(Follow._logical_name_list_in_library_clause10281);
			logical_name_list466=logical_name_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logical_name_list.Add(logical_name_list466.Tree);
			DebugLocation(1057, 35);
			SEMI467=(IToken)Match(input,SEMI,Follow._SEMI_in_library_clause10283); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI467);



			{
			// AST REWRITE
			// elements: logical_name_list, LIBRARY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1058:9: -> ^( LIBRARY logical_name_list )
			{
				DebugLocation(1058, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1058:12: ^( LIBRARY logical_name_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1058, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_LIBRARY.NextNode(), root_1);

				DebugLocation(1058, 23);
				adaptor.AddChild(root_1, stream_logical_name_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("library_clause", 126);
			LeaveRule("library_clause", 126);
			LeaveRule_library_clause();
			if (state.backtracking > 0) { Memoize(input, 126, library_clause_StartIndex); }

		}
		DebugLocation(1059, 4);
		} finally { DebugExitRule(GrammarFileName, "library_clause"); }
		return retval;

	}
	// $ANTLR end "library_clause"

	partial void EnterRule_logical_name_list();
	partial void LeaveRule_logical_name_list();

	// $ANTLR start "logical_name_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1061:1: logical_name_list : logical_name1= identifier ( COMMA logical_name2= identifier )* -> ( identifier )+ ;
	[GrammarRule("logical_name_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> logical_name_list()
	{
		EnterRule_logical_name_list();
		EnterRule("logical_name_list", 127);
		TraceIn("logical_name_list", 127);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logical_name_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA468 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logical_name1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logical_name2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA468_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "logical_name_list");
		DebugLocation(1061, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 127)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1062:5: (logical_name1= identifier ( COMMA logical_name2= identifier )* -> ( identifier )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1062:9: logical_name1= identifier ( COMMA logical_name2= identifier )*
			{
			DebugLocation(1062, 22);
			PushFollow(Follow._identifier_in_logical_name_list10322);
			logical_name1=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(logical_name1.Tree);
			DebugLocation(1062, 34);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1062:34: ( COMMA logical_name2= identifier )*
			try { DebugEnterSubRule(150);
			while (true)
			{
				int alt150=2;
				try { DebugEnterDecision(150, false);
				int LA150_0 = input.LA(1);

				if ((LA150_0==COMMA))
				{
					alt150 = 1;
				}


				} finally { DebugExitDecision(150); }
				switch ( alt150 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1062:36: COMMA logical_name2= identifier
					{
					DebugLocation(1062, 36);
					COMMA468=(IToken)Match(input,COMMA,Follow._COMMA_in_logical_name_list10326); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA468);

					DebugLocation(1062, 55);
					PushFollow(Follow._identifier_in_logical_name_list10330);
					logical_name2=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(logical_name2.Tree);

					}
					break;

				default:
					goto loop150;
				}
			}

			loop150:
				;

			} finally { DebugExitSubRule(150); }



			{
			// AST REWRITE
			// elements: identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1063:9: -> ( identifier )+
			{
				DebugLocation(1063, 12);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(1063, 12);
					adaptor.AddChild(root_0, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logical_name_list", 127);
			LeaveRule("logical_name_list", 127);
			LeaveRule_logical_name_list();
			if (state.backtracking > 0) { Memoize(input, 127, logical_name_list_StartIndex); }

		}
		DebugLocation(1064, 4);
		} finally { DebugExitRule(GrammarFileName, "logical_name_list"); }
		return retval;

	}
	// $ANTLR end "logical_name_list"

	partial void EnterRule_logical_operator();
	partial void LeaveRule_logical_operator();

	// $ANTLR start "logical_operator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1066:1: logical_operator : ( AND | OR | NAND | NOR | XOR | XNOR );
	[GrammarRule("logical_operator")]
	private AstParserRuleReturnScope<CommonTree, IToken> logical_operator()
	{
		EnterRule_logical_operator();
		EnterRule("logical_operator", 128);
		TraceIn("logical_operator", 128);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logical_operator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set469 = default(IToken);

		CommonTree set469_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logical_operator");
		DebugLocation(1066, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 128)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1067:5: ( AND | OR | NAND | NOR | XOR | XNOR )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1067, 5);

			set469=(IToken)input.LT(1);
			if (input.LA(1)==AND||input.LA(1)==NAND||input.LA(1)==NOR||input.LA(1)==OR||(input.LA(1)>=XNOR && input.LA(1)<=XOR))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set469));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logical_operator", 128);
			LeaveRule("logical_operator", 128);
			LeaveRule_logical_operator();
			if (state.backtracking > 0) { Memoize(input, 128, logical_operator_StartIndex); }

		}
		DebugLocation(1073, 4);
		} finally { DebugExitRule(GrammarFileName, "logical_operator"); }
		return retval;

	}
	// $ANTLR end "logical_operator"

	partial void EnterRule_loop_statement();
	partial void LeaveRule_loop_statement();

	// $ANTLR start "loop_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1076:1: loop_statement : iteration_scheme LOOP sequence_of_statements END LOOP ( end_identifier )? SEMI -> ^( LOOP iteration_scheme ( sequence_of_statements )? ( end_identifier )? ) ;
	[GrammarRule("loop_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> loop_statement()
	{
		EnterRule_loop_statement();
		EnterRule("loop_statement", 129);
		TraceIn("loop_statement", 129);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int loop_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LOOP471 = default(IToken);
		IToken END473 = default(IToken);
		IToken LOOP474 = default(IToken);
		IToken SEMI476 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iteration_scheme470 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sequence_of_statements472 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier475 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LOOP471_tree = default(CommonTree);
		CommonTree END473_tree = default(CommonTree);
		CommonTree LOOP474_tree = default(CommonTree);
		CommonTree SEMI476_tree = default(CommonTree);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LOOP=new RewriteRuleITokenStream(adaptor,"token LOOP");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_iteration_scheme=new RewriteRuleSubtreeStream(adaptor,"rule iteration_scheme");
		RewriteRuleSubtreeStream stream_sequence_of_statements=new RewriteRuleSubtreeStream(adaptor,"rule sequence_of_statements");
		try { DebugEnterRule(GrammarFileName, "loop_statement");
		DebugLocation(1076, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 129)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1077:5: ( iteration_scheme LOOP sequence_of_statements END LOOP ( end_identifier )? SEMI -> ^( LOOP iteration_scheme ( sequence_of_statements )? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1077:9: iteration_scheme LOOP sequence_of_statements END LOOP ( end_identifier )? SEMI
			{
			DebugLocation(1077, 9);
			PushFollow(Follow._iteration_scheme_in_loop_statement10435);
			iteration_scheme470=iteration_scheme();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_iteration_scheme.Add(iteration_scheme470.Tree);
			DebugLocation(1078, 9);
			LOOP471=(IToken)Match(input,LOOP,Follow._LOOP_in_loop_statement10445); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LOOP.Add(LOOP471);

			DebugLocation(1079, 9);
			PushFollow(Follow._sequence_of_statements_in_loop_statement10455);
			sequence_of_statements472=sequence_of_statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sequence_of_statements.Add(sequence_of_statements472.Tree);
			DebugLocation(1080, 9);
			END473=(IToken)Match(input,END,Follow._END_in_loop_statement10465); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END473);

			DebugLocation(1080, 13);
			LOOP474=(IToken)Match(input,LOOP,Follow._LOOP_in_loop_statement10467); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LOOP.Add(LOOP474);

			DebugLocation(1080, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1080:18: ( end_identifier )?
			int alt151=2;
			try { DebugEnterSubRule(151);
			try { DebugEnterDecision(151, false);
			int LA151_0 = input.LA(1);

			if ((LA151_0==BASIC_IDENTIFIER||LA151_0==EXTENDED_IDENTIFIER))
			{
				alt151 = 1;
			}
			} finally { DebugExitDecision(151); }
			switch (alt151)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1080:18: end_identifier
				{
				DebugLocation(1080, 18);
				PushFollow(Follow._end_identifier_in_loop_statement10469);
				end_identifier475=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier475.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(151); }

			DebugLocation(1080, 34);
			SEMI476=(IToken)Match(input,SEMI,Follow._SEMI_in_loop_statement10472); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI476);



			{
			// AST REWRITE
			// elements: end_identifier, sequence_of_statements, LOOP, iteration_scheme
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1081:9: -> ^( LOOP iteration_scheme ( sequence_of_statements )? ( end_identifier )? )
			{
				DebugLocation(1081, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1081:12: ^( LOOP iteration_scheme ( sequence_of_statements )? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1081, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_LOOP.NextNode(), root_1);

				DebugLocation(1081, 20);
				adaptor.AddChild(root_1, stream_iteration_scheme.NextTree());
				DebugLocation(1081, 37);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1081:37: ( sequence_of_statements )?
				if (stream_sequence_of_statements.HasNext)
				{
					DebugLocation(1081, 37);
					adaptor.AddChild(root_1, stream_sequence_of_statements.NextTree());

				}
				stream_sequence_of_statements.Reset();
				DebugLocation(1081, 61);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1081:61: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(1081, 61);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("loop_statement", 129);
			LeaveRule("loop_statement", 129);
			LeaveRule_loop_statement();
			if (state.backtracking > 0) { Memoize(input, 129, loop_statement_StartIndex); }

		}
		DebugLocation(1082, 4);
		} finally { DebugExitRule(GrammarFileName, "loop_statement"); }
		return retval;

	}
	// $ANTLR end "loop_statement"

	partial void EnterRule_mode();
	partial void LeaveRule_mode();

	// $ANTLR start "mode"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1084:1: mode : ( IN | OUT | INOUT | BUFFER | LINKAGE );
	[GrammarRule("mode")]
	private AstParserRuleReturnScope<CommonTree, IToken> mode()
	{
		EnterRule_mode();
		EnterRule("mode", 130);
		TraceIn("mode", 130);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int mode_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set477 = default(IToken);

		CommonTree set477_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "mode");
		DebugLocation(1084, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 130)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1085:5: ( IN | OUT | INOUT | BUFFER | LINKAGE )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1085, 5);

			set477=(IToken)input.LT(1);
			if (input.LA(1)==BUFFER||input.LA(1)==IN||input.LA(1)==INOUT||input.LA(1)==LINKAGE||input.LA(1)==OUT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set477));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mode", 130);
			LeaveRule("mode", 130);
			LeaveRule_mode();
			if (state.backtracking > 0) { Memoize(input, 130, mode_StartIndex); }

		}
		DebugLocation(1090, 4);
		} finally { DebugExitRule(GrammarFileName, "mode"); }
		return retval;

	}
	// $ANTLR end "mode"

	partial void EnterRule_multiplying_operator();
	partial void LeaveRule_multiplying_operator();

	// $ANTLR start "multiplying_operator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1092:1: multiplying_operator : ( MUL | DIV | MOD | REM );
	[GrammarRule("multiplying_operator")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplying_operator()
	{
		EnterRule_multiplying_operator();
		EnterRule("multiplying_operator", 131);
		TraceIn("multiplying_operator", 131);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int multiplying_operator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set478 = default(IToken);

		CommonTree set478_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplying_operator");
		DebugLocation(1092, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 131)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1093:5: ( MUL | DIV | MOD | REM )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1093, 5);

			set478=(IToken)input.LT(1);
			if (input.LA(1)==DIV||(input.LA(1)>=MOD && input.LA(1)<=MUL)||input.LA(1)==REM)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set478));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplying_operator", 131);
			LeaveRule("multiplying_operator", 131);
			LeaveRule_multiplying_operator();
			if (state.backtracking > 0) { Memoize(input, 131, multiplying_operator_StartIndex); }

		}
		DebugLocation(1097, 4);
		} finally { DebugExitRule(GrammarFileName, "multiplying_operator"); }
		return retval;

	}
	// $ANTLR end "multiplying_operator"

	partial void EnterRule_name();
	partial void LeaveRule_name();

	// $ANTLR start "name"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1099:1: name : name_prefix ( ( name_part )=> name_part )* -> ^( NAME name_prefix ( name_part )* ) ;
	[GrammarRule("name")]
	private AstParserRuleReturnScope<CommonTree, IToken> name()
	{
		EnterRule_name();
		EnterRule("name", 132);
		TraceIn("name", 132);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name_prefix479 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_part480 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_name_prefix=new RewriteRuleSubtreeStream(adaptor,"rule name_prefix");
		RewriteRuleSubtreeStream stream_name_part=new RewriteRuleSubtreeStream(adaptor,"rule name_part");
		try { DebugEnterRule(GrammarFileName, "name");
		DebugLocation(1099, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 132)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:5: ( name_prefix ( ( name_part )=> name_part )* -> ^( NAME name_prefix ( name_part )* ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:9: name_prefix ( ( name_part )=> name_part )*
			{
			DebugLocation(1100, 9);
			PushFollow(Follow._name_prefix_in_name10623);
			name_prefix479=name_prefix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_prefix.Add(name_prefix479.Tree);
			DebugLocation(1100, 21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:21: ( ( name_part )=> name_part )*
			try { DebugEnterSubRule(152);
			while (true)
			{
				int alt152=2;
				try { DebugEnterDecision(152, false);
				int LA152_0 = input.LA(1);

				if ((LA152_0==LBRACKET))
				{
					int LA152_1 = input.LA(2);

					if ((EvaluatePredicate(synpred8_VhdlAntlr_fragment)))
					{
						alt152 = 1;
					}


				}
				else if ((LA152_0==LPAREN))
				{
					int LA152_14 = input.LA(2);

					if ((EvaluatePredicate(synpred8_VhdlAntlr_fragment)))
					{
						alt152 = 1;
					}


				}
				else if ((LA152_0==DOT) && (EvaluatePredicate(synpred8_VhdlAntlr_fragment)))
				{
					alt152 = 1;
				}
				else if ((LA152_0==APOSTROPHE) && (EvaluatePredicate(synpred8_VhdlAntlr_fragment)))
				{
					alt152 = 1;
				}


				} finally { DebugExitDecision(152); }
				switch ( alt152 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:23: ( name_part )=> name_part
					{
					DebugLocation(1100, 37);
					PushFollow(Follow._name_part_in_name10632);
					name_part480=name_part();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name_part.Add(name_part480.Tree);

					}
					break;

				default:
					goto loop152;
				}
			}

			loop152:
				;

			} finally { DebugExitSubRule(152); }



			{
			// AST REWRITE
			// elements: name_prefix, name_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1101:9: -> ^( NAME name_prefix ( name_part )* )
			{
				DebugLocation(1101, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1101:12: ^( NAME name_prefix ( name_part )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1101, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME, "NAME"), root_1);

				DebugLocation(1101, 20);
				adaptor.AddChild(root_1, stream_name_prefix.NextTree());
				DebugLocation(1101, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1101:32: ( name_part )*
				while ( stream_name_part.HasNext )
				{
					DebugLocation(1101, 32);
					adaptor.AddChild(root_1, stream_name_part.NextTree());

				}
				stream_name_part.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name", 132);
			LeaveRule("name", 132);
			LeaveRule_name();
			if (state.backtracking > 0) { Memoize(input, 132, name_StartIndex); }

		}
		DebugLocation(1102, 4);
		} finally { DebugExitRule(GrammarFileName, "name"); }
		return retval;

	}
	// $ANTLR end "name"

	partial void EnterRule_name_with_association();
	partial void LeaveRule_name_with_association();

	// $ANTLR start "name_with_association"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1104:1: name_with_association : name_prefix ( name_with_association_part )* -> ^( NAME name_prefix ( name_with_association_part )* ) ;
	[GrammarRule("name_with_association")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_with_association()
	{
		EnterRule_name_with_association();
		EnterRule("name_with_association", 133);
		TraceIn("name_with_association", 133);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_with_association_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name_prefix481 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_with_association_part482 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_name_prefix=new RewriteRuleSubtreeStream(adaptor,"rule name_prefix");
		RewriteRuleSubtreeStream stream_name_with_association_part=new RewriteRuleSubtreeStream(adaptor,"rule name_with_association_part");
		try { DebugEnterRule(GrammarFileName, "name_with_association");
		DebugLocation(1104, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 133)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1105:5: ( name_prefix ( name_with_association_part )* -> ^( NAME name_prefix ( name_with_association_part )* ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1105:9: name_prefix ( name_with_association_part )*
			{
			DebugLocation(1105, 9);
			PushFollow(Follow._name_prefix_in_name_with_association10675);
			name_prefix481=name_prefix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_prefix.Add(name_prefix481.Tree);
			DebugLocation(1105, 21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1105:21: ( name_with_association_part )*
			try { DebugEnterSubRule(153);
			while (true)
			{
				int alt153=2;
				try { DebugEnterDecision(153, false);
				int LA153_0 = input.LA(1);

				if ((LA153_0==APOSTROPHE))
				{
					int LA153_1 = input.LA(2);

					if ((LA153_1==BASIC_IDENTIFIER||LA153_1==EXTENDED_IDENTIFIER||LA153_1==RANGETOK))
					{
						alt153 = 1;
					}


				}
				else if ((LA153_0==DOT||LA153_0==LBRACKET||LA153_0==LPAREN))
				{
					alt153 = 1;
				}


				} finally { DebugExitDecision(153); }
				switch ( alt153 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1105:21: name_with_association_part
					{
					DebugLocation(1105, 21);
					PushFollow(Follow._name_with_association_part_in_name_with_association10677);
					name_with_association_part482=name_with_association_part();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name_with_association_part.Add(name_with_association_part482.Tree);

					}
					break;

				default:
					goto loop153;
				}
			}

			loop153:
				;

			} finally { DebugExitSubRule(153); }



			{
			// AST REWRITE
			// elements: name_prefix, name_with_association_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1106:9: -> ^( NAME name_prefix ( name_with_association_part )* )
			{
				DebugLocation(1106, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1106:12: ^( NAME name_prefix ( name_with_association_part )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1106, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME, "NAME"), root_1);

				DebugLocation(1106, 20);
				adaptor.AddChild(root_1, stream_name_prefix.NextTree());
				DebugLocation(1106, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1106:32: ( name_with_association_part )*
				while ( stream_name_with_association_part.HasNext )
				{
					DebugLocation(1106, 32);
					adaptor.AddChild(root_1, stream_name_with_association_part.NextTree());

				}
				stream_name_with_association_part.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_with_association", 133);
			LeaveRule("name_with_association", 133);
			LeaveRule_name_with_association();
			if (state.backtracking > 0) { Memoize(input, 133, name_with_association_StartIndex); }

		}
		DebugLocation(1107, 4);
		} finally { DebugExitRule(GrammarFileName, "name_with_association"); }
		return retval;

	}
	// $ANTLR end "name_with_association"

	partial void EnterRule_name_without_parens();
	partial void LeaveRule_name_without_parens();

	// $ANTLR start "name_without_parens"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1109:1: name_without_parens : name_prefix ( name_without_parens_part )* -> ^( NAME name_prefix ( name_without_parens_part )* ) ;
	[GrammarRule("name_without_parens")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_without_parens()
	{
		EnterRule_name_without_parens();
		EnterRule("name_without_parens", 134);
		TraceIn("name_without_parens", 134);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_without_parens_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name_prefix483 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_without_parens_part484 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_name_prefix=new RewriteRuleSubtreeStream(adaptor,"rule name_prefix");
		RewriteRuleSubtreeStream stream_name_without_parens_part=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens_part");
		try { DebugEnterRule(GrammarFileName, "name_without_parens");
		DebugLocation(1109, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 134)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1110:5: ( name_prefix ( name_without_parens_part )* -> ^( NAME name_prefix ( name_without_parens_part )* ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1110:9: name_prefix ( name_without_parens_part )*
			{
			DebugLocation(1110, 9);
			PushFollow(Follow._name_prefix_in_name_without_parens10718);
			name_prefix483=name_prefix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_prefix.Add(name_prefix483.Tree);
			DebugLocation(1110, 21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1110:21: ( name_without_parens_part )*
			try { DebugEnterSubRule(154);
			while (true)
			{
				int alt154=2;
				try { DebugEnterDecision(154, false);
				int LA154_0 = input.LA(1);

				if ((LA154_0==APOSTROPHE))
				{
					int LA154_2 = input.LA(2);

					if ((LA154_2==BASIC_IDENTIFIER||LA154_2==EXTENDED_IDENTIFIER||LA154_2==RANGETOK))
					{
						alt154 = 1;
					}


				}
				else if ((LA154_0==DOT||LA154_0==LBRACKET))
				{
					alt154 = 1;
				}


				} finally { DebugExitDecision(154); }
				switch ( alt154 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1110:21: name_without_parens_part
					{
					DebugLocation(1110, 21);
					PushFollow(Follow._name_without_parens_part_in_name_without_parens10720);
					name_without_parens_part484=name_without_parens_part();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name_without_parens_part.Add(name_without_parens_part484.Tree);

					}
					break;

				default:
					goto loop154;
				}
			}

			loop154:
				;

			} finally { DebugExitSubRule(154); }



			{
			// AST REWRITE
			// elements: name_prefix, name_without_parens_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1111:9: -> ^( NAME name_prefix ( name_without_parens_part )* )
			{
				DebugLocation(1111, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1111:12: ^( NAME name_prefix ( name_without_parens_part )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1111, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME, "NAME"), root_1);

				DebugLocation(1111, 20);
				adaptor.AddChild(root_1, stream_name_prefix.NextTree());
				DebugLocation(1111, 32);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1111:32: ( name_without_parens_part )*
				while ( stream_name_without_parens_part.HasNext )
				{
					DebugLocation(1111, 32);
					adaptor.AddChild(root_1, stream_name_without_parens_part.NextTree());

				}
				stream_name_without_parens_part.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_without_parens", 134);
			LeaveRule("name_without_parens", 134);
			LeaveRule_name_without_parens();
			if (state.backtracking > 0) { Memoize(input, 134, name_without_parens_StartIndex); }

		}
		DebugLocation(1112, 4);
		} finally { DebugExitRule(GrammarFileName, "name_without_parens"); }
		return retval;

	}
	// $ANTLR end "name_without_parens"

	partial void EnterRule_name_part();
	partial void LeaveRule_name_part();

	// $ANTLR start "name_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1114:1: name_part : ( name_selected_part | ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN | LPAREN expression ( direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | ( COMMA expression )* -> ^( NAME_INDEXED_PART ( expression )+ ) ) RPAREN | name_attribute_part );
	[GrammarRule("name_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_part()
	{
		EnterRule_name_part();
		EnterRule("name_part", 135);
		TraceIn("name_part", 135);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN486 = default(IToken);
		IToken RPAREN489 = default(IToken);
		IToken LPAREN490 = default(IToken);
		IToken COMMA494 = default(IToken);
		IToken RPAREN496 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> name_selected_part485 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name487 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constraint488 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression491 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> direction492 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression493 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression495 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_attribute_part497 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN486_tree = default(CommonTree);
		CommonTree RPAREN489_tree = default(CommonTree);
		CommonTree LPAREN490_tree = default(CommonTree);
		CommonTree COMMA494_tree = default(CommonTree);
		CommonTree RPAREN496_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_direction=new RewriteRuleSubtreeStream(adaptor,"rule direction");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_constraint=new RewriteRuleSubtreeStream(adaptor,"rule constraint");
		try { DebugEnterRule(GrammarFileName, "name_part");
		DebugLocation(1114, 0);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 135)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1115:5: ( name_selected_part | ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN | LPAREN expression ( direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | ( COMMA expression )* -> ^( NAME_INDEXED_PART ( expression )+ ) ) RPAREN | name_attribute_part )
			int alt158=4;
			try { DebugEnterDecision(158, false);
			switch (input.LA(1))
			{
			case DOT:
				{
				alt158 = 1;
				}
				break;
			case LPAREN:
				{
				int LA158_2 = input.LA(2);

				if ((EvaluatePredicate(synpred9_VhdlAntlr_fragment)))
				{
					alt158 = 2;
				}
				else if ((true))
				{
					alt158 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 158, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case APOSTROPHE:
			case LBRACKET:
				{
				alt158 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 158, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(158); }
			switch (alt158)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1115:9: name_selected_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1115, 9);
				PushFollow(Follow._name_selected_part_in_name_part10761);
				name_selected_part485=name_selected_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_selected_part485.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1116:9: ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN
				{
				DebugLocation(1117, 9);
				LPAREN486=(IToken)Match(input,LPAREN,Follow._LPAREN_in_name_part10791); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN486);

				DebugLocation(1117, 16);
				PushFollow(Follow._name_in_name_part10793);
				name487=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name487.Tree);
				DebugLocation(1118, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1118:9: ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) )
				int alt155=2;
				try { DebugEnterSubRule(155);
				try { DebugEnterDecision(155, false);
				int LA155_0 = input.LA(1);

				if ((LA155_0==LPAREN||LA155_0==RANGETOK))
				{
					alt155 = 1;
				}
				else if ((LA155_0==RPAREN))
				{
					alt155 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 155, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(155); }
				switch (alt155)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1119:17: constraint
					{
					DebugLocation(1119, 17);
					PushFollow(Follow._constraint_in_name_part10821);
					constraint488=constraint();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_constraint.Add(constraint488.Tree);


					{
					// AST REWRITE
					// elements: name, constraint
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1120:17: -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) )
					{
						DebugLocation(1120, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1120:20: ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1120, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_SLICE_PART, "NAME_SLICE_PART"), root_1);

						DebugLocation(1120, 39);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1120:39: ^( DISCRETE_RANGE name constraint )
						{
						CommonTree root_2 = (CommonTree)adaptor.Nil();
						DebugLocation(1120, 42);
						root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DISCRETE_RANGE, "DISCRETE_RANGE"), root_2);

						DebugLocation(1120, 57);
						adaptor.AddChild(root_2, stream_name.NextTree());
						DebugLocation(1120, 62);
						adaptor.AddChild(root_2, stream_constraint.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1122:17: 
					{

					{
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1122:17: -> ^( NAME_INDEXED_OR_SLICE_PART name )
					{
						DebugLocation(1122, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1122:20: ^( NAME_INDEXED_OR_SLICE_PART name )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1122, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_INDEXED_OR_SLICE_PART, "NAME_INDEXED_OR_SLICE_PART"), root_1);

						DebugLocation(1122, 50);
						adaptor.AddChild(root_1, stream_name.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(155); }

				DebugLocation(1124, 9);
				RPAREN489=(IToken)Match(input,RPAREN,Follow._RPAREN_in_name_part10915); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN489);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1125:9: LPAREN expression ( direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | ( COMMA expression )* -> ^( NAME_INDEXED_PART ( expression )+ ) ) RPAREN
				{
				DebugLocation(1125, 9);
				LPAREN490=(IToken)Match(input,LPAREN,Follow._LPAREN_in_name_part10925); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN490);

				DebugLocation(1125, 16);
				PushFollow(Follow._expression_in_name_part10927);
				expression491=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression491.Tree);
				DebugLocation(1126, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1126:9: ( direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | ( COMMA expression )* -> ^( NAME_INDEXED_PART ( expression )+ ) )
				int alt157=2;
				try { DebugEnterSubRule(157);
				try { DebugEnterDecision(157, false);
				int LA157_0 = input.LA(1);

				if ((LA157_0==DOWNTO||LA157_0==TO))
				{
					alt157 = 1;
				}
				else if ((LA157_0==COMMA||LA157_0==RPAREN))
				{
					alt157 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 157, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(157); }
				switch (alt157)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1127:17: direction expression
					{
					DebugLocation(1127, 17);
					PushFollow(Follow._direction_in_name_part10955);
					direction492=direction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_direction.Add(direction492.Tree);
					DebugLocation(1127, 27);
					PushFollow(Follow._expression_in_name_part10957);
					expression493=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression493.Tree);


					{
					// AST REWRITE
					// elements: expression, expression, direction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1128:17: -> ^( NAME_SLICE_PART ^( direction expression expression ) )
					{
						DebugLocation(1128, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1128:20: ^( NAME_SLICE_PART ^( direction expression expression ) )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1128, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_SLICE_PART, "NAME_SLICE_PART"), root_1);

						DebugLocation(1128, 39);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1128:39: ^( direction expression expression )
						{
						CommonTree root_2 = (CommonTree)adaptor.Nil();
						DebugLocation(1128, 42);
						root_2 = (CommonTree)adaptor.BecomeRoot(stream_direction.NextNode(), root_2);

						DebugLocation(1128, 52);
						adaptor.AddChild(root_2, stream_expression.NextTree());
						DebugLocation(1128, 63);
						adaptor.AddChild(root_2, stream_expression.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1129:17: ( COMMA expression )*
					{
					DebugLocation(1129, 17);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1129:17: ( COMMA expression )*
					try { DebugEnterSubRule(156);
					while (true)
					{
						int alt156=2;
						try { DebugEnterDecision(156, false);
						int LA156_0 = input.LA(1);

						if ((LA156_0==COMMA))
						{
							alt156 = 1;
						}


						} finally { DebugExitDecision(156); }
						switch ( alt156 )
						{
						case 1:
							DebugEnterAlt(1);
							// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1129:19: COMMA expression
							{
							DebugLocation(1129, 19);
							COMMA494=(IToken)Match(input,COMMA,Follow._COMMA_in_name_part11011); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_COMMA.Add(COMMA494);

							DebugLocation(1129, 25);
							PushFollow(Follow._expression_in_name_part11013);
							expression495=expression();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_expression.Add(expression495.Tree);

							}
							break;

						default:
							goto loop156;
						}
					}

					loop156:
						;

					} finally { DebugExitSubRule(156); }



					{
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1130:13: -> ^( NAME_INDEXED_PART ( expression )+ )
					{
						DebugLocation(1130, 16);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1130:16: ^( NAME_INDEXED_PART ( expression )+ )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1130, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_INDEXED_PART, "NAME_INDEXED_PART"), root_1);

						DebugLocation(1130, 37);
						if (!(stream_expression.HasNext))
						{
							throw new RewriteEarlyExitException();
						}
						while ( stream_expression.HasNext )
						{
							DebugLocation(1130, 37);
							adaptor.AddChild(root_1, stream_expression.NextTree());

						}
						stream_expression.Reset();

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(157); }

				DebugLocation(1132, 9);
				RPAREN496=(IToken)Match(input,RPAREN,Follow._RPAREN_in_name_part11059); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN496);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1133:9: name_attribute_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1133, 9);
				PushFollow(Follow._name_attribute_part_in_name_part11069);
				name_attribute_part497=name_attribute_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_attribute_part497.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_part", 135);
			LeaveRule("name_part", 135);
			LeaveRule_name_part();
			if (state.backtracking > 0) { Memoize(input, 135, name_part_StartIndex); }

		}
		DebugLocation(1134, 0);
		} finally { DebugExitRule(GrammarFileName, "name_part"); }
		return retval;

	}
	// $ANTLR end "name_part"

	partial void EnterRule_name_with_association_part();
	partial void LeaveRule_name_with_association_part();

	// $ANTLR start "name_with_association_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1136:1: name_with_association_part : ( name_selected_part | ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN | LPAREN ( ( expression direction )=> expression direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | association_list -> association_list ) RPAREN | name_attribute_part );
	[GrammarRule("name_with_association_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_with_association_part()
	{
		EnterRule_name_with_association_part();
		EnterRule("name_with_association_part", 136);
		TraceIn("name_with_association_part", 136);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_with_association_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN499 = default(IToken);
		IToken RPAREN502 = default(IToken);
		IToken LPAREN503 = default(IToken);
		IToken RPAREN508 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> name_selected_part498 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name500 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constraint501 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression504 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> direction505 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression506 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> association_list507 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_attribute_part509 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN499_tree = default(CommonTree);
		CommonTree RPAREN502_tree = default(CommonTree);
		CommonTree LPAREN503_tree = default(CommonTree);
		CommonTree RPAREN508_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_association_list=new RewriteRuleSubtreeStream(adaptor,"rule association_list");
		RewriteRuleSubtreeStream stream_direction=new RewriteRuleSubtreeStream(adaptor,"rule direction");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_constraint=new RewriteRuleSubtreeStream(adaptor,"rule constraint");
		try { DebugEnterRule(GrammarFileName, "name_with_association_part");
		DebugLocation(1136, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 136)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1137:5: ( name_selected_part | ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN | LPAREN ( ( expression direction )=> expression direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | association_list -> association_list ) RPAREN | name_attribute_part )
			int alt161=4;
			try { DebugEnterDecision(161, false);
			switch (input.LA(1))
			{
			case DOT:
				{
				alt161 = 1;
				}
				break;
			case LPAREN:
				{
				int LA161_2 = input.LA(2);

				if ((EvaluatePredicate(synpred10_VhdlAntlr_fragment)))
				{
					alt161 = 2;
				}
				else if ((true))
				{
					alt161 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 161, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case APOSTROPHE:
			case LBRACKET:
				{
				alt161 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 161, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(161); }
			switch (alt161)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1137:9: name_selected_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1137, 9);
				PushFollow(Follow._name_selected_part_in_name_with_association_part11084);
				name_selected_part498=name_selected_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_selected_part498.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1138:9: ( LPAREN name ( constraint )? RPAREN )=> LPAREN name ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) ) RPAREN
				{
				DebugLocation(1139, 9);
				LPAREN499=(IToken)Match(input,LPAREN,Follow._LPAREN_in_name_with_association_part11114); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN499);

				DebugLocation(1139, 16);
				PushFollow(Follow._name_in_name_with_association_part11116);
				name500=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name500.Tree);
				DebugLocation(1140, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1140:9: ( constraint -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) ) | -> ^( NAME_INDEXED_OR_SLICE_PART name ) )
				int alt159=2;
				try { DebugEnterSubRule(159);
				try { DebugEnterDecision(159, false);
				int LA159_0 = input.LA(1);

				if ((LA159_0==LPAREN||LA159_0==RANGETOK))
				{
					alt159 = 1;
				}
				else if ((LA159_0==RPAREN))
				{
					alt159 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 159, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(159); }
				switch (alt159)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1141:17: constraint
					{
					DebugLocation(1141, 17);
					PushFollow(Follow._constraint_in_name_with_association_part11144);
					constraint501=constraint();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_constraint.Add(constraint501.Tree);


					{
					// AST REWRITE
					// elements: constraint, name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1142:17: -> ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) )
					{
						DebugLocation(1142, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1142:20: ^( NAME_SLICE_PART ^( DISCRETE_RANGE name constraint ) )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1142, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_SLICE_PART, "NAME_SLICE_PART"), root_1);

						DebugLocation(1142, 39);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1142:39: ^( DISCRETE_RANGE name constraint )
						{
						CommonTree root_2 = (CommonTree)adaptor.Nil();
						DebugLocation(1142, 42);
						root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DISCRETE_RANGE, "DISCRETE_RANGE"), root_2);

						DebugLocation(1142, 57);
						adaptor.AddChild(root_2, stream_name.NextTree());
						DebugLocation(1142, 62);
						adaptor.AddChild(root_2, stream_constraint.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1144:17: 
					{

					{
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1144:17: -> ^( NAME_INDEXED_OR_SLICE_PART name )
					{
						DebugLocation(1144, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1144:20: ^( NAME_INDEXED_OR_SLICE_PART name )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1144, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_INDEXED_OR_SLICE_PART, "NAME_INDEXED_OR_SLICE_PART"), root_1);

						DebugLocation(1144, 50);
						adaptor.AddChild(root_1, stream_name.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(159); }

				DebugLocation(1146, 9);
				RPAREN502=(IToken)Match(input,RPAREN,Follow._RPAREN_in_name_with_association_part11238); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN502);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1147:9: LPAREN ( ( expression direction )=> expression direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | association_list -> association_list ) RPAREN
				{
				DebugLocation(1147, 9);
				LPAREN503=(IToken)Match(input,LPAREN,Follow._LPAREN_in_name_with_association_part11248); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN503);

				DebugLocation(1148, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1148:9: ( ( expression direction )=> expression direction expression -> ^( NAME_SLICE_PART ^( direction expression expression ) ) | association_list -> association_list )
				int alt160=2;
				try { DebugEnterSubRule(160);
				try { DebugEnterDecision(160, false);
				switch (input.LA(1))
				{
				case MINUS:
				case PLUS:
					{
					int LA160_1 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BINANRY_BASED_INTEGER:
				case DEC_BASED_INTEGER:
				case HEXA_BASED_INTEGER:
				case OCTAL_BASED_INTEGER:
					{
					int LA160_2 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case FLOAT_POINT_LITERAL:
					{
					int LA160_3 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case CHARACTER_LITERAL:
					{
					int LA160_4 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BIT_STRING_LITERAL_BINARY:
					{
					int LA160_5 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 5, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BIT_STRING_LITERAL_OCTAL:
					{
					int LA160_6 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BIT_STRING_LITERAL_HEX:
					{
					int LA160_7 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 7, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case NULLTOK:
					{
					int LA160_8 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 8, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case LPAREN:
					{
					int LA160_9 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 9, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case NEW:
					{
					int LA160_10 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 10, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BASIC_IDENTIFIER:
				case EXTENDED_IDENTIFIER:
					{
					int LA160_11 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 11, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case STRING_LITERAL:
					{
					int LA160_12 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 12, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case ABS:
					{
					int LA160_13 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 13, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case NOT:
					{
					int LA160_14 = input.LA(2);

					if ((EvaluatePredicate(synpred11_VhdlAntlr_fragment)))
					{
						alt160 = 1;
					}
					else if ((true))
					{
						alt160 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 14, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case OPEN:
					{
					alt160 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 160, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(160); }
				switch (alt160)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1149:17: ( expression direction )=> expression direction expression
					{
					DebugLocation(1149, 42);
					PushFollow(Follow._expression_in_name_with_association_part11283);
					expression504=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression504.Tree);
					DebugLocation(1149, 53);
					PushFollow(Follow._direction_in_name_with_association_part11285);
					direction505=direction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_direction.Add(direction505.Tree);
					DebugLocation(1149, 63);
					PushFollow(Follow._expression_in_name_with_association_part11287);
					expression506=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression506.Tree);


					{
					// AST REWRITE
					// elements: direction, expression, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1150:17: -> ^( NAME_SLICE_PART ^( direction expression expression ) )
					{
						DebugLocation(1150, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1150:20: ^( NAME_SLICE_PART ^( direction expression expression ) )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1150, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_SLICE_PART, "NAME_SLICE_PART"), root_1);

						DebugLocation(1150, 39);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1150:39: ^( direction expression expression )
						{
						CommonTree root_2 = (CommonTree)adaptor.Nil();
						DebugLocation(1150, 42);
						root_2 = (CommonTree)adaptor.BecomeRoot(stream_direction.NextNode(), root_2);

						DebugLocation(1150, 52);
						adaptor.AddChild(root_2, stream_expression.NextTree());
						DebugLocation(1150, 63);
						adaptor.AddChild(root_2, stream_expression.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1151:17: association_list
					{
					DebugLocation(1151, 17);
					PushFollow(Follow._association_list_in_name_with_association_part11339);
					association_list507=association_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_association_list.Add(association_list507.Tree);


					{
					// AST REWRITE
					// elements: association_list
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1152:17: -> association_list
					{
						DebugLocation(1152, 20);
						adaptor.AddChild(root_0, stream_association_list.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(160); }

				DebugLocation(1154, 9);
				RPAREN508=(IToken)Match(input,RPAREN,Follow._RPAREN_in_name_with_association_part11379); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN508);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1155:9: name_attribute_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1155, 9);
				PushFollow(Follow._name_attribute_part_in_name_with_association_part11389);
				name_attribute_part509=name_attribute_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_attribute_part509.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_with_association_part", 136);
			LeaveRule("name_with_association_part", 136);
			LeaveRule_name_with_association_part();
			if (state.backtracking > 0) { Memoize(input, 136, name_with_association_part_StartIndex); }

		}
		DebugLocation(1156, 4);
		} finally { DebugExitRule(GrammarFileName, "name_with_association_part"); }
		return retval;

	}
	// $ANTLR end "name_with_association_part"

	partial void EnterRule_name_without_parens_part();
	partial void LeaveRule_name_without_parens_part();

	// $ANTLR start "name_without_parens_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1158:1: name_without_parens_part : ( name_selected_part | name_attribute_part );
	[GrammarRule("name_without_parens_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_without_parens_part()
	{
		EnterRule_name_without_parens_part();
		EnterRule("name_without_parens_part", 137);
		TraceIn("name_without_parens_part", 137);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_without_parens_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name_selected_part510 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name_attribute_part511 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "name_without_parens_part");
		DebugLocation(1158, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 137)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1159:5: ( name_selected_part | name_attribute_part )
			int alt162=2;
			try { DebugEnterDecision(162, false);
			int LA162_0 = input.LA(1);

			if ((LA162_0==DOT))
			{
				alt162 = 1;
			}
			else if ((LA162_0==APOSTROPHE||LA162_0==LBRACKET))
			{
				alt162 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 162, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(162); }
			switch (alt162)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1159:9: name_selected_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1159, 9);
				PushFollow(Follow._name_selected_part_in_name_without_parens_part11408);
				name_selected_part510=name_selected_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_selected_part510.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1160:9: name_attribute_part
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1160, 9);
				PushFollow(Follow._name_attribute_part_in_name_without_parens_part11418);
				name_attribute_part511=name_attribute_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name_attribute_part511.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_without_parens_part", 137);
			LeaveRule("name_without_parens_part", 137);
			LeaveRule_name_without_parens_part();
			if (state.backtracking > 0) { Memoize(input, 137, name_without_parens_part_StartIndex); }

		}
		DebugLocation(1161, 4);
		} finally { DebugExitRule(GrammarFileName, "name_without_parens_part"); }
		return retval;

	}
	// $ANTLR end "name_without_parens_part"

	partial void EnterRule_name_prefix();
	partial void LeaveRule_name_prefix();

	// $ANTLR start "name_prefix"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1163:1: name_prefix : (simple_name= identifier |operator_symbol= STRING_LITERAL );
	[GrammarRule("name_prefix")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_prefix()
	{
		EnterRule_name_prefix();
		EnterRule("name_prefix", 138);
		TraceIn("name_prefix", 138);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_prefix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken operator_symbol = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> simple_name = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree operator_symbol_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "name_prefix");
		DebugLocation(1163, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 138)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1164:5: (simple_name= identifier |operator_symbol= STRING_LITERAL )
			int alt163=2;
			try { DebugEnterDecision(163, false);
			int LA163_0 = input.LA(1);

			if ((LA163_0==BASIC_IDENTIFIER||LA163_0==EXTENDED_IDENTIFIER))
			{
				alt163 = 1;
			}
			else if ((LA163_0==STRING_LITERAL))
			{
				alt163 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 163, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(163); }
			switch (alt163)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1164:9: simple_name= identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1164, 20);
				PushFollow(Follow._identifier_in_name_prefix11439);
				simple_name=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_name.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1165:9: operator_symbol= STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1165, 24);
				operator_symbol=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_name_prefix11451); if (state.failed) return retval;
				if (state.backtracking == 0) {
				operator_symbol_tree = (CommonTree)adaptor.Create(operator_symbol);
				adaptor.AddChild(root_0, operator_symbol_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_prefix", 138);
			LeaveRule("name_prefix", 138);
			LeaveRule_name_prefix();
			if (state.backtracking > 0) { Memoize(input, 138, name_prefix_StartIndex); }

		}
		DebugLocation(1166, 4);
		} finally { DebugExitRule(GrammarFileName, "name_prefix"); }
		return retval;

	}
	// $ANTLR end "name_prefix"

	partial void EnterRule_name_selected_part();
	partial void LeaveRule_name_selected_part();

	// $ANTLR start "name_selected_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1168:1: name_selected_part : DOT suffix -> ^( NAME_SELECTED_PART suffix ) ;
	[GrammarRule("name_selected_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_selected_part()
	{
		EnterRule_name_selected_part();
		EnterRule("name_selected_part", 139);
		TraceIn("name_selected_part", 139);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_selected_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken DOT512 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> suffix513 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT512_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_suffix=new RewriteRuleSubtreeStream(adaptor,"rule suffix");
		try { DebugEnterRule(GrammarFileName, "name_selected_part");
		DebugLocation(1168, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 139)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1169:5: ( DOT suffix -> ^( NAME_SELECTED_PART suffix ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1169:9: DOT suffix
			{
			DebugLocation(1169, 9);
			DOT512=(IToken)Match(input,DOT,Follow._DOT_in_name_selected_part11470); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT512);

			DebugLocation(1169, 13);
			PushFollow(Follow._suffix_in_name_selected_part11472);
			suffix513=suffix();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_suffix.Add(suffix513.Tree);


			{
			// AST REWRITE
			// elements: suffix
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1170:9: -> ^( NAME_SELECTED_PART suffix )
			{
				DebugLocation(1170, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1170:12: ^( NAME_SELECTED_PART suffix )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1170, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_SELECTED_PART, "NAME_SELECTED_PART"), root_1);

				DebugLocation(1170, 34);
				adaptor.AddChild(root_1, stream_suffix.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_selected_part", 139);
			LeaveRule("name_selected_part", 139);
			LeaveRule_name_selected_part();
			if (state.backtracking > 0) { Memoize(input, 139, name_selected_part_StartIndex); }

		}
		DebugLocation(1171, 4);
		} finally { DebugExitRule(GrammarFileName, "name_selected_part"); }
		return retval;

	}
	// $ANTLR end "name_selected_part"

	partial void EnterRule_name_attribute_part();
	partial void LeaveRule_name_attribute_part();

	// $ANTLR start "name_attribute_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1173:1: name_attribute_part : ( signature )? APOSTROPHE attribute_designator ( ( LPAREN expression RPAREN )=> LPAREN expression RPAREN )? -> ^( NAME_ATTRIBUTE_PART ( signature )? attribute_designator ( expression )? ) ;
	[GrammarRule("name_attribute_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> name_attribute_part()
	{
		EnterRule_name_attribute_part();
		EnterRule("name_attribute_part", 140);
		TraceIn("name_attribute_part", 140);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int name_attribute_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken APOSTROPHE515 = default(IToken);
		IToken LPAREN517 = default(IToken);
		IToken RPAREN519 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> signature514 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_designator516 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression518 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree APOSTROPHE515_tree = default(CommonTree);
		CommonTree LPAREN517_tree = default(CommonTree);
		CommonTree RPAREN519_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_APOSTROPHE=new RewriteRuleITokenStream(adaptor,"token APOSTROPHE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_attribute_designator=new RewriteRuleSubtreeStream(adaptor,"rule attribute_designator");
		RewriteRuleSubtreeStream stream_signature=new RewriteRuleSubtreeStream(adaptor,"rule signature");
		try { DebugEnterRule(GrammarFileName, "name_attribute_part");
		DebugLocation(1173, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 140)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1174:5: ( ( signature )? APOSTROPHE attribute_designator ( ( LPAREN expression RPAREN )=> LPAREN expression RPAREN )? -> ^( NAME_ATTRIBUTE_PART ( signature )? attribute_designator ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1174:9: ( signature )? APOSTROPHE attribute_designator ( ( LPAREN expression RPAREN )=> LPAREN expression RPAREN )?
			{
			DebugLocation(1174, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1174:9: ( signature )?
			int alt164=2;
			try { DebugEnterSubRule(164);
			try { DebugEnterDecision(164, false);
			int LA164_0 = input.LA(1);

			if ((LA164_0==LBRACKET))
			{
				alt164 = 1;
			}
			} finally { DebugExitDecision(164); }
			switch (alt164)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1174:9: signature
				{
				DebugLocation(1174, 9);
				PushFollow(Follow._signature_in_name_attribute_part11509);
				signature514=signature();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_signature.Add(signature514.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(164); }

			DebugLocation(1174, 20);
			APOSTROPHE515=(IToken)Match(input,APOSTROPHE,Follow._APOSTROPHE_in_name_attribute_part11512); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_APOSTROPHE.Add(APOSTROPHE515);

			DebugLocation(1174, 31);
			PushFollow(Follow._attribute_designator_in_name_attribute_part11514);
			attribute_designator516=attribute_designator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_attribute_designator.Add(attribute_designator516.Tree);
			DebugLocation(1175, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1175:9: ( ( LPAREN expression RPAREN )=> LPAREN expression RPAREN )?
			int alt165=2;
			try { DebugEnterSubRule(165);
			try { DebugEnterDecision(165, false);
			int LA165_0 = input.LA(1);

			if ((LA165_0==LPAREN))
			{
				int LA165_1 = input.LA(2);

				if ((EvaluatePredicate(synpred12_VhdlAntlr_fragment)))
				{
					alt165 = 1;
				}
			}
			} finally { DebugExitDecision(165); }
			switch (alt165)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1175:11: ( LPAREN expression RPAREN )=> LPAREN expression RPAREN
				{
				DebugLocation(1175, 40);
				LPAREN517=(IToken)Match(input,LPAREN,Follow._LPAREN_in_name_attribute_part11535); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN517);

				DebugLocation(1175, 47);
				PushFollow(Follow._expression_in_name_attribute_part11537);
				expression518=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression518.Tree);
				DebugLocation(1175, 58);
				RPAREN519=(IToken)Match(input,RPAREN,Follow._RPAREN_in_name_attribute_part11539); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN519);


				}
				break;

			}
			} finally { DebugExitSubRule(165); }



			{
			// AST REWRITE
			// elements: attribute_designator, expression, signature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1176:9: -> ^( NAME_ATTRIBUTE_PART ( signature )? attribute_designator ( expression )? )
			{
				DebugLocation(1176, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1176:12: ^( NAME_ATTRIBUTE_PART ( signature )? attribute_designator ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1176, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME_ATTRIBUTE_PART, "NAME_ATTRIBUTE_PART"), root_1);

				DebugLocation(1176, 35);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1176:35: ( signature )?
				if (stream_signature.HasNext)
				{
					DebugLocation(1176, 35);
					adaptor.AddChild(root_1, stream_signature.NextTree());

				}
				stream_signature.Reset();
				DebugLocation(1176, 46);
				adaptor.AddChild(root_1, stream_attribute_designator.NextTree());
				DebugLocation(1176, 67);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1176:67: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(1176, 67);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name_attribute_part", 140);
			LeaveRule("name_attribute_part", 140);
			LeaveRule_name_attribute_part();
			if (state.backtracking > 0) { Memoize(input, 140, name_attribute_part_StartIndex); }

		}
		DebugLocation(1177, 4);
		} finally { DebugExitRule(GrammarFileName, "name_attribute_part"); }
		return retval;

	}
	// $ANTLR end "name_attribute_part"

	partial void EnterRule_next_statement();
	partial void LeaveRule_next_statement();

	// $ANTLR start "next_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1179:1: next_statement : NEXT (loop_label= identifier )? ( WHEN condition )? SEMI -> ^( NEXT ( $loop_label)? ( condition )? ) ;
	[GrammarRule("next_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> next_statement()
	{
		EnterRule_next_statement();
		EnterRule("next_statement", 141);
		TraceIn("next_statement", 141);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int next_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken NEXT520 = default(IToken);
		IToken WHEN521 = default(IToken);
		IToken SEMI523 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> loop_label = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition522 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEXT520_tree = default(CommonTree);
		CommonTree WHEN521_tree = default(CommonTree);
		CommonTree SEMI523_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEXT=new RewriteRuleITokenStream(adaptor,"token NEXT");
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "next_statement");
		DebugLocation(1179, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 141)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:5: ( NEXT (loop_label= identifier )? ( WHEN condition )? SEMI -> ^( NEXT ( $loop_label)? ( condition )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:9: NEXT (loop_label= identifier )? ( WHEN condition )? SEMI
			{
			DebugLocation(1180, 9);
			NEXT520=(IToken)Match(input,NEXT,Follow._NEXT_in_next_statement11585); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEXT.Add(NEXT520);

			DebugLocation(1180, 24);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:24: (loop_label= identifier )?
			int alt166=2;
			try { DebugEnterSubRule(166);
			try { DebugEnterDecision(166, false);
			int LA166_0 = input.LA(1);

			if ((LA166_0==BASIC_IDENTIFIER||LA166_0==EXTENDED_IDENTIFIER))
			{
				alt166 = 1;
			}
			} finally { DebugExitDecision(166); }
			switch (alt166)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:24: loop_label= identifier
				{
				DebugLocation(1180, 24);
				PushFollow(Follow._identifier_in_next_statement11589);
				loop_label=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(loop_label.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(166); }

			DebugLocation(1180, 37);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:37: ( WHEN condition )?
			int alt167=2;
			try { DebugEnterSubRule(167);
			try { DebugEnterDecision(167, false);
			int LA167_0 = input.LA(1);

			if ((LA167_0==WHEN))
			{
				alt167 = 1;
			}
			} finally { DebugExitDecision(167); }
			switch (alt167)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1180:39: WHEN condition
				{
				DebugLocation(1180, 39);
				WHEN521=(IToken)Match(input,WHEN,Follow._WHEN_in_next_statement11594); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHEN.Add(WHEN521);

				DebugLocation(1180, 44);
				PushFollow(Follow._condition_in_next_statement11596);
				condition522=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition522.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(167); }

			DebugLocation(1180, 57);
			SEMI523=(IToken)Match(input,SEMI,Follow._SEMI_in_next_statement11601); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI523);



			{
			// AST REWRITE
			// elements: loop_label, NEXT, condition
			// token labels: 
			// rule labels: loop_label, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_loop_label=new RewriteRuleSubtreeStream(adaptor,"rule loop_label",loop_label!=null?loop_label.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1181:9: -> ^( NEXT ( $loop_label)? ( condition )? )
			{
				DebugLocation(1181, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1181:12: ^( NEXT ( $loop_label)? ( condition )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1181, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_NEXT.NextNode(), root_1);

				DebugLocation(1181, 21);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1181:21: ( $loop_label)?
				if (stream_loop_label.HasNext)
				{
					DebugLocation(1181, 21);
					adaptor.AddChild(root_1, stream_loop_label.NextTree());

				}
				stream_loop_label.Reset();
				DebugLocation(1181, 33);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1181:33: ( condition )?
				if (stream_condition.HasNext)
				{
					DebugLocation(1181, 33);
					adaptor.AddChild(root_1, stream_condition.NextTree());

				}
				stream_condition.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("next_statement", 141);
			LeaveRule("next_statement", 141);
			LeaveRule_next_statement();
			if (state.backtracking > 0) { Memoize(input, 141, next_statement_StartIndex); }

		}
		DebugLocation(1182, 4);
		} finally { DebugExitRule(GrammarFileName, "next_statement"); }
		return retval;

	}
	// $ANTLR end "next_statement"

	partial void EnterRule_null_statement();
	partial void LeaveRule_null_statement();

	// $ANTLR start "null_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1184:1: null_statement : NULLTOK SEMI -> NULLTOK ;
	[GrammarRule("null_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> null_statement()
	{
		EnterRule_null_statement();
		EnterRule("null_statement", 142);
		TraceIn("null_statement", 142);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int null_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken NULLTOK524 = default(IToken);
		IToken SEMI525 = default(IToken);

		CommonTree NULLTOK524_tree = default(CommonTree);
		CommonTree SEMI525_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NULLTOK=new RewriteRuleITokenStream(adaptor,"token NULLTOK");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		try { DebugEnterRule(GrammarFileName, "null_statement");
		DebugLocation(1184, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 142)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1185:5: ( NULLTOK SEMI -> NULLTOK )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1185:9: NULLTOK SEMI
			{
			DebugLocation(1185, 9);
			NULLTOK524=(IToken)Match(input,NULLTOK,Follow._NULLTOK_in_null_statement11643); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NULLTOK.Add(NULLTOK524);

			DebugLocation(1185, 17);
			SEMI525=(IToken)Match(input,SEMI,Follow._SEMI_in_null_statement11645); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI525);



			{
			// AST REWRITE
			// elements: NULLTOK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1186:9: -> NULLTOK
			{
				DebugLocation(1186, 12);
				adaptor.AddChild(root_0, stream_NULLTOK.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("null_statement", 142);
			LeaveRule("null_statement", 142);
			LeaveRule_null_statement();
			if (state.backtracking > 0) { Memoize(input, 142, null_statement_StartIndex); }

		}
		DebugLocation(1187, 4);
		} finally { DebugExitRule(GrammarFileName, "null_statement"); }
		return retval;

	}
	// $ANTLR end "null_statement"

	partial void EnterRule_signal_assignment_options();
	partial void LeaveRule_signal_assignment_options();

	// $ANTLR start "signal_assignment_options"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1190:1: signal_assignment_options : ( GUARDED )? ( delay_mechanism )? ;
	[GrammarRule("signal_assignment_options")]
	private AstParserRuleReturnScope<CommonTree, IToken> signal_assignment_options()
	{
		EnterRule_signal_assignment_options();
		EnterRule("signal_assignment_options", 143);
		TraceIn("signal_assignment_options", 143);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signal_assignment_options_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken GUARDED526 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> delay_mechanism527 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree GUARDED526_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "signal_assignment_options");
		DebugLocation(1190, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 143)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:5: ( ( GUARDED )? ( delay_mechanism )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:9: ( GUARDED )? ( delay_mechanism )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1191, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:9: ( GUARDED )?
			int alt168=2;
			try { DebugEnterSubRule(168);
			try { DebugEnterDecision(168, false);
			int LA168_0 = input.LA(1);

			if ((LA168_0==GUARDED))
			{
				alt168 = 1;
			}
			} finally { DebugExitDecision(168); }
			switch (alt168)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:9: GUARDED
				{
				DebugLocation(1191, 9);
				GUARDED526=(IToken)Match(input,GUARDED,Follow._GUARDED_in_signal_assignment_options11677); if (state.failed) return retval;
				if (state.backtracking == 0) {
				GUARDED526_tree = (CommonTree)adaptor.Create(GUARDED526);
				adaptor.AddChild(root_0, GUARDED526_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(168); }

			DebugLocation(1191, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:18: ( delay_mechanism )?
			int alt169=2;
			try { DebugEnterSubRule(169);
			try { DebugEnterDecision(169, false);
			int LA169_0 = input.LA(1);

			if ((LA169_0==INERTIAL||LA169_0==REJECT||LA169_0==TRANSPORT))
			{
				alt169 = 1;
			}
			} finally { DebugExitDecision(169); }
			switch (alt169)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1191:18: delay_mechanism
				{
				DebugLocation(1191, 18);
				PushFollow(Follow._delay_mechanism_in_signal_assignment_options11680);
				delay_mechanism527=delay_mechanism();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, delay_mechanism527.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(169); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signal_assignment_options", 143);
			LeaveRule("signal_assignment_options", 143);
			LeaveRule_signal_assignment_options();
			if (state.backtracking > 0) { Memoize(input, 143, signal_assignment_options_StartIndex); }

		}
		DebugLocation(1192, 4);
		} finally { DebugExitRule(GrammarFileName, "signal_assignment_options"); }
		return retval;

	}
	// $ANTLR end "signal_assignment_options"

	partial void EnterRule_package_body();
	partial void LeaveRule_package_body();

	// $ANTLR start "package_body"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1195:1: package_body : PACKAGE BODY identifier IS ( package_body_declarative_part )? END ( PACKAGE BODY )? ( end_identifier )? SEMI -> ^( PACKAGE_BODY ( identifier )? ( package_body_declarative_part )? ( end_identifier )? ) ;
	[GrammarRule("package_body")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_body()
	{
		EnterRule_package_body();
		EnterRule("package_body", 144);
		TraceIn("package_body", 144);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_body_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PACKAGE528 = default(IToken);
		IToken BODY529 = default(IToken);
		IToken IS531 = default(IToken);
		IToken END533 = default(IToken);
		IToken PACKAGE534 = default(IToken);
		IToken BODY535 = default(IToken);
		IToken SEMI537 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier530 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> package_body_declarative_part532 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier536 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PACKAGE528_tree = default(CommonTree);
		CommonTree BODY529_tree = default(CommonTree);
		CommonTree IS531_tree = default(CommonTree);
		CommonTree END533_tree = default(CommonTree);
		CommonTree PACKAGE534_tree = default(CommonTree);
		CommonTree BODY535_tree = default(CommonTree);
		CommonTree SEMI537_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PACKAGE=new RewriteRuleITokenStream(adaptor,"token PACKAGE");
		RewriteRuleITokenStream stream_BODY=new RewriteRuleITokenStream(adaptor,"token BODY");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_package_body_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule package_body_declarative_part");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "package_body");
		DebugLocation(1195, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 144)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1196:5: ( PACKAGE BODY identifier IS ( package_body_declarative_part )? END ( PACKAGE BODY )? ( end_identifier )? SEMI -> ^( PACKAGE_BODY ( identifier )? ( package_body_declarative_part )? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1196:9: PACKAGE BODY identifier IS ( package_body_declarative_part )? END ( PACKAGE BODY )? ( end_identifier )? SEMI
			{
			DebugLocation(1196, 9);
			PACKAGE528=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_package_body11701); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE528);

			DebugLocation(1196, 17);
			BODY529=(IToken)Match(input,BODY,Follow._BODY_in_package_body11703); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BODY.Add(BODY529);

			DebugLocation(1196, 22);
			PushFollow(Follow._identifier_in_package_body11705);
			identifier530=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier530.Tree);
			DebugLocation(1196, 33);
			IS531=(IToken)Match(input,IS,Follow._IS_in_package_body11707); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS531);

			DebugLocation(1197, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1197:9: ( package_body_declarative_part )?
			int alt170=2;
			try { DebugEnterSubRule(170);
			try { DebugEnterDecision(170, false);
			int LA170_0 = input.LA(1);

			if ((LA170_0==ALIAS||LA170_0==CONSTANT||LA170_0==FILE||LA170_0==FUNCTION||LA170_0==GROUP||LA170_0==IMPURE||LA170_0==PROCEDURE||LA170_0==PURE||LA170_0==SHARED||LA170_0==SUBTYPE||LA170_0==TYPE||LA170_0==USE||LA170_0==VARIABLE))
			{
				alt170 = 1;
			}
			} finally { DebugExitDecision(170); }
			switch (alt170)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1197:9: package_body_declarative_part
				{
				DebugLocation(1197, 9);
				PushFollow(Follow._package_body_declarative_part_in_package_body11717);
				package_body_declarative_part532=package_body_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_package_body_declarative_part.Add(package_body_declarative_part532.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(170); }

			DebugLocation(1198, 9);
			END533=(IToken)Match(input,END,Follow._END_in_package_body11728); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END533);

			DebugLocation(1198, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1198:13: ( PACKAGE BODY )?
			int alt171=2;
			try { DebugEnterSubRule(171);
			try { DebugEnterDecision(171, false);
			int LA171_0 = input.LA(1);

			if ((LA171_0==PACKAGE))
			{
				alt171 = 1;
			}
			} finally { DebugExitDecision(171); }
			switch (alt171)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1198:15: PACKAGE BODY
				{
				DebugLocation(1198, 15);
				PACKAGE534=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_package_body11732); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE534);

				DebugLocation(1198, 23);
				BODY535=(IToken)Match(input,BODY,Follow._BODY_in_package_body11734); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BODY.Add(BODY535);


				}
				break;

			}
			} finally { DebugExitSubRule(171); }

			DebugLocation(1198, 31);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1198:31: ( end_identifier )?
			int alt172=2;
			try { DebugEnterSubRule(172);
			try { DebugEnterDecision(172, false);
			int LA172_0 = input.LA(1);

			if ((LA172_0==BASIC_IDENTIFIER||LA172_0==EXTENDED_IDENTIFIER))
			{
				alt172 = 1;
			}
			} finally { DebugExitDecision(172); }
			switch (alt172)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1198:31: end_identifier
				{
				DebugLocation(1198, 31);
				PushFollow(Follow._end_identifier_in_package_body11739);
				end_identifier536=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier536.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(172); }

			DebugLocation(1198, 47);
			SEMI537=(IToken)Match(input,SEMI,Follow._SEMI_in_package_body11742); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI537);



			{
			// AST REWRITE
			// elements: identifier, end_identifier, package_body_declarative_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1199:9: -> ^( PACKAGE_BODY ( identifier )? ( package_body_declarative_part )? ( end_identifier )? )
			{
				DebugLocation(1199, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1199:12: ^( PACKAGE_BODY ( identifier )? ( package_body_declarative_part )? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1199, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PACKAGE_BODY, "PACKAGE_BODY"), root_1);

				DebugLocation(1199, 28);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1199:28: ( identifier )?
				if (stream_identifier.HasNext)
				{
					DebugLocation(1199, 28);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();
				DebugLocation(1199, 40);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1199:40: ( package_body_declarative_part )?
				if (stream_package_body_declarative_part.HasNext)
				{
					DebugLocation(1199, 40);
					adaptor.AddChild(root_1, stream_package_body_declarative_part.NextTree());

				}
				stream_package_body_declarative_part.Reset();
				DebugLocation(1199, 71);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1199:71: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(1199, 71);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_body", 144);
			LeaveRule("package_body", 144);
			LeaveRule_package_body();
			if (state.backtracking > 0) { Memoize(input, 144, package_body_StartIndex); }

		}
		DebugLocation(1200, 4);
		} finally { DebugExitRule(GrammarFileName, "package_body"); }
		return retval;

	}
	// $ANTLR end "package_body"

	partial void EnterRule_package_body_declarative_item();
	partial void LeaveRule_package_body_declarative_item();

	// $ANTLR start "package_body_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1202:1: package_body_declarative_item : ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("package_body_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_body_declarative_item()
	{
		EnterRule_package_body_declarative_item();
		EnterRule("package_body_declarative_item", 145);
		TraceIn("package_body_declarative_item", 145);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_body_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shared_variable_declaration = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration538 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration539 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration540 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration541 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration542 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration543 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause544 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration545 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration546 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "package_body_declarative_item");
		DebugLocation(1202, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 145)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1203:5: ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | use_clause | group_template_declaration | group_declaration )
			int alt173=10;
			try { DebugEnterDecision(173, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt173 = 1;
				}
				break;
			case TYPE:
				{
				alt173 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt173 = 3;
				}
				break;
			case CONSTANT:
				{
				alt173 = 4;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt173 = 5;
				}
				break;
			case FILE:
				{
				alt173 = 6;
				}
				break;
			case ALIAS:
				{
				alt173 = 7;
				}
				break;
			case USE:
				{
				alt173 = 8;
				}
				break;
			case GROUP:
				{
				int LA173_9 = input.LA(2);

				if ((LA173_9==BASIC_IDENTIFIER||LA173_9==EXTENDED_IDENTIFIER))
				{
					int LA173_10 = input.LA(3);

					if ((LA173_10==IS))
					{
						alt173 = 9;
					}
					else if ((LA173_10==COLON))
					{
						alt173 = 10;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 173, 10, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 173, 9, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 173, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(173); }
			switch (alt173)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1203:9: subprogram_body_or_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1203, 9);
				PushFollow(Follow._subprogram_body_or_declaration_in_package_body_declarative_item11785);
				subprogram_body_or_declaration538=subprogram_body_or_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_body_or_declaration538.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1204:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1204, 9);
				PushFollow(Follow._type_declaration_in_package_body_declarative_item11795);
				type_declaration539=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration539.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1205:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1205, 9);
				PushFollow(Follow._subtype_declaration_in_package_body_declarative_item11805);
				subtype_declaration540=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration540.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1206:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1206, 9);
				PushFollow(Follow._constant_declaration_in_package_body_declarative_item11815);
				constant_declaration541=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration541.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1207:9: shared_variable_declaration= variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1207, 36);
				PushFollow(Follow._variable_declaration_in_package_body_declarative_item11827);
				shared_variable_declaration=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, shared_variable_declaration.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1208:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1208, 9);
				PushFollow(Follow._file_declaration_in_package_body_declarative_item11837);
				file_declaration542=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration542.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1209:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1209, 9);
				PushFollow(Follow._alias_declaration_in_package_body_declarative_item11847);
				alias_declaration543=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration543.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1210:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1210, 9);
				PushFollow(Follow._use_clause_in_package_body_declarative_item11857);
				use_clause544=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause544.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1211:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1211, 9);
				PushFollow(Follow._group_template_declaration_in_package_body_declarative_item11867);
				group_template_declaration545=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration545.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1212:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1212, 9);
				PushFollow(Follow._group_declaration_in_package_body_declarative_item11877);
				group_declaration546=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration546.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_body_declarative_item", 145);
			LeaveRule("package_body_declarative_item", 145);
			LeaveRule_package_body_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 145, package_body_declarative_item_StartIndex); }

		}
		DebugLocation(1213, 4);
		} finally { DebugExitRule(GrammarFileName, "package_body_declarative_item"); }
		return retval;

	}
	// $ANTLR end "package_body_declarative_item"

	partial void EnterRule_package_body_declarative_part();
	partial void LeaveRule_package_body_declarative_part();

	// $ANTLR start "package_body_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1215:1: package_body_declarative_part : ( package_body_declarative_item )+ ;
	[GrammarRule("package_body_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_body_declarative_part()
	{
		EnterRule_package_body_declarative_part();
		EnterRule("package_body_declarative_part", 146);
		TraceIn("package_body_declarative_part", 146);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_body_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> package_body_declarative_item547 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "package_body_declarative_part");
		DebugLocation(1215, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 146)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1216:5: ( ( package_body_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1216:9: ( package_body_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1216, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1216:9: ( package_body_declarative_item )+
			int cnt174=0;
			try { DebugEnterSubRule(174);
			while (true)
			{
				int alt174=2;
				try { DebugEnterDecision(174, false);
				int LA174_0 = input.LA(1);

				if ((LA174_0==ALIAS||LA174_0==CONSTANT||LA174_0==FILE||LA174_0==FUNCTION||LA174_0==GROUP||LA174_0==IMPURE||LA174_0==PROCEDURE||LA174_0==PURE||LA174_0==SHARED||LA174_0==SUBTYPE||LA174_0==TYPE||LA174_0==USE||LA174_0==VARIABLE))
				{
					alt174 = 1;
				}


				} finally { DebugExitDecision(174); }
				switch (alt174)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1216:9: package_body_declarative_item
					{
					DebugLocation(1216, 9);
					PushFollow(Follow._package_body_declarative_item_in_package_body_declarative_part11896);
					package_body_declarative_item547=package_body_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, package_body_declarative_item547.Tree);

					}
					break;

				default:
					if (cnt174 >= 1)
						goto loop174;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee174 = new EarlyExitException( 174, input );
					DebugRecognitionException(eee174);
					throw eee174;
				}
				cnt174++;
			}
			loop174:
				;

			} finally { DebugExitSubRule(174); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_body_declarative_part", 146);
			LeaveRule("package_body_declarative_part", 146);
			LeaveRule_package_body_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 146, package_body_declarative_part_StartIndex); }

		}
		DebugLocation(1217, 4);
		} finally { DebugExitRule(GrammarFileName, "package_body_declarative_part"); }
		return retval;

	}
	// $ANTLR end "package_body_declarative_part"

	partial void EnterRule_package_declaration();
	partial void LeaveRule_package_declaration();

	// $ANTLR start "package_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1220:1: package_declaration : PACKAGE identifier IS ( package_declarative_part )? END ( PACKAGE )? ( end_identifier )? SEMI -> ^( PACKAGE identifier ( package_declarative_part )? ( end_identifier )? ) ;
	[GrammarRule("package_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_declaration()
	{
		EnterRule_package_declaration();
		EnterRule("package_declaration", 147);
		TraceIn("package_declaration", 147);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PACKAGE548 = default(IToken);
		IToken IS550 = default(IToken);
		IToken END552 = default(IToken);
		IToken PACKAGE553 = default(IToken);
		IToken SEMI555 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier549 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> package_declarative_part551 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier554 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PACKAGE548_tree = default(CommonTree);
		CommonTree IS550_tree = default(CommonTree);
		CommonTree END552_tree = default(CommonTree);
		CommonTree PACKAGE553_tree = default(CommonTree);
		CommonTree SEMI555_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PACKAGE=new RewriteRuleITokenStream(adaptor,"token PACKAGE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_package_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule package_declarative_part");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "package_declaration");
		DebugLocation(1220, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 147)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1221:5: ( PACKAGE identifier IS ( package_declarative_part )? END ( PACKAGE )? ( end_identifier )? SEMI -> ^( PACKAGE identifier ( package_declarative_part )? ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1221:9: PACKAGE identifier IS ( package_declarative_part )? END ( PACKAGE )? ( end_identifier )? SEMI
			{
			DebugLocation(1221, 9);
			PACKAGE548=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_package_declaration11917); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE548);

			DebugLocation(1221, 17);
			PushFollow(Follow._identifier_in_package_declaration11919);
			identifier549=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier549.Tree);
			DebugLocation(1221, 28);
			IS550=(IToken)Match(input,IS,Follow._IS_in_package_declaration11921); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS550);

			DebugLocation(1222, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1222:9: ( package_declarative_part )?
			int alt175=2;
			try { DebugEnterSubRule(175);
			try { DebugEnterDecision(175, false);
			int LA175_0 = input.LA(1);

			if ((LA175_0==ALIAS||LA175_0==ATTRIBUTE||LA175_0==COMPONENT||LA175_0==CONSTANT||LA175_0==DISCONNECT||LA175_0==FILE||LA175_0==FUNCTION||LA175_0==GROUP||LA175_0==IMPURE||LA175_0==PROCEDURE||LA175_0==PURE||(LA175_0>=SHARED && LA175_0<=SIGNAL)||LA175_0==SUBTYPE||LA175_0==TYPE||LA175_0==USE||LA175_0==VARIABLE))
			{
				alt175 = 1;
			}
			} finally { DebugExitDecision(175); }
			switch (alt175)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1222:9: package_declarative_part
				{
				DebugLocation(1222, 9);
				PushFollow(Follow._package_declarative_part_in_package_declaration11931);
				package_declarative_part551=package_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_package_declarative_part.Add(package_declarative_part551.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(175); }

			DebugLocation(1223, 9);
			END552=(IToken)Match(input,END,Follow._END_in_package_declaration11942); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END552);

			DebugLocation(1223, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1223:13: ( PACKAGE )?
			int alt176=2;
			try { DebugEnterSubRule(176);
			try { DebugEnterDecision(176, false);
			int LA176_0 = input.LA(1);

			if ((LA176_0==PACKAGE))
			{
				alt176 = 1;
			}
			} finally { DebugExitDecision(176); }
			switch (alt176)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1223:13: PACKAGE
				{
				DebugLocation(1223, 13);
				PACKAGE553=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_package_declaration11944); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE553);


				}
				break;

			}
			} finally { DebugExitSubRule(176); }

			DebugLocation(1223, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1223:22: ( end_identifier )?
			int alt177=2;
			try { DebugEnterSubRule(177);
			try { DebugEnterDecision(177, false);
			int LA177_0 = input.LA(1);

			if ((LA177_0==BASIC_IDENTIFIER||LA177_0==EXTENDED_IDENTIFIER))
			{
				alt177 = 1;
			}
			} finally { DebugExitDecision(177); }
			switch (alt177)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1223:22: end_identifier
				{
				DebugLocation(1223, 22);
				PushFollow(Follow._end_identifier_in_package_declaration11947);
				end_identifier554=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier554.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(177); }

			DebugLocation(1223, 38);
			SEMI555=(IToken)Match(input,SEMI,Follow._SEMI_in_package_declaration11950); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI555);



			{
			// AST REWRITE
			// elements: PACKAGE, end_identifier, package_declarative_part, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1224:9: -> ^( PACKAGE identifier ( package_declarative_part )? ( end_identifier )? )
			{
				DebugLocation(1224, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1224:12: ^( PACKAGE identifier ( package_declarative_part )? ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1224, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_PACKAGE.NextNode(), root_1);

				DebugLocation(1224, 23);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1224, 34);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1224:34: ( package_declarative_part )?
				if (stream_package_declarative_part.HasNext)
				{
					DebugLocation(1224, 34);
					adaptor.AddChild(root_1, stream_package_declarative_part.NextTree());

				}
				stream_package_declarative_part.Reset();
				DebugLocation(1224, 60);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1224:60: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(1224, 60);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_declaration", 147);
			LeaveRule("package_declaration", 147);
			LeaveRule_package_declaration();
			if (state.backtracking > 0) { Memoize(input, 147, package_declaration_StartIndex); }

		}
		DebugLocation(1225, 4);
		} finally { DebugExitRule(GrammarFileName, "package_declaration"); }
		return retval;

	}
	// $ANTLR end "package_declaration"

	partial void EnterRule_package_declarative_item();
	partial void LeaveRule_package_declarative_item();

	// $ANTLR start "package_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1227:1: package_declarative_item : ( subprogram_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | component_declaration | attribute_declaration | attribute_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("package_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_declarative_item()
	{
		EnterRule_package_declarative_item();
		EnterRule("package_declarative_item", 148);
		TraceIn("package_declarative_item", 148);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shared_variable_declaration = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_declaration556 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration557 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration558 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration559 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signal_declaration560 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration561 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration562 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> component_declaration563 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration564 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification565 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> disconnection_specification566 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause567 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration568 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration569 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "package_declarative_item");
		DebugLocation(1227, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 148)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1228:5: ( subprogram_declaration | type_declaration | subtype_declaration | constant_declaration | signal_declaration |shared_variable_declaration= variable_declaration | file_declaration | alias_declaration | component_declaration | attribute_declaration | attribute_specification | disconnection_specification | use_clause | group_template_declaration | group_declaration )
			int alt178=15;
			try { DebugEnterDecision(178, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt178 = 1;
				}
				break;
			case TYPE:
				{
				alt178 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt178 = 3;
				}
				break;
			case CONSTANT:
				{
				alt178 = 4;
				}
				break;
			case SIGNAL:
				{
				alt178 = 5;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt178 = 6;
				}
				break;
			case FILE:
				{
				alt178 = 7;
				}
				break;
			case ALIAS:
				{
				alt178 = 8;
				}
				break;
			case COMPONENT:
				{
				alt178 = 9;
				}
				break;
			case ATTRIBUTE:
				{
				int LA178_10 = input.LA(2);

				if ((LA178_10==BASIC_IDENTIFIER||LA178_10==EXTENDED_IDENTIFIER))
				{
					int LA178_14 = input.LA(3);

					if ((LA178_14==COLON))
					{
						alt178 = 10;
					}
					else if ((LA178_14==OF))
					{
						alt178 = 11;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 178, 14, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA178_10==RANGETOK))
				{
					alt178 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 178, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DISCONNECT:
				{
				alt178 = 12;
				}
				break;
			case USE:
				{
				alt178 = 13;
				}
				break;
			case GROUP:
				{
				int LA178_13 = input.LA(2);

				if ((LA178_13==BASIC_IDENTIFIER||LA178_13==EXTENDED_IDENTIFIER))
				{
					int LA178_16 = input.LA(3);

					if ((LA178_16==IS))
					{
						alt178 = 14;
					}
					else if ((LA178_16==COLON))
					{
						alt178 = 15;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 178, 16, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 178, 13, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 178, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(178); }
			switch (alt178)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1228:9: subprogram_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1228, 9);
				PushFollow(Follow._subprogram_declaration_in_package_declarative_item11993);
				subprogram_declaration556=subprogram_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_declaration556.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1229:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1229, 9);
				PushFollow(Follow._type_declaration_in_package_declarative_item12003);
				type_declaration557=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration557.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1230:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1230, 9);
				PushFollow(Follow._subtype_declaration_in_package_declarative_item12013);
				subtype_declaration558=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration558.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1231:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1231, 9);
				PushFollow(Follow._constant_declaration_in_package_declarative_item12023);
				constant_declaration559=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration559.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1232:9: signal_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1232, 9);
				PushFollow(Follow._signal_declaration_in_package_declarative_item12033);
				signal_declaration560=signal_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, signal_declaration560.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1233:9: shared_variable_declaration= variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1233, 36);
				PushFollow(Follow._variable_declaration_in_package_declarative_item12045);
				shared_variable_declaration=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, shared_variable_declaration.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1234:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1234, 9);
				PushFollow(Follow._file_declaration_in_package_declarative_item12055);
				file_declaration561=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration561.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1235:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1235, 9);
				PushFollow(Follow._alias_declaration_in_package_declarative_item12065);
				alias_declaration562=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration562.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1236:9: component_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1236, 9);
				PushFollow(Follow._component_declaration_in_package_declarative_item12075);
				component_declaration563=component_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, component_declaration563.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1237:9: attribute_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1237, 9);
				PushFollow(Follow._attribute_declaration_in_package_declarative_item12085);
				attribute_declaration564=attribute_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_declaration564.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1238:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1238, 9);
				PushFollow(Follow._attribute_specification_in_package_declarative_item12095);
				attribute_specification565=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification565.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1239:9: disconnection_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1239, 9);
				PushFollow(Follow._disconnection_specification_in_package_declarative_item12105);
				disconnection_specification566=disconnection_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disconnection_specification566.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1240:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1240, 9);
				PushFollow(Follow._use_clause_in_package_declarative_item12115);
				use_clause567=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause567.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1241:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1241, 9);
				PushFollow(Follow._group_template_declaration_in_package_declarative_item12125);
				group_template_declaration568=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration568.Tree);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1242:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1242, 9);
				PushFollow(Follow._group_declaration_in_package_declarative_item12135);
				group_declaration569=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration569.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_declarative_item", 148);
			LeaveRule("package_declarative_item", 148);
			LeaveRule_package_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 148, package_declarative_item_StartIndex); }

		}
		DebugLocation(1243, 4);
		} finally { DebugExitRule(GrammarFileName, "package_declarative_item"); }
		return retval;

	}
	// $ANTLR end "package_declarative_item"

	partial void EnterRule_package_declarative_part();
	partial void LeaveRule_package_declarative_part();

	// $ANTLR start "package_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1245:1: package_declarative_part : ( package_declarative_item )+ ;
	[GrammarRule("package_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> package_declarative_part()
	{
		EnterRule_package_declarative_part();
		EnterRule("package_declarative_part", 149);
		TraceIn("package_declarative_part", 149);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int package_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> package_declarative_item570 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "package_declarative_part");
		DebugLocation(1245, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 149)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1246:5: ( ( package_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1246:9: ( package_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1246, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1246:9: ( package_declarative_item )+
			int cnt179=0;
			try { DebugEnterSubRule(179);
			while (true)
			{
				int alt179=2;
				try { DebugEnterDecision(179, false);
				int LA179_0 = input.LA(1);

				if ((LA179_0==ALIAS||LA179_0==ATTRIBUTE||LA179_0==COMPONENT||LA179_0==CONSTANT||LA179_0==DISCONNECT||LA179_0==FILE||LA179_0==FUNCTION||LA179_0==GROUP||LA179_0==IMPURE||LA179_0==PROCEDURE||LA179_0==PURE||(LA179_0>=SHARED && LA179_0<=SIGNAL)||LA179_0==SUBTYPE||LA179_0==TYPE||LA179_0==USE||LA179_0==VARIABLE))
				{
					alt179 = 1;
				}


				} finally { DebugExitDecision(179); }
				switch (alt179)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1246:9: package_declarative_item
					{
					DebugLocation(1246, 9);
					PushFollow(Follow._package_declarative_item_in_package_declarative_part12154);
					package_declarative_item570=package_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, package_declarative_item570.Tree);

					}
					break;

				default:
					if (cnt179 >= 1)
						goto loop179;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee179 = new EarlyExitException( 179, input );
					DebugRecognitionException(eee179);
					throw eee179;
				}
				cnt179++;
			}
			loop179:
				;

			} finally { DebugExitSubRule(179); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("package_declarative_part", 149);
			LeaveRule("package_declarative_part", 149);
			LeaveRule_package_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 149, package_declarative_part_StartIndex); }

		}
		DebugLocation(1247, 4);
		} finally { DebugExitRule(GrammarFileName, "package_declarative_part"); }
		return retval;

	}
	// $ANTLR end "package_declarative_part"

	partial void EnterRule_parameter_interface_list_function();
	partial void LeaveRule_parameter_interface_list_function();

	// $ANTLR start "parameter_interface_list_function"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1249:1: parameter_interface_list_function : interface_element_function ( SEMI interface_element_function )* -> ( interface_element_function )+ ;
	[GrammarRule("parameter_interface_list_function")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameter_interface_list_function()
	{
		EnterRule_parameter_interface_list_function();
		EnterRule("parameter_interface_list_function", 150);
		TraceIn("parameter_interface_list_function", 150);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int parameter_interface_list_function_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI572 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> interface_element_function571 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_element_function573 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI572_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_interface_element_function=new RewriteRuleSubtreeStream(adaptor,"rule interface_element_function");
		try { DebugEnterRule(GrammarFileName, "parameter_interface_list_function");
		DebugLocation(1249, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 150)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1250:5: ( interface_element_function ( SEMI interface_element_function )* -> ( interface_element_function )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1250:9: interface_element_function ( SEMI interface_element_function )*
			{
			DebugLocation(1250, 9);
			PushFollow(Follow._interface_element_function_in_parameter_interface_list_function12174);
			interface_element_function571=interface_element_function();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_interface_element_function.Add(interface_element_function571.Tree);
			DebugLocation(1250, 36);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1250:36: ( SEMI interface_element_function )*
			try { DebugEnterSubRule(180);
			while (true)
			{
				int alt180=2;
				try { DebugEnterDecision(180, false);
				int LA180_0 = input.LA(1);

				if ((LA180_0==SEMI))
				{
					alt180 = 1;
				}


				} finally { DebugExitDecision(180); }
				switch ( alt180 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1250:38: SEMI interface_element_function
					{
					DebugLocation(1250, 38);
					SEMI572=(IToken)Match(input,SEMI,Follow._SEMI_in_parameter_interface_list_function12178); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI572);

					DebugLocation(1250, 43);
					PushFollow(Follow._interface_element_function_in_parameter_interface_list_function12180);
					interface_element_function573=interface_element_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_interface_element_function.Add(interface_element_function573.Tree);

					}
					break;

				default:
					goto loop180;
				}
			}

			loop180:
				;

			} finally { DebugExitSubRule(180); }



			{
			// AST REWRITE
			// elements: interface_element_function
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1251:9: -> ( interface_element_function )+
			{
				DebugLocation(1251, 12);
				if (!(stream_interface_element_function.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_interface_element_function.HasNext )
				{
					DebugLocation(1251, 12);
					adaptor.AddChild(root_0, stream_interface_element_function.NextTree());

				}
				stream_interface_element_function.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter_interface_list_function", 150);
			LeaveRule("parameter_interface_list_function", 150);
			LeaveRule_parameter_interface_list_function();
			if (state.backtracking > 0) { Memoize(input, 150, parameter_interface_list_function_StartIndex); }

		}
		DebugLocation(1252, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter_interface_list_function"); }
		return retval;

	}
	// $ANTLR end "parameter_interface_list_function"

	partial void EnterRule_parameter_interface_list_procedure();
	partial void LeaveRule_parameter_interface_list_procedure();

	// $ANTLR start "parameter_interface_list_procedure"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1254:1: parameter_interface_list_procedure : interface_element_procedure ( SEMI interface_element_procedure )* -> ( interface_element_procedure )+ ;
	[GrammarRule("parameter_interface_list_procedure")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameter_interface_list_procedure()
	{
		EnterRule_parameter_interface_list_procedure();
		EnterRule("parameter_interface_list_procedure", 151);
		TraceIn("parameter_interface_list_procedure", 151);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int parameter_interface_list_procedure_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI575 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> interface_element_procedure574 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_element_procedure576 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI575_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_interface_element_procedure=new RewriteRuleSubtreeStream(adaptor,"rule interface_element_procedure");
		try { DebugEnterRule(GrammarFileName, "parameter_interface_list_procedure");
		DebugLocation(1254, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 151)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1255:5: ( interface_element_procedure ( SEMI interface_element_procedure )* -> ( interface_element_procedure )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1255:9: interface_element_procedure ( SEMI interface_element_procedure )*
			{
			DebugLocation(1255, 9);
			PushFollow(Follow._interface_element_procedure_in_parameter_interface_list_procedure12215);
			interface_element_procedure574=interface_element_procedure();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_interface_element_procedure.Add(interface_element_procedure574.Tree);
			DebugLocation(1255, 37);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1255:37: ( SEMI interface_element_procedure )*
			try { DebugEnterSubRule(181);
			while (true)
			{
				int alt181=2;
				try { DebugEnterDecision(181, false);
				int LA181_0 = input.LA(1);

				if ((LA181_0==SEMI))
				{
					alt181 = 1;
				}


				} finally { DebugExitDecision(181); }
				switch ( alt181 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1255:39: SEMI interface_element_procedure
					{
					DebugLocation(1255, 39);
					SEMI575=(IToken)Match(input,SEMI,Follow._SEMI_in_parameter_interface_list_procedure12219); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI575);

					DebugLocation(1255, 44);
					PushFollow(Follow._interface_element_procedure_in_parameter_interface_list_procedure12221);
					interface_element_procedure576=interface_element_procedure();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_interface_element_procedure.Add(interface_element_procedure576.Tree);

					}
					break;

				default:
					goto loop181;
				}
			}

			loop181:
				;

			} finally { DebugExitSubRule(181); }



			{
			// AST REWRITE
			// elements: interface_element_procedure
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1256:9: -> ( interface_element_procedure )+
			{
				DebugLocation(1256, 12);
				if (!(stream_interface_element_procedure.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_interface_element_procedure.HasNext )
				{
					DebugLocation(1256, 12);
					adaptor.AddChild(root_0, stream_interface_element_procedure.NextTree());

				}
				stream_interface_element_procedure.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter_interface_list_procedure", 151);
			LeaveRule("parameter_interface_list_procedure", 151);
			LeaveRule_parameter_interface_list_procedure();
			if (state.backtracking > 0) { Memoize(input, 151, parameter_interface_list_procedure_StartIndex); }

		}
		DebugLocation(1257, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter_interface_list_procedure"); }
		return retval;

	}
	// $ANTLR end "parameter_interface_list_procedure"

	partial void EnterRule_parameter_specification();
	partial void LeaveRule_parameter_specification();

	// $ANTLR start "parameter_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1259:1: parameter_specification : identifier IN discrete_range -> identifier discrete_range ;
	[GrammarRule("parameter_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameter_specification()
	{
		EnterRule_parameter_specification();
		EnterRule("parameter_specification", 152);
		TraceIn("parameter_specification", 152);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int parameter_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken IN578 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier577 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> discrete_range579 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IN578_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_discrete_range=new RewriteRuleSubtreeStream(adaptor,"rule discrete_range");
		try { DebugEnterRule(GrammarFileName, "parameter_specification");
		DebugLocation(1259, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 152)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1260:5: ( identifier IN discrete_range -> identifier discrete_range )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1260:9: identifier IN discrete_range
			{
			DebugLocation(1260, 9);
			PushFollow(Follow._identifier_in_parameter_specification12256);
			identifier577=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier577.Tree);
			DebugLocation(1260, 20);
			IN578=(IToken)Match(input,IN,Follow._IN_in_parameter_specification12258); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IN.Add(IN578);

			DebugLocation(1260, 23);
			PushFollow(Follow._discrete_range_in_parameter_specification12260);
			discrete_range579=discrete_range();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_discrete_range.Add(discrete_range579.Tree);


			{
			// AST REWRITE
			// elements: discrete_range, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1261:9: -> identifier discrete_range
			{
				DebugLocation(1261, 12);
				adaptor.AddChild(root_0, stream_identifier.NextTree());
				DebugLocation(1261, 23);
				adaptor.AddChild(root_0, stream_discrete_range.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter_specification", 152);
			LeaveRule("parameter_specification", 152);
			LeaveRule_parameter_specification();
			if (state.backtracking > 0) { Memoize(input, 152, parameter_specification_StartIndex); }

		}
		DebugLocation(1262, 4);
		} finally { DebugExitRule(GrammarFileName, "parameter_specification"); }
		return retval;

	}
	// $ANTLR end "parameter_specification"

	partial void EnterRule_physical_type_definition();
	partial void LeaveRule_physical_type_definition();

	// $ANTLR start "physical_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1265:1: physical_type_definition : range_constraint UNITS primary_unit_declaration= identifier SEMI ( secondary_unit_declaration )* END UNITS ( end_identifier )? -> ^( PHYSICAL_TYPE_DEFINITION range_constraint $primary_unit_declaration ( secondary_unit_declaration )* identifier ( end_identifier )? ) ;
	[GrammarRule("physical_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> physical_type_definition()
	{
		EnterRule_physical_type_definition();
		EnterRule("physical_type_definition", 153);
		TraceIn("physical_type_definition", 153);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int physical_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken UNITS581 = default(IToken);
		IToken SEMI582 = default(IToken);
		IToken END584 = default(IToken);
		IToken UNITS585 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primary_unit_declaration = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> range_constraint580 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> secondary_unit_declaration583 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier586 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree UNITS581_tree = default(CommonTree);
		CommonTree SEMI582_tree = default(CommonTree);
		CommonTree END584_tree = default(CommonTree);
		CommonTree UNITS585_tree = default(CommonTree);
		RewriteRuleITokenStream stream_UNITS=new RewriteRuleITokenStream(adaptor,"token UNITS");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_range_constraint=new RewriteRuleSubtreeStream(adaptor,"rule range_constraint");
		RewriteRuleSubtreeStream stream_secondary_unit_declaration=new RewriteRuleSubtreeStream(adaptor,"rule secondary_unit_declaration");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "physical_type_definition");
		DebugLocation(1265, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 153)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1266:5: ( range_constraint UNITS primary_unit_declaration= identifier SEMI ( secondary_unit_declaration )* END UNITS ( end_identifier )? -> ^( PHYSICAL_TYPE_DEFINITION range_constraint $primary_unit_declaration ( secondary_unit_declaration )* identifier ( end_identifier )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1266:9: range_constraint UNITS primary_unit_declaration= identifier SEMI ( secondary_unit_declaration )* END UNITS ( end_identifier )?
			{
			DebugLocation(1266, 9);
			PushFollow(Follow._range_constraint_in_physical_type_definition12294);
			range_constraint580=range_constraint();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_range_constraint.Add(range_constraint580.Tree);
			DebugLocation(1266, 26);
			UNITS581=(IToken)Match(input,UNITS,Follow._UNITS_in_physical_type_definition12296); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_UNITS.Add(UNITS581);

			DebugLocation(1267, 33);
			PushFollow(Follow._identifier_in_physical_type_definition12308);
			primary_unit_declaration=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(primary_unit_declaration.Tree);
			DebugLocation(1267, 45);
			SEMI582=(IToken)Match(input,SEMI,Follow._SEMI_in_physical_type_definition12310); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI582);

			DebugLocation(1268, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1268:9: ( secondary_unit_declaration )*
			try { DebugEnterSubRule(182);
			while (true)
			{
				int alt182=2;
				try { DebugEnterDecision(182, false);
				int LA182_0 = input.LA(1);

				if ((LA182_0==BASIC_IDENTIFIER||LA182_0==EXTENDED_IDENTIFIER))
				{
					alt182 = 1;
				}


				} finally { DebugExitDecision(182); }
				switch ( alt182 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1268:9: secondary_unit_declaration
					{
					DebugLocation(1268, 9);
					PushFollow(Follow._secondary_unit_declaration_in_physical_type_definition12320);
					secondary_unit_declaration583=secondary_unit_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_secondary_unit_declaration.Add(secondary_unit_declaration583.Tree);

					}
					break;

				default:
					goto loop182;
				}
			}

			loop182:
				;

			} finally { DebugExitSubRule(182); }

			DebugLocation(1269, 9);
			END584=(IToken)Match(input,END,Follow._END_in_physical_type_definition12331); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END584);

			DebugLocation(1269, 13);
			UNITS585=(IToken)Match(input,UNITS,Follow._UNITS_in_physical_type_definition12333); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_UNITS.Add(UNITS585);

			DebugLocation(1269, 19);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1269:19: ( end_identifier )?
			int alt183=2;
			try { DebugEnterSubRule(183);
			try { DebugEnterDecision(183, false);
			int LA183_0 = input.LA(1);

			if ((LA183_0==BASIC_IDENTIFIER||LA183_0==EXTENDED_IDENTIFIER))
			{
				alt183 = 1;
			}
			} finally { DebugExitDecision(183); }
			switch (alt183)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1269:19: end_identifier
				{
				DebugLocation(1269, 19);
				PushFollow(Follow._end_identifier_in_physical_type_definition12335);
				end_identifier586=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier586.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(183); }



			{
			// AST REWRITE
			// elements: secondary_unit_declaration, identifier, range_constraint, end_identifier, primary_unit_declaration
			// token labels: 
			// rule labels: retval, primary_unit_declaration
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_primary_unit_declaration=new RewriteRuleSubtreeStream(adaptor,"rule primary_unit_declaration",primary_unit_declaration!=null?primary_unit_declaration.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1270:9: -> ^( PHYSICAL_TYPE_DEFINITION range_constraint $primary_unit_declaration ( secondary_unit_declaration )* identifier ( end_identifier )? )
			{
				DebugLocation(1270, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1270:12: ^( PHYSICAL_TYPE_DEFINITION range_constraint $primary_unit_declaration ( secondary_unit_declaration )* identifier ( end_identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1270, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PHYSICAL_TYPE_DEFINITION, "PHYSICAL_TYPE_DEFINITION"), root_1);

				DebugLocation(1270, 40);
				adaptor.AddChild(root_1, stream_range_constraint.NextTree());
				DebugLocation(1270, 58);
				adaptor.AddChild(root_1, stream_primary_unit_declaration.NextTree());
				DebugLocation(1271, 17);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1271:17: ( secondary_unit_declaration )*
				while ( stream_secondary_unit_declaration.HasNext )
				{
					DebugLocation(1271, 17);
					adaptor.AddChild(root_1, stream_secondary_unit_declaration.NextTree());

				}
				stream_secondary_unit_declaration.Reset();
				DebugLocation(1271, 45);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1271, 56);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1271:56: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(1271, 56);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("physical_type_definition", 153);
			LeaveRule("physical_type_definition", 153);
			LeaveRule_physical_type_definition();
			if (state.backtracking > 0) { Memoize(input, 153, physical_type_definition_StartIndex); }

		}
		DebugLocation(1272, 4);
		} finally { DebugExitRule(GrammarFileName, "physical_type_definition"); }
		return retval;

	}
	// $ANTLR end "physical_type_definition"

	partial void EnterRule_port_clause();
	partial void LeaveRule_port_clause();

	// $ANTLR start "port_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1274:1: port_clause : PORT LPAREN port_interface_list RPAREN SEMI -> ^( PORT port_interface_list ) ;
	[GrammarRule("port_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> port_clause()
	{
		EnterRule_port_clause();
		EnterRule("port_clause", 154);
		TraceIn("port_clause", 154);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int port_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PORT587 = default(IToken);
		IToken LPAREN588 = default(IToken);
		IToken RPAREN590 = default(IToken);
		IToken SEMI591 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> port_interface_list589 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PORT587_tree = default(CommonTree);
		CommonTree LPAREN588_tree = default(CommonTree);
		CommonTree RPAREN590_tree = default(CommonTree);
		CommonTree SEMI591_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PORT=new RewriteRuleITokenStream(adaptor,"token PORT");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_port_interface_list=new RewriteRuleSubtreeStream(adaptor,"rule port_interface_list");
		try { DebugEnterRule(GrammarFileName, "port_clause");
		DebugLocation(1274, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 154)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1275:5: ( PORT LPAREN port_interface_list RPAREN SEMI -> ^( PORT port_interface_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1275:9: PORT LPAREN port_interface_list RPAREN SEMI
			{
			DebugLocation(1275, 9);
			PORT587=(IToken)Match(input,PORT,Follow._PORT_in_port_clause12401); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PORT.Add(PORT587);

			DebugLocation(1275, 14);
			LPAREN588=(IToken)Match(input,LPAREN,Follow._LPAREN_in_port_clause12403); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN588);

			DebugLocation(1275, 21);
			PushFollow(Follow._port_interface_list_in_port_clause12405);
			port_interface_list589=port_interface_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_port_interface_list.Add(port_interface_list589.Tree);
			DebugLocation(1275, 41);
			RPAREN590=(IToken)Match(input,RPAREN,Follow._RPAREN_in_port_clause12407); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN590);

			DebugLocation(1275, 48);
			SEMI591=(IToken)Match(input,SEMI,Follow._SEMI_in_port_clause12409); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI591);



			{
			// AST REWRITE
			// elements: port_interface_list, PORT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1276:9: -> ^( PORT port_interface_list )
			{
				DebugLocation(1276, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1276:12: ^( PORT port_interface_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1276, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_PORT.NextNode(), root_1);

				DebugLocation(1276, 20);
				adaptor.AddChild(root_1, stream_port_interface_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("port_clause", 154);
			LeaveRule("port_clause", 154);
			LeaveRule_port_clause();
			if (state.backtracking > 0) { Memoize(input, 154, port_clause_StartIndex); }

		}
		DebugLocation(1277, 4);
		} finally { DebugExitRule(GrammarFileName, "port_clause"); }
		return retval;

	}
	// $ANTLR end "port_clause"

	partial void EnterRule_port_interface_list();
	partial void LeaveRule_port_interface_list();

	// $ANTLR start "port_interface_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1279:1: port_interface_list : interface_signal_declaration_for_port ( SEMI interface_signal_declaration_for_port )* -> ( interface_signal_declaration_for_port )+ ;
	[GrammarRule("port_interface_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> port_interface_list()
	{
		EnterRule_port_interface_list();
		EnterRule("port_interface_list", 155);
		TraceIn("port_interface_list", 155);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int port_interface_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI593 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration_for_port592 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interface_signal_declaration_for_port594 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI593_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_interface_signal_declaration_for_port=new RewriteRuleSubtreeStream(adaptor,"rule interface_signal_declaration_for_port");
		try { DebugEnterRule(GrammarFileName, "port_interface_list");
		DebugLocation(1279, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 155)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1280:5: ( interface_signal_declaration_for_port ( SEMI interface_signal_declaration_for_port )* -> ( interface_signal_declaration_for_port )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1280:9: interface_signal_declaration_for_port ( SEMI interface_signal_declaration_for_port )*
			{
			DebugLocation(1280, 9);
			PushFollow(Follow._interface_signal_declaration_for_port_in_port_interface_list12446);
			interface_signal_declaration_for_port592=interface_signal_declaration_for_port();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_interface_signal_declaration_for_port.Add(interface_signal_declaration_for_port592.Tree);
			DebugLocation(1280, 47);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1280:47: ( SEMI interface_signal_declaration_for_port )*
			try { DebugEnterSubRule(184);
			while (true)
			{
				int alt184=2;
				try { DebugEnterDecision(184, false);
				int LA184_0 = input.LA(1);

				if ((LA184_0==SEMI))
				{
					alt184 = 1;
				}


				} finally { DebugExitDecision(184); }
				switch ( alt184 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1280:49: SEMI interface_signal_declaration_for_port
					{
					DebugLocation(1280, 49);
					SEMI593=(IToken)Match(input,SEMI,Follow._SEMI_in_port_interface_list12450); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI593);

					DebugLocation(1280, 54);
					PushFollow(Follow._interface_signal_declaration_for_port_in_port_interface_list12452);
					interface_signal_declaration_for_port594=interface_signal_declaration_for_port();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_interface_signal_declaration_for_port.Add(interface_signal_declaration_for_port594.Tree);

					}
					break;

				default:
					goto loop184;
				}
			}

			loop184:
				;

			} finally { DebugExitSubRule(184); }



			{
			// AST REWRITE
			// elements: interface_signal_declaration_for_port
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1281:9: -> ( interface_signal_declaration_for_port )+
			{
				DebugLocation(1281, 12);
				if (!(stream_interface_signal_declaration_for_port.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_interface_signal_declaration_for_port.HasNext )
				{
					DebugLocation(1281, 12);
					adaptor.AddChild(root_0, stream_interface_signal_declaration_for_port.NextTree());

				}
				stream_interface_signal_declaration_for_port.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("port_interface_list", 155);
			LeaveRule("port_interface_list", 155);
			LeaveRule_port_interface_list();
			if (state.backtracking > 0) { Memoize(input, 155, port_interface_list_StartIndex); }

		}
		DebugLocation(1282, 4);
		} finally { DebugExitRule(GrammarFileName, "port_interface_list"); }
		return retval;

	}
	// $ANTLR end "port_interface_list"

	partial void EnterRule_port_map_aspect();
	partial void LeaveRule_port_map_aspect();

	// $ANTLR start "port_map_aspect"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1284:1: port_map_aspect : PORT MAP LPAREN port_association_list= association_list RPAREN -> ^( PORT_MAP $port_association_list) ;
	[GrammarRule("port_map_aspect")]
	private AstParserRuleReturnScope<CommonTree, IToken> port_map_aspect()
	{
		EnterRule_port_map_aspect();
		EnterRule("port_map_aspect", 156);
		TraceIn("port_map_aspect", 156);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int port_map_aspect_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PORT595 = default(IToken);
		IToken MAP596 = default(IToken);
		IToken LPAREN597 = default(IToken);
		IToken RPAREN598 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> port_association_list = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PORT595_tree = default(CommonTree);
		CommonTree MAP596_tree = default(CommonTree);
		CommonTree LPAREN597_tree = default(CommonTree);
		CommonTree RPAREN598_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PORT=new RewriteRuleITokenStream(adaptor,"token PORT");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_MAP=new RewriteRuleITokenStream(adaptor,"token MAP");
		RewriteRuleSubtreeStream stream_association_list=new RewriteRuleSubtreeStream(adaptor,"rule association_list");
		try { DebugEnterRule(GrammarFileName, "port_map_aspect");
		DebugLocation(1284, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 156)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1285:5: ( PORT MAP LPAREN port_association_list= association_list RPAREN -> ^( PORT_MAP $port_association_list) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1285:9: PORT MAP LPAREN port_association_list= association_list RPAREN
			{
			DebugLocation(1285, 9);
			PORT595=(IToken)Match(input,PORT,Follow._PORT_in_port_map_aspect12487); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PORT.Add(PORT595);

			DebugLocation(1285, 14);
			MAP596=(IToken)Match(input,MAP,Follow._MAP_in_port_map_aspect12489); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_MAP.Add(MAP596);

			DebugLocation(1285, 18);
			LPAREN597=(IToken)Match(input,LPAREN,Follow._LPAREN_in_port_map_aspect12491); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN597);

			DebugLocation(1285, 46);
			PushFollow(Follow._association_list_in_port_map_aspect12495);
			port_association_list=association_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_association_list.Add(port_association_list.Tree);
			DebugLocation(1285, 64);
			RPAREN598=(IToken)Match(input,RPAREN,Follow._RPAREN_in_port_map_aspect12497); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN598);



			{
			// AST REWRITE
			// elements: port_association_list
			// token labels: 
			// rule labels: retval, port_association_list
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_port_association_list=new RewriteRuleSubtreeStream(adaptor,"rule port_association_list",port_association_list!=null?port_association_list.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1286:9: -> ^( PORT_MAP $port_association_list)
			{
				DebugLocation(1286, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1286:12: ^( PORT_MAP $port_association_list)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1286, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PORT_MAP, "PORT_MAP"), root_1);

				DebugLocation(1286, 25);
				adaptor.AddChild(root_1, stream_port_association_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("port_map_aspect", 156);
			LeaveRule("port_map_aspect", 156);
			LeaveRule_port_map_aspect();
			if (state.backtracking > 0) { Memoize(input, 156, port_map_aspect_StartIndex); }

		}
		DebugLocation(1287, 4);
		} finally { DebugExitRule(GrammarFileName, "port_map_aspect"); }
		return retval;

	}
	// $ANTLR end "port_map_aspect"

	partial void EnterRule_primary();
	partial void LeaveRule_primary();

	// $ANTLR start "primary"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1317:1: primary : ( abstract_literal ( identifier -> ^( PHYSICAL_LITERAL abstract_literal identifier ) | -> abstract_literal ) | FLOAT_POINT_LITERAL | CHARACTER_LITERAL | BIT_STRING_LITERAL_BINARY | BIT_STRING_LITERAL_OCTAL | BIT_STRING_LITERAL_HEX | NULLTOK | aggregate | allocator |type_mark_name_or_function= name_with_association ( qualified_expression -> ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression ) | -> $type_mark_name_or_function) );
	[GrammarRule("primary")]
	private AstParserRuleReturnScope<CommonTree, IToken> primary()
	{
		EnterRule_primary();
		EnterRule("primary", 157);
		TraceIn("primary", 157);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primary_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FLOAT_POINT_LITERAL601 = default(IToken);
		IToken CHARACTER_LITERAL602 = default(IToken);
		IToken BIT_STRING_LITERAL_BINARY603 = default(IToken);
		IToken BIT_STRING_LITERAL_OCTAL604 = default(IToken);
		IToken BIT_STRING_LITERAL_HEX605 = default(IToken);
		IToken NULLTOK606 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark_name_or_function = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> abstract_literal599 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier600 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> aggregate607 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> allocator608 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qualified_expression609 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FLOAT_POINT_LITERAL601_tree = default(CommonTree);
		CommonTree CHARACTER_LITERAL602_tree = default(CommonTree);
		CommonTree BIT_STRING_LITERAL_BINARY603_tree = default(CommonTree);
		CommonTree BIT_STRING_LITERAL_OCTAL604_tree = default(CommonTree);
		CommonTree BIT_STRING_LITERAL_HEX605_tree = default(CommonTree);
		CommonTree NULLTOK606_tree = default(CommonTree);
		RewriteRuleSubtreeStream stream_qualified_expression=new RewriteRuleSubtreeStream(adaptor,"rule qualified_expression");
		RewriteRuleSubtreeStream stream_abstract_literal=new RewriteRuleSubtreeStream(adaptor,"rule abstract_literal");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_name_with_association=new RewriteRuleSubtreeStream(adaptor,"rule name_with_association");
		try { DebugEnterRule(GrammarFileName, "primary");
		DebugLocation(1317, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 157)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1318:5: ( abstract_literal ( identifier -> ^( PHYSICAL_LITERAL abstract_literal identifier ) | -> abstract_literal ) | FLOAT_POINT_LITERAL | CHARACTER_LITERAL | BIT_STRING_LITERAL_BINARY | BIT_STRING_LITERAL_OCTAL | BIT_STRING_LITERAL_HEX | NULLTOK | aggregate | allocator |type_mark_name_or_function= name_with_association ( qualified_expression -> ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression ) | -> $type_mark_name_or_function) )
			int alt187=10;
			try { DebugEnterDecision(187, false);
			switch (input.LA(1))
			{
			case BINANRY_BASED_INTEGER:
			case DEC_BASED_INTEGER:
			case HEXA_BASED_INTEGER:
			case OCTAL_BASED_INTEGER:
				{
				alt187 = 1;
				}
				break;
			case FLOAT_POINT_LITERAL:
				{
				alt187 = 2;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt187 = 3;
				}
				break;
			case BIT_STRING_LITERAL_BINARY:
				{
				alt187 = 4;
				}
				break;
			case BIT_STRING_LITERAL_OCTAL:
				{
				alt187 = 5;
				}
				break;
			case BIT_STRING_LITERAL_HEX:
				{
				alt187 = 6;
				}
				break;
			case NULLTOK:
				{
				alt187 = 7;
				}
				break;
			case LPAREN:
				{
				alt187 = 8;
				}
				break;
			case NEW:
				{
				alt187 = 9;
				}
				break;
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt187 = 10;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 187, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(187); }
			switch (alt187)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1318:9: abstract_literal ( identifier -> ^( PHYSICAL_LITERAL abstract_literal identifier ) | -> abstract_literal )
				{
				DebugLocation(1318, 9);
				PushFollow(Follow._abstract_literal_in_primary12563);
				abstract_literal599=abstract_literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_abstract_literal.Add(abstract_literal599.Tree);
				DebugLocation(1319, 5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1319:5: ( identifier -> ^( PHYSICAL_LITERAL abstract_literal identifier ) | -> abstract_literal )
				int alt185=2;
				try { DebugEnterSubRule(185);
				try { DebugEnterDecision(185, false);
				int LA185_0 = input.LA(1);

				if ((LA185_0==BASIC_IDENTIFIER||LA185_0==EXTENDED_IDENTIFIER))
				{
					alt185 = 1;
				}
				else if ((LA185_0==AFTER||(LA185_0>=AMPERSAND && LA185_0<=AND)||LA185_0==ARROW||LA185_0==BAR||LA185_0==BUS||LA185_0==COMMA||LA185_0==DIV||(LA185_0>=DOUBLESTAR && LA185_0<=ELSE)||(LA185_0>=EQ && LA185_0<=EXCLAMATION)||LA185_0==FOR||(LA185_0>=GE && LA185_0<=GENERATE)||LA185_0==GT||LA185_0==INERTIAL||LA185_0==IS||LA185_0==LE||LA185_0==LOOP||LA185_0==LT||(LA185_0>=MINUS && LA185_0<=MUL)||(LA185_0>=NAND && LA185_0<=NEQ)||LA185_0==NOR||(LA185_0>=OPEN && LA185_0<=OR)||LA185_0==PLUS||LA185_0==REGISTER||(LA185_0>=REM && LA185_0<=REPORT)||(LA185_0>=ROL && LA185_0<=SELECT)||(LA185_0>=SEMI && LA185_0<=SEVERITY)||(LA185_0>=SLA && LA185_0<=SLL)||(LA185_0>=SRA && LA185_0<=SRL)||(LA185_0>=THEN && LA185_0<=TO)||LA185_0==UNITS||LA185_0==VARASGN||LA185_0==WHEN||(LA185_0>=XNOR && LA185_0<=XOR)))
				{
					alt185 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 185, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(185); }
				switch (alt185)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1319:11: identifier
					{
					DebugLocation(1319, 11);
					PushFollow(Follow._identifier_in_primary12575);
					identifier600=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier600.Tree);


					{
					// AST REWRITE
					// elements: identifier, abstract_literal
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1320:11: -> ^( PHYSICAL_LITERAL abstract_literal identifier )
					{
						DebugLocation(1320, 14);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1320:14: ^( PHYSICAL_LITERAL abstract_literal identifier )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1320, 16);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PHYSICAL_LITERAL, "PHYSICAL_LITERAL"), root_1);

						DebugLocation(1320, 33);
						adaptor.AddChild(root_1, stream_abstract_literal.NextTree());
						DebugLocation(1320, 50);
						adaptor.AddChild(root_1, stream_identifier.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1322:5: 
					{

					{
					// AST REWRITE
					// elements: abstract_literal
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1322:5: -> abstract_literal
					{
						DebugLocation(1322, 8);
						adaptor.AddChild(root_0, stream_abstract_literal.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(185); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1324:7: FLOAT_POINT_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1324, 7);
				FLOAT_POINT_LITERAL601=(IToken)Match(input,FLOAT_POINT_LITERAL,Follow._FLOAT_POINT_LITERAL_in_primary12623); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT_POINT_LITERAL601_tree = (CommonTree)adaptor.Create(FLOAT_POINT_LITERAL601);
				adaptor.AddChild(root_0, FLOAT_POINT_LITERAL601_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1325:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1325, 9);
				CHARACTER_LITERAL602=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_primary12633); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL602_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL602);
				adaptor.AddChild(root_0, CHARACTER_LITERAL602_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1326:9: BIT_STRING_LITERAL_BINARY
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1326, 9);
				BIT_STRING_LITERAL_BINARY603=(IToken)Match(input,BIT_STRING_LITERAL_BINARY,Follow._BIT_STRING_LITERAL_BINARY_in_primary12647); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BIT_STRING_LITERAL_BINARY603_tree = (CommonTree)adaptor.Create(BIT_STRING_LITERAL_BINARY603);
				adaptor.AddChild(root_0, BIT_STRING_LITERAL_BINARY603_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1327:9: BIT_STRING_LITERAL_OCTAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1327, 9);
				BIT_STRING_LITERAL_OCTAL604=(IToken)Match(input,BIT_STRING_LITERAL_OCTAL,Follow._BIT_STRING_LITERAL_OCTAL_in_primary12657); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BIT_STRING_LITERAL_OCTAL604_tree = (CommonTree)adaptor.Create(BIT_STRING_LITERAL_OCTAL604);
				adaptor.AddChild(root_0, BIT_STRING_LITERAL_OCTAL604_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1328:9: BIT_STRING_LITERAL_HEX
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1328, 9);
				BIT_STRING_LITERAL_HEX605=(IToken)Match(input,BIT_STRING_LITERAL_HEX,Follow._BIT_STRING_LITERAL_HEX_in_primary12667); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BIT_STRING_LITERAL_HEX605_tree = (CommonTree)adaptor.Create(BIT_STRING_LITERAL_HEX605);
				adaptor.AddChild(root_0, BIT_STRING_LITERAL_HEX605_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1329:9: NULLTOK
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1329, 9);
				NULLTOK606=(IToken)Match(input,NULLTOK,Follow._NULLTOK_in_primary12677); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULLTOK606_tree = (CommonTree)adaptor.Create(NULLTOK606);
				adaptor.AddChild(root_0, NULLTOK606_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1330:9: aggregate
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1330, 9);
				PushFollow(Follow._aggregate_in_primary12687);
				aggregate607=aggregate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, aggregate607.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1331:9: allocator
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1331, 9);
				PushFollow(Follow._allocator_in_primary12697);
				allocator608=allocator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, allocator608.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1332:9: type_mark_name_or_function= name_with_association ( qualified_expression -> ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression ) | -> $type_mark_name_or_function)
				{
				DebugLocation(1332, 35);
				PushFollow(Follow._name_with_association_in_primary12709);
				type_mark_name_or_function=name_with_association();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_with_association.Add(type_mark_name_or_function.Tree);
				DebugLocation(1333, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1333:9: ( qualified_expression -> ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression ) | -> $type_mark_name_or_function)
				int alt186=2;
				try { DebugEnterSubRule(186);
				try { DebugEnterDecision(186, false);
				int LA186_0 = input.LA(1);

				if ((LA186_0==APOSTROPHE))
				{
					alt186 = 1;
				}
				else if ((LA186_0==AFTER||(LA186_0>=AMPERSAND && LA186_0<=AND)||LA186_0==ARROW||LA186_0==BAR||LA186_0==BUS||LA186_0==COMMA||LA186_0==DIV||(LA186_0>=DOUBLESTAR && LA186_0<=ELSE)||(LA186_0>=EQ && LA186_0<=EXCLAMATION)||LA186_0==FOR||(LA186_0>=GE && LA186_0<=GENERATE)||LA186_0==GT||LA186_0==INERTIAL||LA186_0==IS||LA186_0==LE||LA186_0==LOOP||LA186_0==LT||(LA186_0>=MINUS && LA186_0<=MUL)||(LA186_0>=NAND && LA186_0<=NEQ)||LA186_0==NOR||(LA186_0>=OPEN && LA186_0<=OR)||LA186_0==PLUS||LA186_0==REGISTER||(LA186_0>=REM && LA186_0<=REPORT)||(LA186_0>=ROL && LA186_0<=SELECT)||(LA186_0>=SEMI && LA186_0<=SEVERITY)||(LA186_0>=SLA && LA186_0<=SLL)||(LA186_0>=SRA && LA186_0<=SRL)||(LA186_0>=THEN && LA186_0<=TO)||LA186_0==UNITS||LA186_0==VARASGN||LA186_0==WHEN||(LA186_0>=XNOR && LA186_0<=XOR)))
				{
					alt186 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 186, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(186); }
				switch (alt186)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1334:17: qualified_expression
					{
					DebugLocation(1334, 17);
					PushFollow(Follow._qualified_expression_in_primary12737);
					qualified_expression609=qualified_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_qualified_expression.Add(qualified_expression609.Tree);


					{
					// AST REWRITE
					// elements: qualified_expression, type_mark_name_or_function
					// token labels: 
					// rule labels: retval, type_mark_name_or_function
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_type_mark_name_or_function=new RewriteRuleSubtreeStream(adaptor,"rule type_mark_name_or_function",type_mark_name_or_function!=null?type_mark_name_or_function.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1335:17: -> ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression )
					{
						DebugLocation(1335, 20);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1335:20: ^( QUALIFIED_EXPRESSION $type_mark_name_or_function qualified_expression )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1335, 23);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(QUALIFIED_EXPRESSION, "QUALIFIED_EXPRESSION"), root_1);

						DebugLocation(1335, 45);
						adaptor.AddChild(root_1, stream_type_mark_name_or_function.NextTree());
						DebugLocation(1335, 72);
						adaptor.AddChild(root_1, stream_qualified_expression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1337:17: 
					{

					{
					// AST REWRITE
					// elements: type_mark_name_or_function
					// token labels: 
					// rule labels: retval, type_mark_name_or_function
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_type_mark_name_or_function=new RewriteRuleSubtreeStream(adaptor,"rule type_mark_name_or_function",type_mark_name_or_function!=null?type_mark_name_or_function.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1337:17: -> $type_mark_name_or_function
					{
						DebugLocation(1337, 21);
						adaptor.AddChild(root_0, stream_type_mark_name_or_function.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(186); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary", 157);
			LeaveRule("primary", 157);
			LeaveRule_primary();
			if (state.backtracking > 0) { Memoize(input, 157, primary_StartIndex); }

		}
		DebugLocation(1339, 4);
		} finally { DebugExitRule(GrammarFileName, "primary"); }
		return retval;

	}
	// $ANTLR end "primary"

	partial void EnterRule_primary_unit();
	partial void LeaveRule_primary_unit();

	// $ANTLR start "primary_unit"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1341:1: primary_unit : ( entity_declaration | configuration_declaration | package_declaration );
	[GrammarRule("primary_unit")]
	private AstParserRuleReturnScope<CommonTree, IToken> primary_unit()
	{
		EnterRule_primary_unit();
		EnterRule("primary_unit", 158);
		TraceIn("primary_unit", 158);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primary_unit_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> entity_declaration610 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> configuration_declaration611 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> package_declaration612 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "primary_unit");
		DebugLocation(1341, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 158)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1342:5: ( entity_declaration | configuration_declaration | package_declaration )
			int alt188=3;
			try { DebugEnterDecision(188, false);
			switch (input.LA(1))
			{
			case ENTITY:
				{
				alt188 = 1;
				}
				break;
			case CONFIGURATION:
				{
				alt188 = 2;
				}
				break;
			case PACKAGE:
				{
				alt188 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 188, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(188); }
			switch (alt188)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1343:5: entity_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1343, 5);
				PushFollow(Follow._entity_declaration_in_primary_unit12832);
				entity_declaration610=entity_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, entity_declaration610.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1344:9: configuration_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1344, 9);
				PushFollow(Follow._configuration_declaration_in_primary_unit12842);
				configuration_declaration611=configuration_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, configuration_declaration611.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1345:9: package_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1345, 9);
				PushFollow(Follow._package_declaration_in_primary_unit12852);
				package_declaration612=package_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, package_declaration612.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primary_unit", 158);
			LeaveRule("primary_unit", 158);
			LeaveRule_primary_unit();
			if (state.backtracking > 0) { Memoize(input, 158, primary_unit_StartIndex); }

		}
		DebugLocation(1346, 4);
		} finally { DebugExitRule(GrammarFileName, "primary_unit"); }
		return retval;

	}
	// $ANTLR end "primary_unit"

	partial void EnterRule_procedure_call();
	partial void LeaveRule_procedure_call();

	// $ANTLR start "procedure_call"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1348:1: procedure_call : procedure= name_without_parens ( LPAREN parameters= association_list RPAREN )? -> ^( PROCEDURE_CALL $procedure ( $parameters)? ) ;
	[GrammarRule("procedure_call")]
	private AstParserRuleReturnScope<CommonTree, IToken> procedure_call()
	{
		EnterRule_procedure_call();
		EnterRule("procedure_call", 159);
		TraceIn("procedure_call", 159);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int procedure_call_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN613 = default(IToken);
		IToken RPAREN614 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> procedure = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameters = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN613_tree = default(CommonTree);
		CommonTree RPAREN614_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_association_list=new RewriteRuleSubtreeStream(adaptor,"rule association_list");
		try { DebugEnterRule(GrammarFileName, "procedure_call");
		DebugLocation(1348, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 159)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1349:5: (procedure= name_without_parens ( LPAREN parameters= association_list RPAREN )? -> ^( PROCEDURE_CALL $procedure ( $parameters)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1349:9: procedure= name_without_parens ( LPAREN parameters= association_list RPAREN )?
			{
			DebugLocation(1349, 18);
			PushFollow(Follow._name_without_parens_in_procedure_call12873);
			procedure=name_without_parens();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_without_parens.Add(procedure.Tree);
			DebugLocation(1349, 39);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1349:39: ( LPAREN parameters= association_list RPAREN )?
			int alt189=2;
			try { DebugEnterSubRule(189);
			try { DebugEnterDecision(189, false);
			int LA189_0 = input.LA(1);

			if ((LA189_0==LPAREN))
			{
				alt189 = 1;
			}
			} finally { DebugExitDecision(189); }
			switch (alt189)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1349:41: LPAREN parameters= association_list RPAREN
				{
				DebugLocation(1349, 41);
				LPAREN613=(IToken)Match(input,LPAREN,Follow._LPAREN_in_procedure_call12877); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN613);

				DebugLocation(1349, 58);
				PushFollow(Follow._association_list_in_procedure_call12881);
				parameters=association_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_association_list.Add(parameters.Tree);
				DebugLocation(1349, 76);
				RPAREN614=(IToken)Match(input,RPAREN,Follow._RPAREN_in_procedure_call12883); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN614);


				}
				break;

			}
			} finally { DebugExitSubRule(189); }



			{
			// AST REWRITE
			// elements: parameters, procedure
			// token labels: 
			// rule labels: retval, parameters, procedure
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters",parameters!=null?parameters.Tree:null);
			RewriteRuleSubtreeStream stream_procedure=new RewriteRuleSubtreeStream(adaptor,"rule procedure",procedure!=null?procedure.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1350:9: -> ^( PROCEDURE_CALL $procedure ( $parameters)? )
			{
				DebugLocation(1350, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1350:12: ^( PROCEDURE_CALL $procedure ( $parameters)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1350, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROCEDURE_CALL, "PROCEDURE_CALL"), root_1);

				DebugLocation(1350, 31);
				adaptor.AddChild(root_1, stream_procedure.NextTree());
				DebugLocation(1350, 42);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1350:42: ( $parameters)?
				if (stream_parameters.HasNext)
				{
					DebugLocation(1350, 42);
					adaptor.AddChild(root_1, stream_parameters.NextTree());

				}
				stream_parameters.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("procedure_call", 159);
			LeaveRule("procedure_call", 159);
			LeaveRule_procedure_call();
			if (state.backtracking > 0) { Memoize(input, 159, procedure_call_StartIndex); }

		}
		DebugLocation(1352, 4);
		} finally { DebugExitRule(GrammarFileName, "procedure_call"); }
		return retval;

	}
	// $ANTLR end "procedure_call"

	partial void EnterRule_procedure_call_statement();
	partial void LeaveRule_procedure_call_statement();

	// $ANTLR start "procedure_call_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1354:1: procedure_call_statement : procedure_call SEMI -> procedure_call ;
	[GrammarRule("procedure_call_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> procedure_call_statement()
	{
		EnterRule_procedure_call_statement();
		EnterRule("procedure_call_statement", 160);
		TraceIn("procedure_call_statement", 160);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int procedure_call_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI616 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> procedure_call615 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI616_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_procedure_call=new RewriteRuleSubtreeStream(adaptor,"rule procedure_call");
		try { DebugEnterRule(GrammarFileName, "procedure_call_statement");
		DebugLocation(1354, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 160)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1355:5: ( procedure_call SEMI -> procedure_call )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1355:9: procedure_call SEMI
			{
			DebugLocation(1355, 9);
			PushFollow(Follow._procedure_call_in_procedure_call_statement12929);
			procedure_call615=procedure_call();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_procedure_call.Add(procedure_call615.Tree);
			DebugLocation(1355, 24);
			SEMI616=(IToken)Match(input,SEMI,Follow._SEMI_in_procedure_call_statement12931); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI616);



			{
			// AST REWRITE
			// elements: procedure_call
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1356:9: -> procedure_call
			{
				DebugLocation(1356, 12);
				adaptor.AddChild(root_0, stream_procedure_call.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("procedure_call_statement", 160);
			LeaveRule("procedure_call_statement", 160);
			LeaveRule_procedure_call_statement();
			if (state.backtracking > 0) { Memoize(input, 160, procedure_call_statement_StartIndex); }

		}
		DebugLocation(1357, 4);
		} finally { DebugExitRule(GrammarFileName, "procedure_call_statement"); }
		return retval;

	}
	// $ANTLR end "procedure_call_statement"

	partial void EnterRule_process_declarative_item();
	partial void LeaveRule_process_declarative_item();

	// $ANTLR start "process_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1359:1: process_declarative_item : ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("process_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> process_declarative_item()
	{
		EnterRule_process_declarative_item();
		EnterRule("process_declarative_item", 161);
		TraceIn("process_declarative_item", 161);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int process_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration617 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration618 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration619 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration620 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variable_declaration621 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration622 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration623 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration624 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification625 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause626 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration627 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration628 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "process_declarative_item");
		DebugLocation(1359, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 161)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1360:5: ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | use_clause | group_template_declaration | group_declaration )
			int alt190=12;
			try { DebugEnterDecision(190, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt190 = 1;
				}
				break;
			case TYPE:
				{
				alt190 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt190 = 3;
				}
				break;
			case CONSTANT:
				{
				alt190 = 4;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt190 = 5;
				}
				break;
			case FILE:
				{
				alt190 = 6;
				}
				break;
			case ALIAS:
				{
				alt190 = 7;
				}
				break;
			case ATTRIBUTE:
				{
				int LA190_8 = input.LA(2);

				if ((LA190_8==BASIC_IDENTIFIER||LA190_8==EXTENDED_IDENTIFIER))
				{
					int LA190_11 = input.LA(3);

					if ((LA190_11==COLON))
					{
						alt190 = 8;
					}
					else if ((LA190_11==OF))
					{
						alt190 = 9;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 190, 11, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA190_8==RANGETOK))
				{
					alt190 = 9;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 190, 8, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case USE:
				{
				alt190 = 10;
				}
				break;
			case GROUP:
				{
				int LA190_10 = input.LA(2);

				if ((LA190_10==BASIC_IDENTIFIER||LA190_10==EXTENDED_IDENTIFIER))
				{
					int LA190_13 = input.LA(3);

					if ((LA190_13==IS))
					{
						alt190 = 11;
					}
					else if ((LA190_13==COLON))
					{
						alt190 = 12;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 190, 13, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 190, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 190, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(190); }
			switch (alt190)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1360:9: subprogram_body_or_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1360, 9);
				PushFollow(Follow._subprogram_body_or_declaration_in_process_declarative_item12962);
				subprogram_body_or_declaration617=subprogram_body_or_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_body_or_declaration617.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1361:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1361, 9);
				PushFollow(Follow._type_declaration_in_process_declarative_item12972);
				type_declaration618=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration618.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1362:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1362, 9);
				PushFollow(Follow._subtype_declaration_in_process_declarative_item12982);
				subtype_declaration619=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration619.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1363:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1363, 9);
				PushFollow(Follow._constant_declaration_in_process_declarative_item12992);
				constant_declaration620=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration620.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1364:9: variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1364, 9);
				PushFollow(Follow._variable_declaration_in_process_declarative_item13002);
				variable_declaration621=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration621.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1365:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1365, 9);
				PushFollow(Follow._file_declaration_in_process_declarative_item13012);
				file_declaration622=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration622.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1366:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1366, 9);
				PushFollow(Follow._alias_declaration_in_process_declarative_item13022);
				alias_declaration623=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration623.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1367:9: attribute_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1367, 9);
				PushFollow(Follow._attribute_declaration_in_process_declarative_item13032);
				attribute_declaration624=attribute_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_declaration624.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1368:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1368, 9);
				PushFollow(Follow._attribute_specification_in_process_declarative_item13042);
				attribute_specification625=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification625.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1369:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1369, 9);
				PushFollow(Follow._use_clause_in_process_declarative_item13052);
				use_clause626=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause626.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1370:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1370, 9);
				PushFollow(Follow._group_template_declaration_in_process_declarative_item13062);
				group_template_declaration627=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration627.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1371:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1371, 9);
				PushFollow(Follow._group_declaration_in_process_declarative_item13072);
				group_declaration628=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration628.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("process_declarative_item", 161);
			LeaveRule("process_declarative_item", 161);
			LeaveRule_process_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 161, process_declarative_item_StartIndex); }

		}
		DebugLocation(1372, 4);
		} finally { DebugExitRule(GrammarFileName, "process_declarative_item"); }
		return retval;

	}
	// $ANTLR end "process_declarative_item"

	partial void EnterRule_process_declarative_part();
	partial void LeaveRule_process_declarative_part();

	// $ANTLR start "process_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1374:1: process_declarative_part : ( process_declarative_item )+ ;
	[GrammarRule("process_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> process_declarative_part()
	{
		EnterRule_process_declarative_part();
		EnterRule("process_declarative_part", 162);
		TraceIn("process_declarative_part", 162);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int process_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> process_declarative_item629 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "process_declarative_part");
		DebugLocation(1374, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 162)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1375:5: ( ( process_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1375:9: ( process_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1375, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1375:9: ( process_declarative_item )+
			int cnt191=0;
			try { DebugEnterSubRule(191);
			while (true)
			{
				int alt191=2;
				try { DebugEnterDecision(191, false);
				int LA191_0 = input.LA(1);

				if ((LA191_0==ALIAS||LA191_0==ATTRIBUTE||LA191_0==CONSTANT||LA191_0==FILE||LA191_0==FUNCTION||LA191_0==GROUP||LA191_0==IMPURE||LA191_0==PROCEDURE||LA191_0==PURE||LA191_0==SHARED||LA191_0==SUBTYPE||LA191_0==TYPE||LA191_0==USE||LA191_0==VARIABLE))
				{
					alt191 = 1;
				}


				} finally { DebugExitDecision(191); }
				switch (alt191)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1375:9: process_declarative_item
					{
					DebugLocation(1375, 9);
					PushFollow(Follow._process_declarative_item_in_process_declarative_part13091);
					process_declarative_item629=process_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, process_declarative_item629.Tree);

					}
					break;

				default:
					if (cnt191 >= 1)
						goto loop191;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee191 = new EarlyExitException( 191, input );
					DebugRecognitionException(eee191);
					throw eee191;
				}
				cnt191++;
			}
			loop191:
				;

			} finally { DebugExitSubRule(191); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("process_declarative_part", 162);
			LeaveRule("process_declarative_part", 162);
			LeaveRule_process_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 162, process_declarative_part_StartIndex); }

		}
		DebugLocation(1376, 4);
		} finally { DebugExitRule(GrammarFileName, "process_declarative_part"); }
		return retval;

	}
	// $ANTLR end "process_declarative_part"

	partial void EnterRule_process_statement();
	partial void LeaveRule_process_statement();

	// $ANTLR start "process_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1379:1: process_statement : PROCESS ( LPAREN sensitivity_list RPAREN )? ( IS )? ( process_declarative_part )? BEGIN ( process_statement_part )? END ( POSTPONED )? PROCESS ( end_identifier )? SEMI -> ^( PROCESS ( sensitivity_list )? ( IS )? ( process_declarative_part )? ( process_statement_part )? ( end_identifier )? ( POSTPONED )? ) ;
	[GrammarRule("process_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> process_statement()
	{
		EnterRule_process_statement();
		EnterRule("process_statement", 163);
		TraceIn("process_statement", 163);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int process_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PROCESS630 = default(IToken);
		IToken LPAREN631 = default(IToken);
		IToken RPAREN633 = default(IToken);
		IToken IS634 = default(IToken);
		IToken BEGIN636 = default(IToken);
		IToken END638 = default(IToken);
		IToken POSTPONED639 = default(IToken);
		IToken PROCESS640 = default(IToken);
		IToken SEMI642 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sensitivity_list632 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> process_declarative_part635 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> process_statement_part637 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> end_identifier641 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PROCESS630_tree = default(CommonTree);
		CommonTree LPAREN631_tree = default(CommonTree);
		CommonTree RPAREN633_tree = default(CommonTree);
		CommonTree IS634_tree = default(CommonTree);
		CommonTree BEGIN636_tree = default(CommonTree);
		CommonTree END638_tree = default(CommonTree);
		CommonTree POSTPONED639_tree = default(CommonTree);
		CommonTree PROCESS640_tree = default(CommonTree);
		CommonTree SEMI642_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_POSTPONED=new RewriteRuleITokenStream(adaptor,"token POSTPONED");
		RewriteRuleITokenStream stream_PROCESS=new RewriteRuleITokenStream(adaptor,"token PROCESS");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_process_statement_part=new RewriteRuleSubtreeStream(adaptor,"rule process_statement_part");
		RewriteRuleSubtreeStream stream_end_identifier=new RewriteRuleSubtreeStream(adaptor,"rule end_identifier");
		RewriteRuleSubtreeStream stream_process_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule process_declarative_part");
		RewriteRuleSubtreeStream stream_sensitivity_list=new RewriteRuleSubtreeStream(adaptor,"rule sensitivity_list");
		try { DebugEnterRule(GrammarFileName, "process_statement");
		DebugLocation(1379, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 163)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:5: ( PROCESS ( LPAREN sensitivity_list RPAREN )? ( IS )? ( process_declarative_part )? BEGIN ( process_statement_part )? END ( POSTPONED )? PROCESS ( end_identifier )? SEMI -> ^( PROCESS ( sensitivity_list )? ( IS )? ( process_declarative_part )? ( process_statement_part )? ( end_identifier )? ( POSTPONED )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:9: PROCESS ( LPAREN sensitivity_list RPAREN )? ( IS )? ( process_declarative_part )? BEGIN ( process_statement_part )? END ( POSTPONED )? PROCESS ( end_identifier )? SEMI
			{
			DebugLocation(1380, 9);
			PROCESS630=(IToken)Match(input,PROCESS,Follow._PROCESS_in_process_statement13112); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROCESS.Add(PROCESS630);

			DebugLocation(1380, 17);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:17: ( LPAREN sensitivity_list RPAREN )?
			int alt192=2;
			try { DebugEnterSubRule(192);
			try { DebugEnterDecision(192, false);
			int LA192_0 = input.LA(1);

			if ((LA192_0==LPAREN))
			{
				alt192 = 1;
			}
			} finally { DebugExitDecision(192); }
			switch (alt192)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:19: LPAREN sensitivity_list RPAREN
				{
				DebugLocation(1380, 19);
				LPAREN631=(IToken)Match(input,LPAREN,Follow._LPAREN_in_process_statement13116); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN631);

				DebugLocation(1380, 26);
				PushFollow(Follow._sensitivity_list_in_process_statement13118);
				sensitivity_list632=sensitivity_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_sensitivity_list.Add(sensitivity_list632.Tree);
				DebugLocation(1380, 43);
				RPAREN633=(IToken)Match(input,RPAREN,Follow._RPAREN_in_process_statement13120); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN633);


				}
				break;

			}
			} finally { DebugExitSubRule(192); }

			DebugLocation(1380, 53);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:53: ( IS )?
			int alt193=2;
			try { DebugEnterSubRule(193);
			try { DebugEnterDecision(193, false);
			int LA193_0 = input.LA(1);

			if ((LA193_0==IS))
			{
				alt193 = 1;
			}
			} finally { DebugExitDecision(193); }
			switch (alt193)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1380:53: IS
				{
				DebugLocation(1380, 53);
				IS634=(IToken)Match(input,IS,Follow._IS_in_process_statement13125); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IS.Add(IS634);


				}
				break;

			}
			} finally { DebugExitSubRule(193); }

			DebugLocation(1381, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1381:9: ( process_declarative_part )?
			int alt194=2;
			try { DebugEnterSubRule(194);
			try { DebugEnterDecision(194, false);
			int LA194_0 = input.LA(1);

			if ((LA194_0==ALIAS||LA194_0==ATTRIBUTE||LA194_0==CONSTANT||LA194_0==FILE||LA194_0==FUNCTION||LA194_0==GROUP||LA194_0==IMPURE||LA194_0==PROCEDURE||LA194_0==PURE||LA194_0==SHARED||LA194_0==SUBTYPE||LA194_0==TYPE||LA194_0==USE||LA194_0==VARIABLE))
			{
				alt194 = 1;
			}
			} finally { DebugExitDecision(194); }
			switch (alt194)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1381:9: process_declarative_part
				{
				DebugLocation(1381, 9);
				PushFollow(Follow._process_declarative_part_in_process_statement13136);
				process_declarative_part635=process_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_process_declarative_part.Add(process_declarative_part635.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(194); }

			DebugLocation(1382, 9);
			BEGIN636=(IToken)Match(input,BEGIN,Follow._BEGIN_in_process_statement13147); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BEGIN.Add(BEGIN636);

			DebugLocation(1383, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1383:9: ( process_statement_part )?
			int alt195=2;
			try { DebugEnterSubRule(195);
			try { DebugEnterDecision(195, false);
			int LA195_0 = input.LA(1);

			if ((LA195_0==ASSERT||LA195_0==BASIC_IDENTIFIER||LA195_0==CASE||LA195_0==EXIT||LA195_0==EXTENDED_IDENTIFIER||LA195_0==FOR||LA195_0==IF||LA195_0==LOOP||LA195_0==LPAREN||LA195_0==NEXT||LA195_0==NULLTOK||LA195_0==REPORT||LA195_0==RETURN||LA195_0==STRING_LITERAL||LA195_0==WAIT||LA195_0==WHILE))
			{
				alt195 = 1;
			}
			} finally { DebugExitDecision(195); }
			switch (alt195)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1383:9: process_statement_part
				{
				DebugLocation(1383, 9);
				PushFollow(Follow._process_statement_part_in_process_statement13157);
				process_statement_part637=process_statement_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_process_statement_part.Add(process_statement_part637.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(195); }

			DebugLocation(1384, 9);
			END638=(IToken)Match(input,END,Follow._END_in_process_statement13168); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END638);

			DebugLocation(1384, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1384:13: ( POSTPONED )?
			int alt196=2;
			try { DebugEnterSubRule(196);
			try { DebugEnterDecision(196, false);
			int LA196_0 = input.LA(1);

			if ((LA196_0==POSTPONED))
			{
				alt196 = 1;
			}
			} finally { DebugExitDecision(196); }
			switch (alt196)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1384:13: POSTPONED
				{
				DebugLocation(1384, 13);
				POSTPONED639=(IToken)Match(input,POSTPONED,Follow._POSTPONED_in_process_statement13170); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POSTPONED.Add(POSTPONED639);


				}
				break;

			}
			} finally { DebugExitSubRule(196); }

			DebugLocation(1384, 24);
			PROCESS640=(IToken)Match(input,PROCESS,Follow._PROCESS_in_process_statement13173); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PROCESS.Add(PROCESS640);

			DebugLocation(1384, 32);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1384:32: ( end_identifier )?
			int alt197=2;
			try { DebugEnterSubRule(197);
			try { DebugEnterDecision(197, false);
			int LA197_0 = input.LA(1);

			if ((LA197_0==BASIC_IDENTIFIER||LA197_0==EXTENDED_IDENTIFIER))
			{
				alt197 = 1;
			}
			} finally { DebugExitDecision(197); }
			switch (alt197)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1384:32: end_identifier
				{
				DebugLocation(1384, 32);
				PushFollow(Follow._end_identifier_in_process_statement13175);
				end_identifier641=end_identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end_identifier.Add(end_identifier641.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(197); }

			DebugLocation(1384, 48);
			SEMI642=(IToken)Match(input,SEMI,Follow._SEMI_in_process_statement13178); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI642);



			{
			// AST REWRITE
			// elements: process_statement_part, POSTPONED, PROCESS, IS, end_identifier, sensitivity_list, process_declarative_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1385:9: -> ^( PROCESS ( sensitivity_list )? ( IS )? ( process_declarative_part )? ( process_statement_part )? ( end_identifier )? ( POSTPONED )? )
			{
				DebugLocation(1385, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:12: ^( PROCESS ( sensitivity_list )? ( IS )? ( process_declarative_part )? ( process_statement_part )? ( end_identifier )? ( POSTPONED )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1385, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_PROCESS.NextNode(), root_1);

				DebugLocation(1385, 23);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:23: ( sensitivity_list )?
				if (stream_sensitivity_list.HasNext)
				{
					DebugLocation(1385, 23);
					adaptor.AddChild(root_1, stream_sensitivity_list.NextTree());

				}
				stream_sensitivity_list.Reset();
				DebugLocation(1385, 41);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:41: ( IS )?
				if (stream_IS.HasNext)
				{
					DebugLocation(1385, 41);
					adaptor.AddChild(root_1, stream_IS.NextNode());

				}
				stream_IS.Reset();
				DebugLocation(1385, 45);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:45: ( process_declarative_part )?
				if (stream_process_declarative_part.HasNext)
				{
					DebugLocation(1385, 45);
					adaptor.AddChild(root_1, stream_process_declarative_part.NextTree());

				}
				stream_process_declarative_part.Reset();
				DebugLocation(1385, 71);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:71: ( process_statement_part )?
				if (stream_process_statement_part.HasNext)
				{
					DebugLocation(1385, 71);
					adaptor.AddChild(root_1, stream_process_statement_part.NextTree());

				}
				stream_process_statement_part.Reset();
				DebugLocation(1385, 95);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:95: ( end_identifier )?
				if (stream_end_identifier.HasNext)
				{
					DebugLocation(1385, 95);
					adaptor.AddChild(root_1, stream_end_identifier.NextTree());

				}
				stream_end_identifier.Reset();
				DebugLocation(1385, 111);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1385:111: ( POSTPONED )?
				if (stream_POSTPONED.HasNext)
				{
					DebugLocation(1385, 111);
					adaptor.AddChild(root_1, stream_POSTPONED.NextNode());

				}
				stream_POSTPONED.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("process_statement", 163);
			LeaveRule("process_statement", 163);
			LeaveRule_process_statement();
			if (state.backtracking > 0) { Memoize(input, 163, process_statement_StartIndex); }

		}
		DebugLocation(1386, 4);
		} finally { DebugExitRule(GrammarFileName, "process_statement"); }
		return retval;

	}
	// $ANTLR end "process_statement"

	partial void EnterRule_process_statement_part();
	partial void LeaveRule_process_statement_part();

	// $ANTLR start "process_statement_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1388:1: process_statement_part : ( sequential_statement )+ ;
	[GrammarRule("process_statement_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> process_statement_part()
	{
		EnterRule_process_statement_part();
		EnterRule("process_statement_part", 164);
		TraceIn("process_statement_part", 164);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int process_statement_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> sequential_statement643 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "process_statement_part");
		DebugLocation(1388, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 164)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1389:5: ( ( sequential_statement )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1389:9: ( sequential_statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1389, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1389:9: ( sequential_statement )+
			int cnt198=0;
			try { DebugEnterSubRule(198);
			while (true)
			{
				int alt198=2;
				try { DebugEnterDecision(198, false);
				int LA198_0 = input.LA(1);

				if ((LA198_0==ASSERT||LA198_0==BASIC_IDENTIFIER||LA198_0==CASE||LA198_0==EXIT||LA198_0==EXTENDED_IDENTIFIER||LA198_0==FOR||LA198_0==IF||LA198_0==LOOP||LA198_0==LPAREN||LA198_0==NEXT||LA198_0==NULLTOK||LA198_0==REPORT||LA198_0==RETURN||LA198_0==STRING_LITERAL||LA198_0==WAIT||LA198_0==WHILE))
				{
					alt198 = 1;
				}


				} finally { DebugExitDecision(198); }
				switch (alt198)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1389:9: sequential_statement
					{
					DebugLocation(1389, 9);
					PushFollow(Follow._sequential_statement_in_process_statement_part13230);
					sequential_statement643=sequential_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, sequential_statement643.Tree);

					}
					break;

				default:
					if (cnt198 >= 1)
						goto loop198;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee198 = new EarlyExitException( 198, input );
					DebugRecognitionException(eee198);
					throw eee198;
				}
				cnt198++;
			}
			loop198:
				;

			} finally { DebugExitSubRule(198); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("process_statement_part", 164);
			LeaveRule("process_statement_part", 164);
			LeaveRule_process_statement_part();
			if (state.backtracking > 0) { Memoize(input, 164, process_statement_part_StartIndex); }

		}
		DebugLocation(1390, 4);
		} finally { DebugExitRule(GrammarFileName, "process_statement_part"); }
		return retval;

	}
	// $ANTLR end "process_statement_part"

	partial void EnterRule_qualified_expression();
	partial void LeaveRule_qualified_expression();

	// $ANTLR start "qualified_expression"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1394:1: qualified_expression : APOSTROPHE aggregate -> aggregate ;
	[GrammarRule("qualified_expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> qualified_expression()
	{
		EnterRule_qualified_expression();
		EnterRule("qualified_expression", 165);
		TraceIn("qualified_expression", 165);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int qualified_expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken APOSTROPHE644 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> aggregate645 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree APOSTROPHE644_tree = default(CommonTree);
		RewriteRuleITokenStream stream_APOSTROPHE=new RewriteRuleITokenStream(adaptor,"token APOSTROPHE");
		RewriteRuleSubtreeStream stream_aggregate=new RewriteRuleSubtreeStream(adaptor,"rule aggregate");
		try { DebugEnterRule(GrammarFileName, "qualified_expression");
		DebugLocation(1394, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 165)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1395:5: ( APOSTROPHE aggregate -> aggregate )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1395:9: APOSTROPHE aggregate
			{
			DebugLocation(1395, 9);
			APOSTROPHE644=(IToken)Match(input,APOSTROPHE,Follow._APOSTROPHE_in_qualified_expression13252); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_APOSTROPHE.Add(APOSTROPHE644);

			DebugLocation(1395, 20);
			PushFollow(Follow._aggregate_in_qualified_expression13254);
			aggregate645=aggregate();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_aggregate.Add(aggregate645.Tree);


			{
			// AST REWRITE
			// elements: aggregate
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1396:9: -> aggregate
			{
				DebugLocation(1396, 12);
				adaptor.AddChild(root_0, stream_aggregate.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qualified_expression", 165);
			LeaveRule("qualified_expression", 165);
			LeaveRule_qualified_expression();
			if (state.backtracking > 0) { Memoize(input, 165, qualified_expression_StartIndex); }

		}
		DebugLocation(1397, 4);
		} finally { DebugExitRule(GrammarFileName, "qualified_expression"); }
		return retval;

	}
	// $ANTLR end "qualified_expression"

	partial void EnterRule_range();
	partial void LeaveRule_range();

	// $ANTLR start "range"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1399:1: range : ( ( simple_expression direction )=> simple_expression direction ^ simple_expression |range_attribute= name );
	[GrammarRule("range")]
	private AstParserRuleReturnScope<CommonTree, IToken> range()
	{
		EnterRule_range();
		EnterRule("range", 166);
		TraceIn("range", 166);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int range_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> range_attribute = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression646 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> direction647 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression648 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "range");
		DebugLocation(1399, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 166)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1400:5: ( ( simple_expression direction )=> simple_expression direction ^ simple_expression |range_attribute= name )
			int alt199=2;
			try { DebugEnterDecision(199, false);
			int LA199_0 = input.LA(1);

			if ((LA199_0==MINUS||LA199_0==PLUS) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==BINANRY_BASED_INTEGER||LA199_0==DEC_BASED_INTEGER||LA199_0==HEXA_BASED_INTEGER||LA199_0==OCTAL_BASED_INTEGER) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==FLOAT_POINT_LITERAL) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==CHARACTER_LITERAL) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==BIT_STRING_LITERAL_BINARY) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==BIT_STRING_LITERAL_OCTAL) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==BIT_STRING_LITERAL_HEX) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==NULLTOK) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==LPAREN) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==NEW) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==BASIC_IDENTIFIER||LA199_0==EXTENDED_IDENTIFIER))
			{
				int LA199_11 = input.LA(2);

				if ((EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
				{
					alt199 = 1;
				}
				else if ((true))
				{
					alt199 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 199, 11, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA199_0==STRING_LITERAL))
			{
				int LA199_12 = input.LA(2);

				if ((EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
				{
					alt199 = 1;
				}
				else if ((true))
				{
					alt199 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 199, 12, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA199_0==ABS) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else if ((LA199_0==NOT) && (EvaluatePredicate(synpred13_VhdlAntlr_fragment)))
			{
				alt199 = 1;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 199, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(199); }
			switch (alt199)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1400:9: ( simple_expression direction )=> simple_expression direction ^ simple_expression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1400, 41);
				PushFollow(Follow._simple_expression_in_range13292);
				simple_expression646=simple_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_expression646.Tree);
				DebugLocation(1400, 68);
				PushFollow(Follow._direction_in_range13294);
				direction647=direction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(direction647.Tree, root_0);
				DebugLocation(1400, 70);
				PushFollow(Follow._simple_expression_in_range13297);
				simple_expression648=simple_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_expression648.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1401:9: range_attribute= name
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1401, 24);
				PushFollow(Follow._name_in_range13309);
				range_attribute=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, range_attribute.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("range", 166);
			LeaveRule("range", 166);
			LeaveRule_range();
			if (state.backtracking > 0) { Memoize(input, 166, range_StartIndex); }

		}
		DebugLocation(1402, 4);
		} finally { DebugExitRule(GrammarFileName, "range"); }
		return retval;

	}
	// $ANTLR end "range"

	partial void EnterRule_range_constraint();
	partial void LeaveRule_range_constraint();

	// $ANTLR start "range_constraint"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1404:1: range_constraint : RANGETOK range -> ^( RANGETOK range ) ;
	[GrammarRule("range_constraint")]
	private AstParserRuleReturnScope<CommonTree, IToken> range_constraint()
	{
		EnterRule_range_constraint();
		EnterRule("range_constraint", 167);
		TraceIn("range_constraint", 167);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int range_constraint_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken RANGETOK649 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> range650 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RANGETOK649_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RANGETOK=new RewriteRuleITokenStream(adaptor,"token RANGETOK");
		RewriteRuleSubtreeStream stream_range=new RewriteRuleSubtreeStream(adaptor,"rule range");
		try { DebugEnterRule(GrammarFileName, "range_constraint");
		DebugLocation(1404, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 167)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1405:5: ( RANGETOK range -> ^( RANGETOK range ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1405:9: RANGETOK range
			{
			DebugLocation(1405, 9);
			RANGETOK649=(IToken)Match(input,RANGETOK,Follow._RANGETOK_in_range_constraint13328); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RANGETOK.Add(RANGETOK649);

			DebugLocation(1405, 18);
			PushFollow(Follow._range_in_range_constraint13330);
			range650=range();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_range.Add(range650.Tree);


			{
			// AST REWRITE
			// elements: range, RANGETOK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1406:9: -> ^( RANGETOK range )
			{
				DebugLocation(1406, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1406:12: ^( RANGETOK range )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1406, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_RANGETOK.NextNode(), root_1);

				DebugLocation(1406, 24);
				adaptor.AddChild(root_1, stream_range.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("range_constraint", 167);
			LeaveRule("range_constraint", 167);
			LeaveRule_range_constraint();
			if (state.backtracking > 0) { Memoize(input, 167, range_constraint_StartIndex); }

		}
		DebugLocation(1407, 4);
		} finally { DebugExitRule(GrammarFileName, "range_constraint"); }
		return retval;

	}
	// $ANTLR end "range_constraint"

	partial void EnterRule_record_type_definition();
	partial void LeaveRule_record_type_definition();

	// $ANTLR start "record_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1410:1: record_type_definition : RECORD ( element_declaration )+ END RECORD ( identifier )? -> ^( RECORD_TYPE_DEFINITION ( element_declaration )+ ) ;
	[GrammarRule("record_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> record_type_definition()
	{
		EnterRule_record_type_definition();
		EnterRule("record_type_definition", 168);
		TraceIn("record_type_definition", 168);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int record_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken RECORD651 = default(IToken);
		IToken END653 = default(IToken);
		IToken RECORD654 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> element_declaration652 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier655 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RECORD651_tree = default(CommonTree);
		CommonTree END653_tree = default(CommonTree);
		CommonTree RECORD654_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RECORD=new RewriteRuleITokenStream(adaptor,"token RECORD");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_element_declaration=new RewriteRuleSubtreeStream(adaptor,"rule element_declaration");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "record_type_definition");
		DebugLocation(1410, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 168)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1411:5: ( RECORD ( element_declaration )+ END RECORD ( identifier )? -> ^( RECORD_TYPE_DEFINITION ( element_declaration )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1411:9: RECORD ( element_declaration )+ END RECORD ( identifier )?
			{
			DebugLocation(1411, 9);
			RECORD651=(IToken)Match(input,RECORD,Follow._RECORD_in_record_type_definition13368); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RECORD.Add(RECORD651);

			DebugLocation(1412, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1412:9: ( element_declaration )+
			int cnt200=0;
			try { DebugEnterSubRule(200);
			while (true)
			{
				int alt200=2;
				try { DebugEnterDecision(200, false);
				int LA200_0 = input.LA(1);

				if ((LA200_0==BASIC_IDENTIFIER||LA200_0==EXTENDED_IDENTIFIER))
				{
					alt200 = 1;
				}


				} finally { DebugExitDecision(200); }
				switch (alt200)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1412:9: element_declaration
					{
					DebugLocation(1412, 9);
					PushFollow(Follow._element_declaration_in_record_type_definition13378);
					element_declaration652=element_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_element_declaration.Add(element_declaration652.Tree);

					}
					break;

				default:
					if (cnt200 >= 1)
						goto loop200;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee200 = new EarlyExitException( 200, input );
					DebugRecognitionException(eee200);
					throw eee200;
				}
				cnt200++;
			}
			loop200:
				;

			} finally { DebugExitSubRule(200); }

			DebugLocation(1413, 9);
			END653=(IToken)Match(input,END,Follow._END_in_record_type_definition13389); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END653);

			DebugLocation(1413, 13);
			RECORD654=(IToken)Match(input,RECORD,Follow._RECORD_in_record_type_definition13391); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RECORD.Add(RECORD654);

			DebugLocation(1413, 20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1413:20: ( identifier )?
			int alt201=2;
			try { DebugEnterSubRule(201);
			try { DebugEnterDecision(201, false);
			int LA201_0 = input.LA(1);

			if ((LA201_0==BASIC_IDENTIFIER||LA201_0==EXTENDED_IDENTIFIER))
			{
				alt201 = 1;
			}
			} finally { DebugExitDecision(201); }
			switch (alt201)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1413:20: identifier
				{
				DebugLocation(1413, 20);
				PushFollow(Follow._identifier_in_record_type_definition13393);
				identifier655=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier655.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(201); }



			{
			// AST REWRITE
			// elements: element_declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1414:9: -> ^( RECORD_TYPE_DEFINITION ( element_declaration )+ )
			{
				DebugLocation(1414, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1414:12: ^( RECORD_TYPE_DEFINITION ( element_declaration )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1414, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RECORD_TYPE_DEFINITION, "RECORD_TYPE_DEFINITION"), root_1);

				DebugLocation(1414, 38);
				if (!(stream_element_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_element_declaration.HasNext )
				{
					DebugLocation(1414, 38);
					adaptor.AddChild(root_1, stream_element_declaration.NextTree());

				}
				stream_element_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record_type_definition", 168);
			LeaveRule("record_type_definition", 168);
			LeaveRule_record_type_definition();
			if (state.backtracking > 0) { Memoize(input, 168, record_type_definition_StartIndex); }

		}
		DebugLocation(1415, 4);
		} finally { DebugExitRule(GrammarFileName, "record_type_definition"); }
		return retval;

	}
	// $ANTLR end "record_type_definition"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();

	// $ANTLR start "relation"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1417:1: relation : shift_expression ( relational_operator ^ shift_expression )? ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, IToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 169);
		TraceIn("relation", 169);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relation_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shift_expression656 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relational_operator657 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift_expression658 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(1417, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 169)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1418:5: ( shift_expression ( relational_operator ^ shift_expression )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1418:9: shift_expression ( relational_operator ^ shift_expression )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1418, 9);
			PushFollow(Follow._shift_expression_in_relation13432);
			shift_expression656=shift_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shift_expression656.Tree);
			DebugLocation(1418, 26);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1418:26: ( relational_operator ^ shift_expression )?
			int alt202=2;
			try { DebugEnterSubRule(202);
			try { DebugEnterDecision(202, false);
			int LA202_0 = input.LA(1);

			if ((LA202_0==EQ||LA202_0==GE||LA202_0==GT||LA202_0==LE||LA202_0==LT||LA202_0==NEQ))
			{
				alt202 = 1;
			}
			} finally { DebugExitDecision(202); }
			switch (alt202)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1418:28: relational_operator ^ shift_expression
				{
				DebugLocation(1418, 47);
				PushFollow(Follow._relational_operator_in_relation13436);
				relational_operator657=relational_operator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(relational_operator657.Tree, root_0);
				DebugLocation(1418, 49);
				PushFollow(Follow._shift_expression_in_relation13439);
				shift_expression658=shift_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, shift_expression658.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(202); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relation", 169);
			LeaveRule("relation", 169);
			LeaveRule_relation();
			if (state.backtracking > 0) { Memoize(input, 169, relation_StartIndex); }

		}
		DebugLocation(1419, 4);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_relational_operator();
	partial void LeaveRule_relational_operator();

	// $ANTLR start "relational_operator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1421:1: relational_operator : ( EQ | NEQ | LT | LE | GT | GE );
	[GrammarRule("relational_operator")]
	private AstParserRuleReturnScope<CommonTree, IToken> relational_operator()
	{
		EnterRule_relational_operator();
		EnterRule("relational_operator", 170);
		TraceIn("relational_operator", 170);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relational_operator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set659 = default(IToken);

		CommonTree set659_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relational_operator");
		DebugLocation(1421, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 170)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1422:5: ( EQ | NEQ | LT | LE | GT | GE )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1422, 5);

			set659=(IToken)input.LT(1);
			if (input.LA(1)==EQ||input.LA(1)==GE||input.LA(1)==GT||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==NEQ)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set659));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relational_operator", 170);
			LeaveRule("relational_operator", 170);
			LeaveRule_relational_operator();
			if (state.backtracking > 0) { Memoize(input, 170, relational_operator_StartIndex); }

		}
		DebugLocation(1428, 4);
		} finally { DebugExitRule(GrammarFileName, "relational_operator"); }
		return retval;

	}
	// $ANTLR end "relational_operator"

	partial void EnterRule_report_statement();
	partial void LeaveRule_report_statement();

	// $ANTLR start "report_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1430:1: report_statement : REPORT report= expression ( SEVERITY severity= expression )? SEMI -> ^( REPORT $report ( $severity)? ) ;
	[GrammarRule("report_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> report_statement()
	{
		EnterRule_report_statement();
		EnterRule("report_statement", 171);
		TraceIn("report_statement", 171);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int report_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken REPORT660 = default(IToken);
		IToken SEVERITY661 = default(IToken);
		IToken SEMI662 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> report = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> severity = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree REPORT660_tree = default(CommonTree);
		CommonTree SEVERITY661_tree = default(CommonTree);
		CommonTree SEMI662_tree = default(CommonTree);
		RewriteRuleITokenStream stream_REPORT=new RewriteRuleITokenStream(adaptor,"token REPORT");
		RewriteRuleITokenStream stream_SEVERITY=new RewriteRuleITokenStream(adaptor,"token SEVERITY");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "report_statement");
		DebugLocation(1430, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 171)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1431:5: ( REPORT report= expression ( SEVERITY severity= expression )? SEMI -> ^( REPORT $report ( $severity)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1431:9: REPORT report= expression ( SEVERITY severity= expression )? SEMI
			{
			DebugLocation(1431, 9);
			REPORT660=(IToken)Match(input,REPORT,Follow._REPORT_in_report_statement13530); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REPORT.Add(REPORT660);

			DebugLocation(1431, 22);
			PushFollow(Follow._expression_in_report_statement13534);
			report=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(report.Tree);
			DebugLocation(1431, 34);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1431:34: ( SEVERITY severity= expression )?
			int alt203=2;
			try { DebugEnterSubRule(203);
			try { DebugEnterDecision(203, false);
			int LA203_0 = input.LA(1);

			if ((LA203_0==SEVERITY))
			{
				alt203 = 1;
			}
			} finally { DebugExitDecision(203); }
			switch (alt203)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1431:36: SEVERITY severity= expression
				{
				DebugLocation(1431, 36);
				SEVERITY661=(IToken)Match(input,SEVERITY,Follow._SEVERITY_in_report_statement13538); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEVERITY.Add(SEVERITY661);

				DebugLocation(1431, 53);
				PushFollow(Follow._expression_in_report_statement13542);
				severity=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(severity.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(203); }

			DebugLocation(1431, 68);
			SEMI662=(IToken)Match(input,SEMI,Follow._SEMI_in_report_statement13547); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI662);



			{
			// AST REWRITE
			// elements: report, REPORT, severity
			// token labels: 
			// rule labels: retval, report, severity
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_report=new RewriteRuleSubtreeStream(adaptor,"rule report",report!=null?report.Tree:null);
			RewriteRuleSubtreeStream stream_severity=new RewriteRuleSubtreeStream(adaptor,"rule severity",severity!=null?severity.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1432:9: -> ^( REPORT $report ( $severity)? )
			{
				DebugLocation(1432, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1432:12: ^( REPORT $report ( $severity)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1432, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_REPORT.NextNode(), root_1);

				DebugLocation(1432, 23);
				adaptor.AddChild(root_1, stream_report.NextTree());
				DebugLocation(1432, 31);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1432:31: ( $severity)?
				if (stream_severity.HasNext)
				{
					DebugLocation(1432, 31);
					adaptor.AddChild(root_1, stream_severity.NextTree());

				}
				stream_severity.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("report_statement", 171);
			LeaveRule("report_statement", 171);
			LeaveRule_report_statement();
			if (state.backtracking > 0) { Memoize(input, 171, report_statement_StartIndex); }

		}
		DebugLocation(1433, 4);
		} finally { DebugExitRule(GrammarFileName, "report_statement"); }
		return retval;

	}
	// $ANTLR end "report_statement"

	partial void EnterRule_return_statement();
	partial void LeaveRule_return_statement();

	// $ANTLR start "return_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1435:1: return_statement : RETURN ( expression )? SEMI -> ^( RETURN ( expression )? ) ;
	[GrammarRule("return_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> return_statement()
	{
		EnterRule_return_statement();
		EnterRule("return_statement", 172);
		TraceIn("return_statement", 172);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int return_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken RETURN663 = default(IToken);
		IToken SEMI665 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression664 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RETURN663_tree = default(CommonTree);
		CommonTree SEMI665_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "return_statement");
		DebugLocation(1435, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 172)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1436:5: ( RETURN ( expression )? SEMI -> ^( RETURN ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1436:9: RETURN ( expression )? SEMI
			{
			DebugLocation(1436, 9);
			RETURN663=(IToken)Match(input,RETURN,Follow._RETURN_in_return_statement13589); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RETURN.Add(RETURN663);

			DebugLocation(1436, 16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1436:16: ( expression )?
			int alt204=2;
			try { DebugEnterSubRule(204);
			try { DebugEnterDecision(204, false);
			int LA204_0 = input.LA(1);

			if ((LA204_0==ABS||LA204_0==BASIC_IDENTIFIER||LA204_0==BINANRY_BASED_INTEGER||(LA204_0>=BIT_STRING_LITERAL_BINARY && LA204_0<=BIT_STRING_LITERAL_OCTAL)||LA204_0==CHARACTER_LITERAL||LA204_0==DEC_BASED_INTEGER||LA204_0==EXTENDED_IDENTIFIER||LA204_0==FLOAT_POINT_LITERAL||LA204_0==HEXA_BASED_INTEGER||LA204_0==LPAREN||LA204_0==MINUS||LA204_0==NEW||(LA204_0>=NOT && LA204_0<=OCTAL_BASED_INTEGER)||LA204_0==PLUS||LA204_0==STRING_LITERAL))
			{
				alt204 = 1;
			}
			} finally { DebugExitDecision(204); }
			switch (alt204)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1436:16: expression
				{
				DebugLocation(1436, 16);
				PushFollow(Follow._expression_in_return_statement13591);
				expression664=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression664.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(204); }

			DebugLocation(1436, 28);
			SEMI665=(IToken)Match(input,SEMI,Follow._SEMI_in_return_statement13594); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI665);



			{
			// AST REWRITE
			// elements: RETURN, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1437:9: -> ^( RETURN ( expression )? )
			{
				DebugLocation(1437, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1437:12: ^( RETURN ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1437, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_RETURN.NextNode(), root_1);

				DebugLocation(1437, 22);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1437:22: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(1437, 22);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("return_statement", 172);
			LeaveRule("return_statement", 172);
			LeaveRule_return_statement();
			if (state.backtracking > 0) { Memoize(input, 172, return_statement_StartIndex); }

		}
		DebugLocation(1438, 4);
		} finally { DebugExitRule(GrammarFileName, "return_statement"); }
		return retval;

	}
	// $ANTLR end "return_statement"

	partial void EnterRule_scalar_type_definition();
	partial void LeaveRule_scalar_type_definition();

	// $ANTLR start "scalar_type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1440:1: scalar_type_definition : ( enumeration_type_definition | ( range_constraint UNITS )=> physical_type_definition | integer_or_floating_type_definition );
	[GrammarRule("scalar_type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> scalar_type_definition()
	{
		EnterRule_scalar_type_definition();
		EnterRule("scalar_type_definition", 173);
		TraceIn("scalar_type_definition", 173);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int scalar_type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> enumeration_type_definition666 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> physical_type_definition667 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> integer_or_floating_type_definition668 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "scalar_type_definition");
		DebugLocation(1440, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 173)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1441:5: ( enumeration_type_definition | ( range_constraint UNITS )=> physical_type_definition | integer_or_floating_type_definition )
			int alt205=3;
			try { DebugEnterDecision(205, false);
			int LA205_0 = input.LA(1);

			if ((LA205_0==LPAREN))
			{
				alt205 = 1;
			}
			else if ((LA205_0==RANGETOK))
			{
				int LA205_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_VhdlAntlr_fragment)))
				{
					alt205 = 2;
				}
				else if ((true))
				{
					alt205 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 205, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 205, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(205); }
			switch (alt205)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1441:9: enumeration_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1441, 9);
				PushFollow(Follow._enumeration_type_definition_in_scalar_type_definition13632);
				enumeration_type_definition666=enumeration_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, enumeration_type_definition666.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1442:9: ( range_constraint UNITS )=> physical_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1442, 36);
				PushFollow(Follow._physical_type_definition_in_scalar_type_definition13649);
				physical_type_definition667=physical_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, physical_type_definition667.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1443:9: integer_or_floating_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1443, 9);
				PushFollow(Follow._integer_or_floating_type_definition_in_scalar_type_definition13659);
				integer_or_floating_type_definition668=integer_or_floating_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, integer_or_floating_type_definition668.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("scalar_type_definition", 173);
			LeaveRule("scalar_type_definition", 173);
			LeaveRule_scalar_type_definition();
			if (state.backtracking > 0) { Memoize(input, 173, scalar_type_definition_StartIndex); }

		}
		DebugLocation(1444, 4);
		} finally { DebugExitRule(GrammarFileName, "scalar_type_definition"); }
		return retval;

	}
	// $ANTLR end "scalar_type_definition"

	partial void EnterRule_secondary_unit();
	partial void LeaveRule_secondary_unit();

	// $ANTLR start "secondary_unit"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1446:1: secondary_unit : ( architecture_body | package_body );
	[GrammarRule("secondary_unit")]
	private AstParserRuleReturnScope<CommonTree, IToken> secondary_unit()
	{
		EnterRule_secondary_unit();
		EnterRule("secondary_unit", 174);
		TraceIn("secondary_unit", 174);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int secondary_unit_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> architecture_body669 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> package_body670 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "secondary_unit");
		DebugLocation(1446, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 174)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1447:5: ( architecture_body | package_body )
			int alt206=2;
			try { DebugEnterDecision(206, false);
			int LA206_0 = input.LA(1);

			if ((LA206_0==ARCHITECTURE))
			{
				alt206 = 1;
			}
			else if ((LA206_0==PACKAGE))
			{
				alt206 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 206, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(206); }
			switch (alt206)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1447:9: architecture_body
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1447, 9);
				PushFollow(Follow._architecture_body_in_secondary_unit13678);
				architecture_body669=architecture_body();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, architecture_body669.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1448:9: package_body
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1448, 9);
				PushFollow(Follow._package_body_in_secondary_unit13688);
				package_body670=package_body();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, package_body670.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("secondary_unit", 174);
			LeaveRule("secondary_unit", 174);
			LeaveRule_secondary_unit();
			if (state.backtracking > 0) { Memoize(input, 174, secondary_unit_StartIndex); }

		}
		DebugLocation(1449, 4);
		} finally { DebugExitRule(GrammarFileName, "secondary_unit"); }
		return retval;

	}
	// $ANTLR end "secondary_unit"

	partial void EnterRule_secondary_unit_declaration();
	partial void LeaveRule_secondary_unit_declaration();

	// $ANTLR start "secondary_unit_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1451:1: secondary_unit_declaration : identifier EQ ( abstract_literal )? unit= name SEMI -> identifier ( abstract_literal )? $unit;
	[GrammarRule("secondary_unit_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> secondary_unit_declaration()
	{
		EnterRule_secondary_unit_declaration();
		EnterRule("secondary_unit_declaration", 175);
		TraceIn("secondary_unit_declaration", 175);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int secondary_unit_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken EQ672 = default(IToken);
		IToken SEMI674 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unit = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier671 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> abstract_literal673 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EQ672_tree = default(CommonTree);
		CommonTree SEMI674_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_abstract_literal=new RewriteRuleSubtreeStream(adaptor,"rule abstract_literal");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "secondary_unit_declaration");
		DebugLocation(1451, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 175)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1452:5: ( identifier EQ ( abstract_literal )? unit= name SEMI -> identifier ( abstract_literal )? $unit)
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1452:9: identifier EQ ( abstract_literal )? unit= name SEMI
			{
			DebugLocation(1452, 9);
			PushFollow(Follow._identifier_in_secondary_unit_declaration13707);
			identifier671=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier671.Tree);
			DebugLocation(1452, 20);
			EQ672=(IToken)Match(input,EQ,Follow._EQ_in_secondary_unit_declaration13709); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ672);

			DebugLocation(1452, 23);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1452:23: ( abstract_literal )?
			int alt207=2;
			try { DebugEnterSubRule(207);
			try { DebugEnterDecision(207, false);
			int LA207_0 = input.LA(1);

			if ((LA207_0==BINANRY_BASED_INTEGER||LA207_0==DEC_BASED_INTEGER||LA207_0==HEXA_BASED_INTEGER||LA207_0==OCTAL_BASED_INTEGER))
			{
				alt207 = 1;
			}
			} finally { DebugExitDecision(207); }
			switch (alt207)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1452:23: abstract_literal
				{
				DebugLocation(1452, 23);
				PushFollow(Follow._abstract_literal_in_secondary_unit_declaration13711);
				abstract_literal673=abstract_literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_abstract_literal.Add(abstract_literal673.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(207); }

			DebugLocation(1452, 45);
			PushFollow(Follow._name_in_secondary_unit_declaration13716);
			unit=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(unit.Tree);
			DebugLocation(1452, 51);
			SEMI674=(IToken)Match(input,SEMI,Follow._SEMI_in_secondary_unit_declaration13718); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI674);



			{
			// AST REWRITE
			// elements: unit, identifier, abstract_literal
			// token labels: 
			// rule labels: unit, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_unit=new RewriteRuleSubtreeStream(adaptor,"rule unit",unit!=null?unit.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1453:9: -> identifier ( abstract_literal )? $unit
			{
				DebugLocation(1453, 12);
				adaptor.AddChild(root_0, stream_identifier.NextTree());
				DebugLocation(1453, 23);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1453:23: ( abstract_literal )?
				if (stream_abstract_literal.HasNext)
				{
					DebugLocation(1453, 23);
					adaptor.AddChild(root_0, stream_abstract_literal.NextTree());

				}
				stream_abstract_literal.Reset();
				DebugLocation(1453, 42);
				adaptor.AddChild(root_0, stream_unit.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("secondary_unit_declaration", 175);
			LeaveRule("secondary_unit_declaration", 175);
			LeaveRule_secondary_unit_declaration();
			if (state.backtracking > 0) { Memoize(input, 175, secondary_unit_declaration_StartIndex); }

		}
		DebugLocation(1454, 4);
		} finally { DebugExitRule(GrammarFileName, "secondary_unit_declaration"); }
		return retval;

	}
	// $ANTLR end "secondary_unit_declaration"

	partial void EnterRule_selected_signal_assignment();
	partial void LeaveRule_selected_signal_assignment();

	// $ANTLR start "selected_signal_assignment"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1456:1: selected_signal_assignment : WITH expression SELECT target LE sao= signal_assignment_options sw= selected_waveforms SEMI -> ^( SELECTED_SIGNAL_ASSIGNMENT_STATEMENT expression target ( $sao)? $sw) ;
	[GrammarRule("selected_signal_assignment")]
	private AstParserRuleReturnScope<CommonTree, IToken> selected_signal_assignment()
	{
		EnterRule_selected_signal_assignment();
		EnterRule("selected_signal_assignment", 176);
		TraceIn("selected_signal_assignment", 176);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int selected_signal_assignment_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WITH675 = default(IToken);
		IToken SELECT677 = default(IToken);
		IToken LE679 = default(IToken);
		IToken SEMI680 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sao = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sw = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression676 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> target678 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WITH675_tree = default(CommonTree);
		CommonTree SELECT677_tree = default(CommonTree);
		CommonTree LE679_tree = default(CommonTree);
		CommonTree SEMI680_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SELECT=new RewriteRuleITokenStream(adaptor,"token SELECT");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LE=new RewriteRuleITokenStream(adaptor,"token LE");
		RewriteRuleITokenStream stream_WITH=new RewriteRuleITokenStream(adaptor,"token WITH");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_signal_assignment_options=new RewriteRuleSubtreeStream(adaptor,"rule signal_assignment_options");
		RewriteRuleSubtreeStream stream_selected_waveforms=new RewriteRuleSubtreeStream(adaptor,"rule selected_waveforms");
		RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target");
		try { DebugEnterRule(GrammarFileName, "selected_signal_assignment");
		DebugLocation(1456, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 176)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1457:5: ( WITH expression SELECT target LE sao= signal_assignment_options sw= selected_waveforms SEMI -> ^( SELECTED_SIGNAL_ASSIGNMENT_STATEMENT expression target ( $sao)? $sw) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1457:9: WITH expression SELECT target LE sao= signal_assignment_options sw= selected_waveforms SEMI
			{
			DebugLocation(1457, 9);
			WITH675=(IToken)Match(input,WITH,Follow._WITH_in_selected_signal_assignment13755); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WITH.Add(WITH675);

			DebugLocation(1457, 14);
			PushFollow(Follow._expression_in_selected_signal_assignment13757);
			expression676=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression676.Tree);
			DebugLocation(1457, 25);
			SELECT677=(IToken)Match(input,SELECT,Follow._SELECT_in_selected_signal_assignment13759); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SELECT.Add(SELECT677);

			DebugLocation(1457, 32);
			PushFollow(Follow._target_in_selected_signal_assignment13761);
			target678=target();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_target.Add(target678.Tree);
			DebugLocation(1457, 39);
			LE679=(IToken)Match(input,LE,Follow._LE_in_selected_signal_assignment13763); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LE.Add(LE679);

			DebugLocation(1457, 45);
			PushFollow(Follow._signal_assignment_options_in_selected_signal_assignment13767);
			sao=signal_assignment_options();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_signal_assignment_options.Add(sao.Tree);
			DebugLocation(1457, 74);
			PushFollow(Follow._selected_waveforms_in_selected_signal_assignment13771);
			sw=selected_waveforms();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_selected_waveforms.Add(sw.Tree);
			DebugLocation(1457, 94);
			SEMI680=(IToken)Match(input,SEMI,Follow._SEMI_in_selected_signal_assignment13773); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI680);



			{
			// AST REWRITE
			// elements: sao, target, sw, expression
			// token labels: 
			// rule labels: retval, sao, sw
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_sao=new RewriteRuleSubtreeStream(adaptor,"rule sao",sao!=null?sao.Tree:null);
			RewriteRuleSubtreeStream stream_sw=new RewriteRuleSubtreeStream(adaptor,"rule sw",sw!=null?sw.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1458:9: -> ^( SELECTED_SIGNAL_ASSIGNMENT_STATEMENT expression target ( $sao)? $sw)
			{
				DebugLocation(1458, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1458:12: ^( SELECTED_SIGNAL_ASSIGNMENT_STATEMENT expression target ( $sao)? $sw)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1458, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SELECTED_SIGNAL_ASSIGNMENT_STATEMENT, "SELECTED_SIGNAL_ASSIGNMENT_STATEMENT"), root_1);

				DebugLocation(1458, 52);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1458, 63);
				adaptor.AddChild(root_1, stream_target.NextTree());
				DebugLocation(1458, 71);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1458:71: ( $sao)?
				if (stream_sao.HasNext)
				{
					DebugLocation(1458, 71);
					adaptor.AddChild(root_1, stream_sao.NextTree());

				}
				stream_sao.Reset();
				DebugLocation(1458, 77);
				adaptor.AddChild(root_1, stream_sw.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selected_signal_assignment", 176);
			LeaveRule("selected_signal_assignment", 176);
			LeaveRule_selected_signal_assignment();
			if (state.backtracking > 0) { Memoize(input, 176, selected_signal_assignment_StartIndex); }

		}
		DebugLocation(1459, 4);
		} finally { DebugExitRule(GrammarFileName, "selected_signal_assignment"); }
		return retval;

	}
	// $ANTLR end "selected_signal_assignment"

	partial void EnterRule_selected_waveform();
	partial void LeaveRule_selected_waveform();

	// $ANTLR start "selected_waveform"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1461:1: selected_waveform : waveform WHEN choices -> waveform choices ;
	[GrammarRule("selected_waveform")]
	private AstParserRuleReturnScope<CommonTree, IToken> selected_waveform()
	{
		EnterRule_selected_waveform();
		EnterRule("selected_waveform", 177);
		TraceIn("selected_waveform", 177);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int selected_waveform_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WHEN682 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> waveform681 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> choices683 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHEN682_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WHEN=new RewriteRuleITokenStream(adaptor,"token WHEN");
		RewriteRuleSubtreeStream stream_choices=new RewriteRuleSubtreeStream(adaptor,"rule choices");
		RewriteRuleSubtreeStream stream_waveform=new RewriteRuleSubtreeStream(adaptor,"rule waveform");
		try { DebugEnterRule(GrammarFileName, "selected_waveform");
		DebugLocation(1461, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 177)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1462:5: ( waveform WHEN choices -> waveform choices )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1462:9: waveform WHEN choices
			{
			DebugLocation(1462, 9);
			PushFollow(Follow._waveform_in_selected_waveform13819);
			waveform681=waveform();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_waveform.Add(waveform681.Tree);
			DebugLocation(1462, 18);
			WHEN682=(IToken)Match(input,WHEN,Follow._WHEN_in_selected_waveform13821); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHEN.Add(WHEN682);

			DebugLocation(1462, 23);
			PushFollow(Follow._choices_in_selected_waveform13823);
			choices683=choices();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_choices.Add(choices683.Tree);


			{
			// AST REWRITE
			// elements: waveform, choices
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1463:9: -> waveform choices
			{
				DebugLocation(1463, 12);
				adaptor.AddChild(root_0, stream_waveform.NextTree());
				DebugLocation(1463, 21);
				adaptor.AddChild(root_0, stream_choices.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selected_waveform", 177);
			LeaveRule("selected_waveform", 177);
			LeaveRule_selected_waveform();
			if (state.backtracking > 0) { Memoize(input, 177, selected_waveform_StartIndex); }

		}
		DebugLocation(1464, 4);
		} finally { DebugExitRule(GrammarFileName, "selected_waveform"); }
		return retval;

	}
	// $ANTLR end "selected_waveform"

	partial void EnterRule_selected_waveforms();
	partial void LeaveRule_selected_waveforms();

	// $ANTLR start "selected_waveforms"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1466:1: selected_waveforms : selected_waveform ( COMMA selected_waveform )* -> ( selected_waveform )+ ;
	[GrammarRule("selected_waveforms")]
	private AstParserRuleReturnScope<CommonTree, IToken> selected_waveforms()
	{
		EnterRule_selected_waveforms();
		EnterRule("selected_waveforms", 178);
		TraceIn("selected_waveforms", 178);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int selected_waveforms_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA685 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> selected_waveform684 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> selected_waveform686 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA685_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_selected_waveform=new RewriteRuleSubtreeStream(adaptor,"rule selected_waveform");
		try { DebugEnterRule(GrammarFileName, "selected_waveforms");
		DebugLocation(1466, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 178)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1467:5: ( selected_waveform ( COMMA selected_waveform )* -> ( selected_waveform )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1467:9: selected_waveform ( COMMA selected_waveform )*
			{
			DebugLocation(1467, 9);
			PushFollow(Follow._selected_waveform_in_selected_waveforms13856);
			selected_waveform684=selected_waveform();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_selected_waveform.Add(selected_waveform684.Tree);
			DebugLocation(1467, 27);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1467:27: ( COMMA selected_waveform )*
			try { DebugEnterSubRule(208);
			while (true)
			{
				int alt208=2;
				try { DebugEnterDecision(208, false);
				int LA208_0 = input.LA(1);

				if ((LA208_0==COMMA))
				{
					alt208 = 1;
				}


				} finally { DebugExitDecision(208); }
				switch ( alt208 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1467:29: COMMA selected_waveform
					{
					DebugLocation(1467, 29);
					COMMA685=(IToken)Match(input,COMMA,Follow._COMMA_in_selected_waveforms13860); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA685);

					DebugLocation(1467, 35);
					PushFollow(Follow._selected_waveform_in_selected_waveforms13862);
					selected_waveform686=selected_waveform();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_selected_waveform.Add(selected_waveform686.Tree);

					}
					break;

				default:
					goto loop208;
				}
			}

			loop208:
				;

			} finally { DebugExitSubRule(208); }



			{
			// AST REWRITE
			// elements: selected_waveform
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1468:9: -> ( selected_waveform )+
			{
				DebugLocation(1468, 12);
				if (!(stream_selected_waveform.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_selected_waveform.HasNext )
				{
					DebugLocation(1468, 12);
					adaptor.AddChild(root_0, stream_selected_waveform.NextTree());

				}
				stream_selected_waveform.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selected_waveforms", 178);
			LeaveRule("selected_waveforms", 178);
			LeaveRule_selected_waveforms();
			if (state.backtracking > 0) { Memoize(input, 178, selected_waveforms_StartIndex); }

		}
		DebugLocation(1469, 4);
		} finally { DebugExitRule(GrammarFileName, "selected_waveforms"); }
		return retval;

	}
	// $ANTLR end "selected_waveforms"

	partial void EnterRule_sensitivity_clause();
	partial void LeaveRule_sensitivity_clause();

	// $ANTLR start "sensitivity_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1471:1: sensitivity_clause : ON sensitivity_list -> ^( ON sensitivity_list ) ;
	[GrammarRule("sensitivity_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> sensitivity_clause()
	{
		EnterRule_sensitivity_clause();
		EnterRule("sensitivity_clause", 179);
		TraceIn("sensitivity_clause", 179);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sensitivity_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken ON687 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sensitivity_list688 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ON687_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ON=new RewriteRuleITokenStream(adaptor,"token ON");
		RewriteRuleSubtreeStream stream_sensitivity_list=new RewriteRuleSubtreeStream(adaptor,"rule sensitivity_list");
		try { DebugEnterRule(GrammarFileName, "sensitivity_clause");
		DebugLocation(1471, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 179)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1472:5: ( ON sensitivity_list -> ^( ON sensitivity_list ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1472:9: ON sensitivity_list
			{
			DebugLocation(1472, 9);
			ON687=(IToken)Match(input,ON,Follow._ON_in_sensitivity_clause13897); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ON.Add(ON687);

			DebugLocation(1472, 12);
			PushFollow(Follow._sensitivity_list_in_sensitivity_clause13899);
			sensitivity_list688=sensitivity_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sensitivity_list.Add(sensitivity_list688.Tree);


			{
			// AST REWRITE
			// elements: sensitivity_list, ON
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1473:9: -> ^( ON sensitivity_list )
			{
				DebugLocation(1473, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1473:12: ^( ON sensitivity_list )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1473, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ON.NextNode(), root_1);

				DebugLocation(1473, 18);
				adaptor.AddChild(root_1, stream_sensitivity_list.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sensitivity_clause", 179);
			LeaveRule("sensitivity_clause", 179);
			LeaveRule_sensitivity_clause();
			if (state.backtracking > 0) { Memoize(input, 179, sensitivity_clause_StartIndex); }

		}
		DebugLocation(1474, 4);
		} finally { DebugExitRule(GrammarFileName, "sensitivity_clause"); }
		return retval;

	}
	// $ANTLR end "sensitivity_clause"

	partial void EnterRule_sensitivity_list();
	partial void LeaveRule_sensitivity_list();

	// $ANTLR start "sensitivity_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1476:1: sensitivity_list : signal= name ( COMMA signal= name )* -> ( name )+ ;
	[GrammarRule("sensitivity_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> sensitivity_list()
	{
		EnterRule_sensitivity_list();
		EnterRule("sensitivity_list", 180);
		TraceIn("sensitivity_list", 180);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sensitivity_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA689 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> signal = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA689_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "sensitivity_list");
		DebugLocation(1476, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 180)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1477:5: (signal= name ( COMMA signal= name )* -> ( name )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1477:9: signal= name ( COMMA signal= name )*
			{
			DebugLocation(1477, 15);
			PushFollow(Follow._name_in_sensitivity_list13938);
			signal=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(signal.Tree);
			DebugLocation(1477, 21);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1477:21: ( COMMA signal= name )*
			try { DebugEnterSubRule(209);
			while (true)
			{
				int alt209=2;
				try { DebugEnterDecision(209, false);
				int LA209_0 = input.LA(1);

				if ((LA209_0==COMMA))
				{
					alt209 = 1;
				}


				} finally { DebugExitDecision(209); }
				switch ( alt209 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1477:23: COMMA signal= name
					{
					DebugLocation(1477, 23);
					COMMA689=(IToken)Match(input,COMMA,Follow._COMMA_in_sensitivity_list13942); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA689);

					DebugLocation(1477, 35);
					PushFollow(Follow._name_in_sensitivity_list13946);
					signal=name();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name.Add(signal.Tree);

					}
					break;

				default:
					goto loop209;
				}
			}

			loop209:
				;

			} finally { DebugExitSubRule(209); }



			{
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1478:9: -> ( name )+
			{
				DebugLocation(1478, 12);
				if (!(stream_name.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_name.HasNext )
				{
					DebugLocation(1478, 12);
					adaptor.AddChild(root_0, stream_name.NextTree());

				}
				stream_name.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sensitivity_list", 180);
			LeaveRule("sensitivity_list", 180);
			LeaveRule_sensitivity_list();
			if (state.backtracking > 0) { Memoize(input, 180, sensitivity_list_StartIndex); }

		}
		DebugLocation(1479, 4);
		} finally { DebugExitRule(GrammarFileName, "sensitivity_list"); }
		return retval;

	}
	// $ANTLR end "sensitivity_list"

	partial void EnterRule_sequence_of_statements();
	partial void LeaveRule_sequence_of_statements();

	// $ANTLR start "sequence_of_statements"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1481:1: sequence_of_statements : ( sequential_statement )* ;
	[GrammarRule("sequence_of_statements")]
	private AstParserRuleReturnScope<CommonTree, IToken> sequence_of_statements()
	{
		EnterRule_sequence_of_statements();
		EnterRule("sequence_of_statements", 181);
		TraceIn("sequence_of_statements", 181);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sequence_of_statements_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> sequential_statement690 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "sequence_of_statements");
		DebugLocation(1481, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 181)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1482:5: ( ( sequential_statement )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1482:9: ( sequential_statement )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1482, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1482:9: ( sequential_statement )*
			try { DebugEnterSubRule(210);
			while (true)
			{
				int alt210=2;
				try { DebugEnterDecision(210, false);
				int LA210_0 = input.LA(1);

				if ((LA210_0==ASSERT||LA210_0==BASIC_IDENTIFIER||LA210_0==CASE||LA210_0==EXIT||LA210_0==EXTENDED_IDENTIFIER||LA210_0==FOR||LA210_0==IF||LA210_0==LOOP||LA210_0==LPAREN||LA210_0==NEXT||LA210_0==NULLTOK||LA210_0==REPORT||LA210_0==RETURN||LA210_0==STRING_LITERAL||LA210_0==WAIT||LA210_0==WHILE))
				{
					alt210 = 1;
				}


				} finally { DebugExitDecision(210); }
				switch ( alt210 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1482:9: sequential_statement
					{
					DebugLocation(1482, 9);
					PushFollow(Follow._sequential_statement_in_sequence_of_statements13981);
					sequential_statement690=sequential_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, sequential_statement690.Tree);

					}
					break;

				default:
					goto loop210;
				}
			}

			loop210:
				;

			} finally { DebugExitSubRule(210); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sequence_of_statements", 181);
			LeaveRule("sequence_of_statements", 181);
			LeaveRule_sequence_of_statements();
			if (state.backtracking > 0) { Memoize(input, 181, sequence_of_statements_StartIndex); }

		}
		DebugLocation(1483, 4);
		} finally { DebugExitRule(GrammarFileName, "sequence_of_statements"); }
		return retval;

	}
	// $ANTLR end "sequence_of_statements"

	partial void EnterRule_sequential_statement();
	partial void LeaveRule_sequential_statement();

	// $ANTLR start "sequential_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1487:1: sequential_statement : ( identifier COLON s= sequential_statement_2 -> ^( LABEL_STATEMENT identifier $s) | sequential_statement_2 );
	[GrammarRule("sequential_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> sequential_statement()
	{
		EnterRule_sequential_statement();
		EnterRule("sequential_statement", 182);
		TraceIn("sequential_statement", 182);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sequential_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COLON692 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier691 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sequential_statement_2693 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON692_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_sequential_statement_2=new RewriteRuleSubtreeStream(adaptor,"rule sequential_statement_2");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "sequential_statement");
		DebugLocation(1487, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 182)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1488:5: ( identifier COLON s= sequential_statement_2 -> ^( LABEL_STATEMENT identifier $s) | sequential_statement_2 )
			int alt211=2;
			try { DebugEnterDecision(211, false);
			int LA211_0 = input.LA(1);

			if ((LA211_0==BASIC_IDENTIFIER||LA211_0==EXTENDED_IDENTIFIER))
			{
				int LA211_1 = input.LA(2);

				if ((LA211_1==COLON))
				{
					alt211 = 1;
				}
				else if ((LA211_1==APOSTROPHE||LA211_1==DOT||(LA211_1>=LBRACKET && LA211_1<=LE)||LA211_1==LPAREN||LA211_1==SEMI||LA211_1==VARASGN))
				{
					alt211 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 211, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA211_0==ASSERT||LA211_0==CASE||LA211_0==EXIT||LA211_0==FOR||LA211_0==IF||LA211_0==LOOP||LA211_0==LPAREN||LA211_0==NEXT||LA211_0==NULLTOK||LA211_0==REPORT||LA211_0==RETURN||LA211_0==STRING_LITERAL||LA211_0==WAIT||LA211_0==WHILE))
			{
				alt211 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 211, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(211); }
			switch (alt211)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1488:9: identifier COLON s= sequential_statement_2
				{
				DebugLocation(1488, 9);
				PushFollow(Follow._identifier_in_sequential_statement14003);
				identifier691=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifier.Add(identifier691.Tree);
				DebugLocation(1488, 20);
				COLON692=(IToken)Match(input,COLON,Follow._COLON_in_sequential_statement14005); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON692);

				DebugLocation(1488, 27);
				PushFollow(Follow._sequential_statement_2_in_sequential_statement14009);
				s=sequential_statement_2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_sequential_statement_2.Add(s.Tree);


				{
				// AST REWRITE
				// elements: identifier, s
				// token labels: 
				// rule labels: retval, s
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1489:9: -> ^( LABEL_STATEMENT identifier $s)
				{
					DebugLocation(1489, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1489:12: ^( LABEL_STATEMENT identifier $s)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1489, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LABEL_STATEMENT, "LABEL_STATEMENT"), root_1);

					DebugLocation(1489, 31);
					adaptor.AddChild(root_1, stream_identifier.NextTree());
					DebugLocation(1489, 43);
					adaptor.AddChild(root_1, stream_s.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1490:9: sequential_statement_2
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1490, 9);
				PushFollow(Follow._sequential_statement_2_in_sequential_statement14040);
				sequential_statement_2693=sequential_statement_2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, sequential_statement_2693.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sequential_statement", 182);
			LeaveRule("sequential_statement", 182);
			LeaveRule_sequential_statement();
			if (state.backtracking > 0) { Memoize(input, 182, sequential_statement_StartIndex); }

		}
		DebugLocation(1491, 4);
		} finally { DebugExitRule(GrammarFileName, "sequential_statement"); }
		return retval;

	}
	// $ANTLR end "sequential_statement"

	partial void EnterRule_sequential_statement_2();
	partial void LeaveRule_sequential_statement_2();

	// $ANTLR start "sequential_statement_2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1493:1: sequential_statement_2 : ( wait_statement | assertion_statement | report_statement | ( target LE )=> signal_assignment_statement | ( target VARASGN )=> variable_assignment_statement | procedure_call_statement | if_statement | case_statement | loop_statement | next_statement | exit_statement | return_statement | null_statement );
	[GrammarRule("sequential_statement_2")]
	private AstParserRuleReturnScope<CommonTree, IToken> sequential_statement_2()
	{
		EnterRule_sequential_statement_2();
		EnterRule("sequential_statement_2", 183);
		TraceIn("sequential_statement_2", 183);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sequential_statement_2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> wait_statement694 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assertion_statement695 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> report_statement696 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signal_assignment_statement697 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variable_assignment_statement698 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> procedure_call_statement699 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> if_statement700 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> case_statement701 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> loop_statement702 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> next_statement703 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> exit_statement704 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> return_statement705 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> null_statement706 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "sequential_statement_2");
		DebugLocation(1493, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 183)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1494:5: ( wait_statement | assertion_statement | report_statement | ( target LE )=> signal_assignment_statement | ( target VARASGN )=> variable_assignment_statement | procedure_call_statement | if_statement | case_statement | loop_statement | next_statement | exit_statement | return_statement | null_statement )
			int alt212=13;
			try { DebugEnterDecision(212, false);
			switch (input.LA(1))
			{
			case WAIT:
				{
				alt212 = 1;
				}
				break;
			case ASSERT:
				{
				alt212 = 2;
				}
				break;
			case REPORT:
				{
				alt212 = 3;
				}
				break;
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				int LA212_4 = input.LA(2);

				if ((EvaluatePredicate(synpred15_VhdlAntlr_fragment)))
				{
					alt212 = 4;
				}
				else if ((EvaluatePredicate(synpred16_VhdlAntlr_fragment)))
				{
					alt212 = 5;
				}
				else if ((true))
				{
					alt212 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 212, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STRING_LITERAL:
				{
				int LA212_5 = input.LA(2);

				if ((EvaluatePredicate(synpred15_VhdlAntlr_fragment)))
				{
					alt212 = 4;
				}
				else if ((EvaluatePredicate(synpred16_VhdlAntlr_fragment)))
				{
					alt212 = 5;
				}
				else if ((true))
				{
					alt212 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 212, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPAREN:
				{
				int LA212_6 = input.LA(2);

				if ((EvaluatePredicate(synpred15_VhdlAntlr_fragment)))
				{
					alt212 = 4;
				}
				else if ((EvaluatePredicate(synpred16_VhdlAntlr_fragment)))
				{
					alt212 = 5;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 212, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt212 = 7;
				}
				break;
			case CASE:
				{
				alt212 = 8;
				}
				break;
			case FOR:
			case LOOP:
			case WHILE:
				{
				alt212 = 9;
				}
				break;
			case NEXT:
				{
				alt212 = 10;
				}
				break;
			case EXIT:
				{
				alt212 = 11;
				}
				break;
			case RETURN:
				{
				alt212 = 12;
				}
				break;
			case NULLTOK:
				{
				alt212 = 13;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 212, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(212); }
			switch (alt212)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1494:9: wait_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1494, 9);
				PushFollow(Follow._wait_statement_in_sequential_statement_214059);
				wait_statement694=wait_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, wait_statement694.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1495:9: assertion_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1495, 9);
				PushFollow(Follow._assertion_statement_in_sequential_statement_214069);
				assertion_statement695=assertion_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assertion_statement695.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1496:9: report_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1496, 9);
				PushFollow(Follow._report_statement_in_sequential_statement_214079);
				report_statement696=report_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, report_statement696.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1497:9: ( target LE )=> signal_assignment_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1497, 23);
				PushFollow(Follow._signal_assignment_statement_in_sequential_statement_214096);
				signal_assignment_statement697=signal_assignment_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, signal_assignment_statement697.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1498:9: ( target VARASGN )=> variable_assignment_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1498, 28);
				PushFollow(Follow._variable_assignment_statement_in_sequential_statement_214113);
				variable_assignment_statement698=variable_assignment_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_assignment_statement698.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1499:9: procedure_call_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1499, 9);
				PushFollow(Follow._procedure_call_statement_in_sequential_statement_214123);
				procedure_call_statement699=procedure_call_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, procedure_call_statement699.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1500:9: if_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1500, 9);
				PushFollow(Follow._if_statement_in_sequential_statement_214133);
				if_statement700=if_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_statement700.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1501:9: case_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1501, 9);
				PushFollow(Follow._case_statement_in_sequential_statement_214143);
				case_statement701=case_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, case_statement701.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1502:9: loop_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1502, 9);
				PushFollow(Follow._loop_statement_in_sequential_statement_214153);
				loop_statement702=loop_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, loop_statement702.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1503:9: next_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1503, 9);
				PushFollow(Follow._next_statement_in_sequential_statement_214163);
				next_statement703=next_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, next_statement703.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1504:9: exit_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1504, 9);
				PushFollow(Follow._exit_statement_in_sequential_statement_214173);
				exit_statement704=exit_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, exit_statement704.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1505:9: return_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1505, 9);
				PushFollow(Follow._return_statement_in_sequential_statement_214183);
				return_statement705=return_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_statement705.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1506:9: null_statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1506, 9);
				PushFollow(Follow._null_statement_in_sequential_statement_214193);
				null_statement706=null_statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, null_statement706.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sequential_statement_2", 183);
			LeaveRule("sequential_statement_2", 183);
			LeaveRule_sequential_statement_2();
			if (state.backtracking > 0) { Memoize(input, 183, sequential_statement_2_StartIndex); }

		}
		DebugLocation(1507, 4);
		} finally { DebugExitRule(GrammarFileName, "sequential_statement_2"); }
		return retval;

	}
	// $ANTLR end "sequential_statement_2"

	partial void EnterRule_shift_expression();
	partial void LeaveRule_shift_expression();

	// $ANTLR start "shift_expression"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1509:1: shift_expression : simple_expression2 ( shift_operator ^ simple_expression2 )? ;
	[GrammarRule("shift_expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 184);
		TraceIn("shift_expression", 184);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int shift_expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> simple_expression2707 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift_operator708 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> simple_expression2709 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(1509, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 184)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1510:5: ( simple_expression2 ( shift_operator ^ simple_expression2 )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1510:9: simple_expression2 ( shift_operator ^ simple_expression2 )?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1510, 9);
			PushFollow(Follow._simple_expression2_in_shift_expression14212);
			simple_expression2707=simple_expression2();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, simple_expression2707.Tree);
			DebugLocation(1510, 28);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1510:28: ( shift_operator ^ simple_expression2 )?
			int alt213=2;
			try { DebugEnterSubRule(213);
			try { DebugEnterDecision(213, false);
			int LA213_0 = input.LA(1);

			if (((LA213_0>=ROL && LA213_0<=ROR)||(LA213_0>=SLA && LA213_0<=SLL)||(LA213_0>=SRA && LA213_0<=SRL)))
			{
				alt213 = 1;
			}
			} finally { DebugExitDecision(213); }
			switch (alt213)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1510:30: shift_operator ^ simple_expression2
				{
				DebugLocation(1510, 44);
				PushFollow(Follow._shift_operator_in_shift_expression14216);
				shift_operator708=shift_operator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(shift_operator708.Tree, root_0);
				DebugLocation(1510, 46);
				PushFollow(Follow._simple_expression2_in_shift_expression14219);
				simple_expression2709=simple_expression2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_expression2709.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(213); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_expression", 184);
			LeaveRule("shift_expression", 184);
			LeaveRule_shift_expression();
			if (state.backtracking > 0) { Memoize(input, 184, shift_expression_StartIndex); }

		}
		DebugLocation(1511, 4);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"

	partial void EnterRule_shift_operator();
	partial void LeaveRule_shift_operator();

	// $ANTLR start "shift_operator"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1513:1: shift_operator : ( SLL | SRL | SLA | SRA | ROL | ROR );
	[GrammarRule("shift_operator")]
	private AstParserRuleReturnScope<CommonTree, IToken> shift_operator()
	{
		EnterRule_shift_operator();
		EnterRule("shift_operator", 185);
		TraceIn("shift_operator", 185);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int shift_operator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set710 = default(IToken);

		CommonTree set710_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shift_operator");
		DebugLocation(1513, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 185)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1514:5: ( SLL | SRL | SLA | SRA | ROL | ROR )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1514, 5);

			set710=(IToken)input.LT(1);
			if ((input.LA(1)>=ROL && input.LA(1)<=ROR)||(input.LA(1)>=SLA && input.LA(1)<=SLL)||(input.LA(1)>=SRA && input.LA(1)<=SRL))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set710));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_operator", 185);
			LeaveRule("shift_operator", 185);
			LeaveRule_shift_operator();
			if (state.backtracking > 0) { Memoize(input, 185, shift_operator_StartIndex); }

		}
		DebugLocation(1520, 4);
		} finally { DebugExitRule(GrammarFileName, "shift_operator"); }
		return retval;

	}
	// $ANTLR end "shift_operator"

	partial void EnterRule_sign();
	partial void LeaveRule_sign();

	// $ANTLR start "sign"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1522:1: sign : ( PLUS | MINUS );
	[GrammarRule("sign")]
	private AstParserRuleReturnScope<CommonTree, IToken> sign()
	{
		EnterRule_sign();
		EnterRule("sign", 186);
		TraceIn("sign", 186);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sign_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set711 = default(IToken);

		CommonTree set711_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "sign");
		DebugLocation(1522, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 186)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1523:5: ( PLUS | MINUS )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1523, 5);

			set711=(IToken)input.LT(1);
			if (input.LA(1)==MINUS||input.LA(1)==PLUS)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set711));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sign", 186);
			LeaveRule("sign", 186);
			LeaveRule_sign();
			if (state.backtracking > 0) { Memoize(input, 186, sign_StartIndex); }

		}
		DebugLocation(1525, 4);
		} finally { DebugExitRule(GrammarFileName, "sign"); }
		return retval;

	}
	// $ANTLR end "sign"

	partial void EnterRule_signal_assignment_statement();
	partial void LeaveRule_signal_assignment_statement();

	// $ANTLR start "signal_assignment_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1527:1: signal_assignment_statement : target LE ( delay_mechanism )? waveform SEMI -> ^( SIGNAL_ASSIGNMENT_STATEMENT target ( delay_mechanism )? waveform ) ;
	[GrammarRule("signal_assignment_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> signal_assignment_statement()
	{
		EnterRule_signal_assignment_statement();
		EnterRule("signal_assignment_statement", 187);
		TraceIn("signal_assignment_statement", 187);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signal_assignment_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LE713 = default(IToken);
		IToken SEMI716 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> target712 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> delay_mechanism714 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> waveform715 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LE713_tree = default(CommonTree);
		CommonTree SEMI716_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LE=new RewriteRuleITokenStream(adaptor,"token LE");
		RewriteRuleSubtreeStream stream_delay_mechanism=new RewriteRuleSubtreeStream(adaptor,"rule delay_mechanism");
		RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target");
		RewriteRuleSubtreeStream stream_waveform=new RewriteRuleSubtreeStream(adaptor,"rule waveform");
		try { DebugEnterRule(GrammarFileName, "signal_assignment_statement");
		DebugLocation(1527, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 187)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1528:5: ( target LE ( delay_mechanism )? waveform SEMI -> ^( SIGNAL_ASSIGNMENT_STATEMENT target ( delay_mechanism )? waveform ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1528:9: target LE ( delay_mechanism )? waveform SEMI
			{
			DebugLocation(1528, 9);
			PushFollow(Follow._target_in_signal_assignment_statement14339);
			target712=target();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_target.Add(target712.Tree);
			DebugLocation(1528, 16);
			LE713=(IToken)Match(input,LE,Follow._LE_in_signal_assignment_statement14341); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LE.Add(LE713);

			DebugLocation(1528, 19);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1528:19: ( delay_mechanism )?
			int alt214=2;
			try { DebugEnterSubRule(214);
			try { DebugEnterDecision(214, false);
			int LA214_0 = input.LA(1);

			if ((LA214_0==INERTIAL||LA214_0==REJECT||LA214_0==TRANSPORT))
			{
				alt214 = 1;
			}
			} finally { DebugExitDecision(214); }
			switch (alt214)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1528:19: delay_mechanism
				{
				DebugLocation(1528, 19);
				PushFollow(Follow._delay_mechanism_in_signal_assignment_statement14343);
				delay_mechanism714=delay_mechanism();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_delay_mechanism.Add(delay_mechanism714.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(214); }

			DebugLocation(1528, 36);
			PushFollow(Follow._waveform_in_signal_assignment_statement14346);
			waveform715=waveform();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_waveform.Add(waveform715.Tree);
			DebugLocation(1528, 45);
			SEMI716=(IToken)Match(input,SEMI,Follow._SEMI_in_signal_assignment_statement14348); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI716);



			{
			// AST REWRITE
			// elements: waveform, target, delay_mechanism
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1529:9: -> ^( SIGNAL_ASSIGNMENT_STATEMENT target ( delay_mechanism )? waveform )
			{
				DebugLocation(1529, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1529:12: ^( SIGNAL_ASSIGNMENT_STATEMENT target ( delay_mechanism )? waveform )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1529, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIGNAL_ASSIGNMENT_STATEMENT, "SIGNAL_ASSIGNMENT_STATEMENT"), root_1);

				DebugLocation(1529, 43);
				adaptor.AddChild(root_1, stream_target.NextTree());
				DebugLocation(1529, 50);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1529:50: ( delay_mechanism )?
				if (stream_delay_mechanism.HasNext)
				{
					DebugLocation(1529, 50);
					adaptor.AddChild(root_1, stream_delay_mechanism.NextTree());

				}
				stream_delay_mechanism.Reset();
				DebugLocation(1529, 67);
				adaptor.AddChild(root_1, stream_waveform.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signal_assignment_statement", 187);
			LeaveRule("signal_assignment_statement", 187);
			LeaveRule_signal_assignment_statement();
			if (state.backtracking > 0) { Memoize(input, 187, signal_assignment_statement_StartIndex); }

		}
		DebugLocation(1530, 4);
		} finally { DebugExitRule(GrammarFileName, "signal_assignment_statement"); }
		return retval;

	}
	// $ANTLR end "signal_assignment_statement"

	partial void EnterRule_signal_declaration();
	partial void LeaveRule_signal_declaration();

	// $ANTLR start "signal_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1532:1: signal_declaration : SIGNAL identifier_list COLON subtype_indication ( signal_kind )? ( VARASGN expression )? SEMI -> ^( SIGNAL identifier_list subtype_indication ( signal_kind )? ( expression )? ) ;
	[GrammarRule("signal_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> signal_declaration()
	{
		EnterRule_signal_declaration();
		EnterRule("signal_declaration", 188);
		TraceIn("signal_declaration", 188);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signal_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SIGNAL717 = default(IToken);
		IToken COLON719 = default(IToken);
		IToken VARASGN722 = default(IToken);
		IToken SEMI724 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list718 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication720 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signal_kind721 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression723 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SIGNAL717_tree = default(CommonTree);
		CommonTree COLON719_tree = default(CommonTree);
		CommonTree VARASGN722_tree = default(CommonTree);
		CommonTree SEMI724_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_SIGNAL=new RewriteRuleITokenStream(adaptor,"token SIGNAL");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_signal_kind=new RewriteRuleSubtreeStream(adaptor,"rule signal_kind");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "signal_declaration");
		DebugLocation(1532, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 188)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:5: ( SIGNAL identifier_list COLON subtype_indication ( signal_kind )? ( VARASGN expression )? SEMI -> ^( SIGNAL identifier_list subtype_indication ( signal_kind )? ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:9: SIGNAL identifier_list COLON subtype_indication ( signal_kind )? ( VARASGN expression )? SEMI
			{
			DebugLocation(1533, 9);
			SIGNAL717=(IToken)Match(input,SIGNAL,Follow._SIGNAL_in_signal_declaration14390); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SIGNAL.Add(SIGNAL717);

			DebugLocation(1533, 16);
			PushFollow(Follow._identifier_list_in_signal_declaration14392);
			identifier_list718=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list718.Tree);
			DebugLocation(1533, 32);
			COLON719=(IToken)Match(input,COLON,Follow._COLON_in_signal_declaration14394); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON719);

			DebugLocation(1533, 38);
			PushFollow(Follow._subtype_indication_in_signal_declaration14396);
			subtype_indication720=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication720.Tree);
			DebugLocation(1533, 57);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:57: ( signal_kind )?
			int alt215=2;
			try { DebugEnterSubRule(215);
			try { DebugEnterDecision(215, false);
			int LA215_0 = input.LA(1);

			if ((LA215_0==BUS||LA215_0==REGISTER))
			{
				alt215 = 1;
			}
			} finally { DebugExitDecision(215); }
			switch (alt215)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:57: signal_kind
				{
				DebugLocation(1533, 57);
				PushFollow(Follow._signal_kind_in_signal_declaration14398);
				signal_kind721=signal_kind();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_signal_kind.Add(signal_kind721.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(215); }

			DebugLocation(1533, 70);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:70: ( VARASGN expression )?
			int alt216=2;
			try { DebugEnterSubRule(216);
			try { DebugEnterDecision(216, false);
			int LA216_0 = input.LA(1);

			if ((LA216_0==VARASGN))
			{
				alt216 = 1;
			}
			} finally { DebugExitDecision(216); }
			switch (alt216)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1533:72: VARASGN expression
				{
				DebugLocation(1533, 72);
				VARASGN722=(IToken)Match(input,VARASGN,Follow._VARASGN_in_signal_declaration14403); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN722);

				DebugLocation(1533, 80);
				PushFollow(Follow._expression_in_signal_declaration14405);
				expression723=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression723.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(216); }

			DebugLocation(1533, 94);
			SEMI724=(IToken)Match(input,SEMI,Follow._SEMI_in_signal_declaration14410); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI724);



			{
			// AST REWRITE
			// elements: subtype_indication, SIGNAL, expression, identifier_list, signal_kind
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1534:9: -> ^( SIGNAL identifier_list subtype_indication ( signal_kind )? ( expression )? )
			{
				DebugLocation(1534, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1534:12: ^( SIGNAL identifier_list subtype_indication ( signal_kind )? ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1534, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_SIGNAL.NextNode(), root_1);

				DebugLocation(1534, 22);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1534, 38);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1534, 57);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1534:57: ( signal_kind )?
				if (stream_signal_kind.HasNext)
				{
					DebugLocation(1534, 57);
					adaptor.AddChild(root_1, stream_signal_kind.NextTree());

				}
				stream_signal_kind.Reset();
				DebugLocation(1534, 70);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1534:70: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(1534, 70);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signal_declaration", 188);
			LeaveRule("signal_declaration", 188);
			LeaveRule_signal_declaration();
			if (state.backtracking > 0) { Memoize(input, 188, signal_declaration_StartIndex); }

		}
		DebugLocation(1535, 4);
		} finally { DebugExitRule(GrammarFileName, "signal_declaration"); }
		return retval;

	}
	// $ANTLR end "signal_declaration"

	partial void EnterRule_signal_kind();
	partial void LeaveRule_signal_kind();

	// $ANTLR start "signal_kind"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1537:1: signal_kind : ( REGISTER | BUS );
	[GrammarRule("signal_kind")]
	private AstParserRuleReturnScope<CommonTree, IToken> signal_kind()
	{
		EnterRule_signal_kind();
		EnterRule("signal_kind", 189);
		TraceIn("signal_kind", 189);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signal_kind_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set725 = default(IToken);

		CommonTree set725_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "signal_kind");
		DebugLocation(1537, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 189)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1538:5: ( REGISTER | BUS )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1538, 5);

			set725=(IToken)input.LT(1);
			if (input.LA(1)==BUS||input.LA(1)==REGISTER)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set725));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signal_kind", 189);
			LeaveRule("signal_kind", 189);
			LeaveRule_signal_kind();
			if (state.backtracking > 0) { Memoize(input, 189, signal_kind_StartIndex); }

		}
		DebugLocation(1540, 4);
		} finally { DebugExitRule(GrammarFileName, "signal_kind"); }
		return retval;

	}
	// $ANTLR end "signal_kind"

	partial void EnterRule_signal_list();
	partial void LeaveRule_signal_list();

	// $ANTLR start "signal_list"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1542:1: signal_list : (signal= name ( COMMA signal= name )* -> ^( SIGNAL_LIST ( name )+ ) | OTHERS | ALL );
	[GrammarRule("signal_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> signal_list()
	{
		EnterRule_signal_list();
		EnterRule("signal_list", 190);
		TraceIn("signal_list", 190);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signal_list_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA726 = default(IToken);
		IToken OTHERS727 = default(IToken);
		IToken ALL728 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> signal = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA726_tree = default(CommonTree);
		CommonTree OTHERS727_tree = default(CommonTree);
		CommonTree ALL728_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "signal_list");
		DebugLocation(1542, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 190)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1543:5: (signal= name ( COMMA signal= name )* -> ^( SIGNAL_LIST ( name )+ ) | OTHERS | ALL )
			int alt218=3;
			try { DebugEnterDecision(218, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
			case STRING_LITERAL:
				{
				alt218 = 1;
				}
				break;
			case OTHERS:
				{
				alt218 = 2;
				}
				break;
			case ALL:
				{
				alt218 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 218, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(218); }
			switch (alt218)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1543:9: signal= name ( COMMA signal= name )*
				{
				DebugLocation(1543, 15);
				PushFollow(Follow._name_in_signal_list14486);
				signal=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(signal.Tree);
				DebugLocation(1543, 21);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1543:21: ( COMMA signal= name )*
				try { DebugEnterSubRule(217);
				while (true)
				{
					int alt217=2;
					try { DebugEnterDecision(217, false);
					int LA217_0 = input.LA(1);

					if ((LA217_0==COMMA))
					{
						alt217 = 1;
					}


					} finally { DebugExitDecision(217); }
					switch ( alt217 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1543:23: COMMA signal= name
						{
						DebugLocation(1543, 23);
						COMMA726=(IToken)Match(input,COMMA,Follow._COMMA_in_signal_list14490); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA726);

						DebugLocation(1543, 35);
						PushFollow(Follow._name_in_signal_list14494);
						signal=name();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_name.Add(signal.Tree);

						}
						break;

					default:
						goto loop217;
					}
				}

				loop217:
					;

				} finally { DebugExitSubRule(217); }



				{
				// AST REWRITE
				// elements: name
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1544:9: -> ^( SIGNAL_LIST ( name )+ )
				{
					DebugLocation(1544, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1544:12: ^( SIGNAL_LIST ( name )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1544, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIGNAL_LIST, "SIGNAL_LIST"), root_1);

					DebugLocation(1544, 27);
					if (!(stream_name.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_name.HasNext )
					{
						DebugLocation(1544, 27);
						adaptor.AddChild(root_1, stream_name.NextTree());

					}
					stream_name.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1545:9: OTHERS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1545, 9);
				OTHERS727=(IToken)Match(input,OTHERS,Follow._OTHERS_in_signal_list14526); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OTHERS727_tree = (CommonTree)adaptor.Create(OTHERS727);
				adaptor.AddChild(root_0, OTHERS727_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1546:9: ALL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1546, 9);
				ALL728=(IToken)Match(input,ALL,Follow._ALL_in_signal_list14536); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ALL728_tree = (CommonTree)adaptor.Create(ALL728);
				adaptor.AddChild(root_0, ALL728_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signal_list", 190);
			LeaveRule("signal_list", 190);
			LeaveRule_signal_list();
			if (state.backtracking > 0) { Memoize(input, 190, signal_list_StartIndex); }

		}
		DebugLocation(1547, 4);
		} finally { DebugExitRule(GrammarFileName, "signal_list"); }
		return retval;

	}
	// $ANTLR end "signal_list"

	partial void EnterRule_signature();
	partial void LeaveRule_signature();

	// $ANTLR start "signature"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1549:1: signature : LBRACKET ( signature_type_marks )? ( RETURN return_type= name )? RBRACKET -> ^( SIGNATURE ( signature_type_marks )? ( RETURN $return_type)? ) ;
	[GrammarRule("signature")]
	private AstParserRuleReturnScope<CommonTree, IToken> signature()
	{
		EnterRule_signature();
		EnterRule("signature", 191);
		TraceIn("signature", 191);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signature_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LBRACKET729 = default(IToken);
		IToken RETURN731 = default(IToken);
		IToken RBRACKET732 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> return_type = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> signature_type_marks730 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LBRACKET729_tree = default(CommonTree);
		CommonTree RETURN731_tree = default(CommonTree);
		CommonTree RBRACKET732_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_signature_type_marks=new RewriteRuleSubtreeStream(adaptor,"rule signature_type_marks");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "signature");
		DebugLocation(1549, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 191)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:5: ( LBRACKET ( signature_type_marks )? ( RETURN return_type= name )? RBRACKET -> ^( SIGNATURE ( signature_type_marks )? ( RETURN $return_type)? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:9: LBRACKET ( signature_type_marks )? ( RETURN return_type= name )? RBRACKET
			{
			DebugLocation(1550, 9);
			LBRACKET729=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_signature14555); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET729);

			DebugLocation(1550, 18);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:18: ( signature_type_marks )?
			int alt219=2;
			try { DebugEnterSubRule(219);
			try { DebugEnterDecision(219, false);
			int LA219_0 = input.LA(1);

			if ((LA219_0==BASIC_IDENTIFIER||LA219_0==EXTENDED_IDENTIFIER||LA219_0==STRING_LITERAL))
			{
				alt219 = 1;
			}
			} finally { DebugExitDecision(219); }
			switch (alt219)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:18: signature_type_marks
				{
				DebugLocation(1550, 18);
				PushFollow(Follow._signature_type_marks_in_signature14557);
				signature_type_marks730=signature_type_marks();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_signature_type_marks.Add(signature_type_marks730.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(219); }

			DebugLocation(1550, 40);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:40: ( RETURN return_type= name )?
			int alt220=2;
			try { DebugEnterSubRule(220);
			try { DebugEnterDecision(220, false);
			int LA220_0 = input.LA(1);

			if ((LA220_0==RETURN))
			{
				alt220 = 1;
			}
			} finally { DebugExitDecision(220); }
			switch (alt220)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1550:42: RETURN return_type= name
				{
				DebugLocation(1550, 42);
				RETURN731=(IToken)Match(input,RETURN,Follow._RETURN_in_signature14562); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RETURN.Add(RETURN731);

				DebugLocation(1550, 60);
				PushFollow(Follow._name_in_signature14566);
				return_type=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(return_type.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(220); }

			DebugLocation(1550, 69);
			RBRACKET732=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_signature14571); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET732);



			{
			// AST REWRITE
			// elements: return_type, RETURN, signature_type_marks
			// token labels: 
			// rule labels: retval, return_type
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_return_type=new RewriteRuleSubtreeStream(adaptor,"rule return_type",return_type!=null?return_type.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1551:9: -> ^( SIGNATURE ( signature_type_marks )? ( RETURN $return_type)? )
			{
				DebugLocation(1551, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1551:12: ^( SIGNATURE ( signature_type_marks )? ( RETURN $return_type)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1551, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SIGNATURE, "SIGNATURE"), root_1);

				DebugLocation(1551, 25);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1551:25: ( signature_type_marks )?
				if (stream_signature_type_marks.HasNext)
				{
					DebugLocation(1551, 25);
					adaptor.AddChild(root_1, stream_signature_type_marks.NextTree());

				}
				stream_signature_type_marks.Reset();
				DebugLocation(1551, 47);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1551:47: ( RETURN $return_type)?
				if (stream_return_type.HasNext||stream_RETURN.HasNext)
				{
					DebugLocation(1551, 49);
					adaptor.AddChild(root_1, stream_RETURN.NextNode());
					DebugLocation(1551, 57);
					adaptor.AddChild(root_1, stream_return_type.NextTree());

				}
				stream_return_type.Reset();
				stream_RETURN.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signature", 191);
			LeaveRule("signature", 191);
			LeaveRule_signature();
			if (state.backtracking > 0) { Memoize(input, 191, signature_StartIndex); }

		}
		DebugLocation(1552, 4);
		} finally { DebugExitRule(GrammarFileName, "signature"); }
		return retval;

	}
	// $ANTLR end "signature"

	partial void EnterRule_signature_type_marks();
	partial void LeaveRule_signature_type_marks();

	// $ANTLR start "signature_type_marks"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1554:1: signature_type_marks : name ( COMMA name )* -> ( name )+ ;
	[GrammarRule("signature_type_marks")]
	private AstParserRuleReturnScope<CommonTree, IToken> signature_type_marks()
	{
		EnterRule_signature_type_marks();
		EnterRule("signature_type_marks", 192);
		TraceIn("signature_type_marks", 192);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int signature_type_marks_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA734 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> name733 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> name735 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA734_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "signature_type_marks");
		DebugLocation(1554, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 192)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1555:5: ( name ( COMMA name )* -> ( name )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1555:9: name ( COMMA name )*
			{
			DebugLocation(1555, 9);
			PushFollow(Follow._name_in_signature_type_marks14619);
			name733=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name733.Tree);
			DebugLocation(1555, 14);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1555:14: ( COMMA name )*
			try { DebugEnterSubRule(221);
			while (true)
			{
				int alt221=2;
				try { DebugEnterDecision(221, false);
				int LA221_0 = input.LA(1);

				if ((LA221_0==COMMA))
				{
					alt221 = 1;
				}


				} finally { DebugExitDecision(221); }
				switch ( alt221 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1555:16: COMMA name
					{
					DebugLocation(1555, 16);
					COMMA734=(IToken)Match(input,COMMA,Follow._COMMA_in_signature_type_marks14623); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA734);

					DebugLocation(1555, 22);
					PushFollow(Follow._name_in_signature_type_marks14625);
					name735=name();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name.Add(name735.Tree);

					}
					break;

				default:
					goto loop221;
				}
			}

			loop221:
				;

			} finally { DebugExitSubRule(221); }



			{
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1556:9: -> ( name )+
			{
				DebugLocation(1556, 12);
				if (!(stream_name.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_name.HasNext )
				{
					DebugLocation(1556, 12);
					adaptor.AddChild(root_0, stream_name.NextTree());

				}
				stream_name.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("signature_type_marks", 192);
			LeaveRule("signature_type_marks", 192);
			LeaveRule_signature_type_marks();
			if (state.backtracking > 0) { Memoize(input, 192, signature_type_marks_StartIndex); }

		}
		DebugLocation(1557, 4);
		} finally { DebugExitRule(GrammarFileName, "signature_type_marks"); }
		return retval;

	}
	// $ANTLR end "signature_type_marks"

	partial void EnterRule_simple_expression();
	partial void LeaveRule_simple_expression();

	// $ANTLR start "simple_expression"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1559:1: simple_expression : simple_expression2 -> ^( EXPRESSION simple_expression2 ) ;
	[GrammarRule("simple_expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> simple_expression()
	{
		EnterRule_simple_expression();
		EnterRule("simple_expression", 193);
		TraceIn("simple_expression", 193);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int simple_expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> simple_expression2736 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_simple_expression2=new RewriteRuleSubtreeStream(adaptor,"rule simple_expression2");
		try { DebugEnterRule(GrammarFileName, "simple_expression");
		DebugLocation(1559, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 193)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1560:5: ( simple_expression2 -> ^( EXPRESSION simple_expression2 ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1560:9: simple_expression2
			{
			DebugLocation(1560, 9);
			PushFollow(Follow._simple_expression2_in_simple_expression14660);
			simple_expression2736=simple_expression2();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_simple_expression2.Add(simple_expression2736.Tree);


			{
			// AST REWRITE
			// elements: simple_expression2
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1561:9: -> ^( EXPRESSION simple_expression2 )
			{
				DebugLocation(1561, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1561:12: ^( EXPRESSION simple_expression2 )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1561, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(1561, 26);
				adaptor.AddChild(root_1, stream_simple_expression2.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_expression", 193);
			LeaveRule("simple_expression", 193);
			LeaveRule_simple_expression();
			if (state.backtracking > 0) { Memoize(input, 193, simple_expression_StartIndex); }

		}
		DebugLocation(1562, 4);
		} finally { DebugExitRule(GrammarFileName, "simple_expression"); }
		return retval;

	}
	// $ANTLR end "simple_expression"

	partial void EnterRule_simple_expression2();
	partial void LeaveRule_simple_expression2();

	// $ANTLR start "simple_expression2"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1564:1: simple_expression2 : ( sign )? term ( adding_operator ^ term )* ;
	[GrammarRule("simple_expression2")]
	private AstParserRuleReturnScope<CommonTree, IToken> simple_expression2()
	{
		EnterRule_simple_expression2();
		EnterRule("simple_expression2", 194);
		TraceIn("simple_expression2", 194);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int simple_expression2_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> sign737 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> term738 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> adding_operator739 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> term740 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "simple_expression2");
		DebugLocation(1564, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 194)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:5: ( ( sign )? term ( adding_operator ^ term )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:9: ( sign )? term ( adding_operator ^ term )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1565, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:9: ( sign )?
			int alt222=2;
			try { DebugEnterSubRule(222);
			try { DebugEnterDecision(222, false);
			int LA222_0 = input.LA(1);

			if ((LA222_0==MINUS||LA222_0==PLUS))
			{
				alt222 = 1;
			}
			} finally { DebugExitDecision(222); }
			switch (alt222)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:9: sign
				{
				DebugLocation(1565, 9);
				PushFollow(Follow._sign_in_simple_expression214697);
				sign737=sign();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, sign737.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(222); }

			DebugLocation(1565, 15);
			PushFollow(Follow._term_in_simple_expression214700);
			term738=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term738.Tree);
			DebugLocation(1565, 20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:20: ( adding_operator ^ term )*
			try { DebugEnterSubRule(223);
			while (true)
			{
				int alt223=2;
				try { DebugEnterDecision(223, false);
				int LA223_0 = input.LA(1);

				if ((LA223_0==AMPERSAND||LA223_0==MINUS||LA223_0==PLUS))
				{
					alt223 = 1;
				}


				} finally { DebugExitDecision(223); }
				switch ( alt223 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1565:22: adding_operator ^ term
					{
					DebugLocation(1565, 37);
					PushFollow(Follow._adding_operator_in_simple_expression214704);
					adding_operator739=adding_operator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(adding_operator739.Tree, root_0);
					DebugLocation(1565, 39);
					PushFollow(Follow._term_in_simple_expression214707);
					term740=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term740.Tree);

					}
					break;

				default:
					goto loop223;
				}
			}

			loop223:
				;

			} finally { DebugExitSubRule(223); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_expression2", 194);
			LeaveRule("simple_expression2", 194);
			LeaveRule_simple_expression2();
			if (state.backtracking > 0) { Memoize(input, 194, simple_expression2_StartIndex); }

		}
		DebugLocation(1566, 4);
		} finally { DebugExitRule(GrammarFileName, "simple_expression2"); }
		return retval;

	}
	// $ANTLR end "simple_expression2"

	partial void EnterRule_subprogram_declaration();
	partial void LeaveRule_subprogram_declaration();

	// $ANTLR start "subprogram_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1579:1: subprogram_declaration : subprogram_specification SEMI -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) ;
	[GrammarRule("subprogram_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_declaration()
	{
		EnterRule_subprogram_declaration();
		EnterRule("subprogram_declaration", 195);
		TraceIn("subprogram_declaration", 195);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI742 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_specification741 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI742_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_subprogram_specification=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_specification");
		try { DebugEnterRule(GrammarFileName, "subprogram_declaration");
		DebugLocation(1579, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 195)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1580:5: ( subprogram_specification SEMI -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1580:9: subprogram_specification SEMI
			{
			DebugLocation(1580, 9);
			PushFollow(Follow._subprogram_specification_in_subprogram_declaration14740);
			subprogram_specification741=subprogram_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subprogram_specification.Add(subprogram_specification741.Tree);
			DebugLocation(1580, 34);
			SEMI742=(IToken)Match(input,SEMI,Follow._SEMI_in_subprogram_declaration14742); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI742);



			{
			// AST REWRITE
			// elements: subprogram_specification
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1581:9: -> ^( SUBPROGRAM_DECLARATION subprogram_specification )
			{
				DebugLocation(1581, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1581:12: ^( SUBPROGRAM_DECLARATION subprogram_specification )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1581, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SUBPROGRAM_DECLARATION, "SUBPROGRAM_DECLARATION"), root_1);

				DebugLocation(1581, 38);
				adaptor.AddChild(root_1, stream_subprogram_specification.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_declaration", 195);
			LeaveRule("subprogram_declaration", 195);
			LeaveRule_subprogram_declaration();
			if (state.backtracking > 0) { Memoize(input, 195, subprogram_declaration_StartIndex); }

		}
		DebugLocation(1582, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_declaration"); }
		return retval;

	}
	// $ANTLR end "subprogram_declaration"

	partial void EnterRule_subprogram_body_part();
	partial void LeaveRule_subprogram_body_part();

	// $ANTLR start "subprogram_body_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1584:1: subprogram_body_part : IS ( subprogram_declarative_part )? BEGIN ( subprogram_statement_part )? END ( subprogram_kind )? ( designator )? -> ( subprogram_declarative_part )? ( subprogram_statement_part )? ;
	[GrammarRule("subprogram_body_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_part()
	{
		EnterRule_subprogram_body_part();
		EnterRule("subprogram_body_part", 196);
		TraceIn("subprogram_body_part", 196);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_body_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken IS743 = default(IToken);
		IToken BEGIN745 = default(IToken);
		IToken END747 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_declarative_part744 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_statement_part746 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_kind748 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> designator749 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IS743_tree = default(CommonTree);
		CommonTree BEGIN745_tree = default(CommonTree);
		CommonTree END747_tree = default(CommonTree);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_subprogram_kind=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_kind");
		RewriteRuleSubtreeStream stream_subprogram_statement_part=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_statement_part");
		RewriteRuleSubtreeStream stream_designator=new RewriteRuleSubtreeStream(adaptor,"rule designator");
		RewriteRuleSubtreeStream stream_subprogram_declarative_part=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_declarative_part");
		try { DebugEnterRule(GrammarFileName, "subprogram_body_part");
		DebugLocation(1584, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 196)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1585:5: ( IS ( subprogram_declarative_part )? BEGIN ( subprogram_statement_part )? END ( subprogram_kind )? ( designator )? -> ( subprogram_declarative_part )? ( subprogram_statement_part )? )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1585:9: IS ( subprogram_declarative_part )? BEGIN ( subprogram_statement_part )? END ( subprogram_kind )? ( designator )?
			{
			DebugLocation(1585, 9);
			IS743=(IToken)Match(input,IS,Follow._IS_in_subprogram_body_part14779); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS743);

			DebugLocation(1586, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1586:9: ( subprogram_declarative_part )?
			int alt224=2;
			try { DebugEnterSubRule(224);
			try { DebugEnterDecision(224, false);
			int LA224_0 = input.LA(1);

			if ((LA224_0==ALIAS||LA224_0==ATTRIBUTE||LA224_0==CONSTANT||LA224_0==FILE||LA224_0==FUNCTION||LA224_0==GROUP||LA224_0==IMPURE||LA224_0==PROCEDURE||LA224_0==PURE||LA224_0==SHARED||LA224_0==SUBTYPE||LA224_0==TYPE||LA224_0==USE||LA224_0==VARIABLE))
			{
				alt224 = 1;
			}
			} finally { DebugExitDecision(224); }
			switch (alt224)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1586:9: subprogram_declarative_part
				{
				DebugLocation(1586, 9);
				PushFollow(Follow._subprogram_declarative_part_in_subprogram_body_part14789);
				subprogram_declarative_part744=subprogram_declarative_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subprogram_declarative_part.Add(subprogram_declarative_part744.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(224); }

			DebugLocation(1587, 9);
			BEGIN745=(IToken)Match(input,BEGIN,Follow._BEGIN_in_subprogram_body_part14800); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BEGIN.Add(BEGIN745);

			DebugLocation(1588, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1588:9: ( subprogram_statement_part )?
			int alt225=2;
			try { DebugEnterSubRule(225);
			try { DebugEnterDecision(225, false);
			int LA225_0 = input.LA(1);

			if ((LA225_0==ASSERT||LA225_0==BASIC_IDENTIFIER||LA225_0==CASE||LA225_0==EXIT||LA225_0==EXTENDED_IDENTIFIER||LA225_0==FOR||LA225_0==IF||LA225_0==LOOP||LA225_0==LPAREN||LA225_0==NEXT||LA225_0==NULLTOK||LA225_0==REPORT||LA225_0==RETURN||LA225_0==STRING_LITERAL||LA225_0==WAIT||LA225_0==WHILE))
			{
				alt225 = 1;
			}
			} finally { DebugExitDecision(225); }
			switch (alt225)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1588:9: subprogram_statement_part
				{
				DebugLocation(1588, 9);
				PushFollow(Follow._subprogram_statement_part_in_subprogram_body_part14810);
				subprogram_statement_part746=subprogram_statement_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subprogram_statement_part.Add(subprogram_statement_part746.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(225); }

			DebugLocation(1589, 9);
			END747=(IToken)Match(input,END,Follow._END_in_subprogram_body_part14821); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END747);

			DebugLocation(1589, 13);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1589:13: ( subprogram_kind )?
			int alt226=2;
			try { DebugEnterSubRule(226);
			try { DebugEnterDecision(226, false);
			int LA226_0 = input.LA(1);

			if ((LA226_0==FUNCTION||LA226_0==PROCEDURE))
			{
				alt226 = 1;
			}
			} finally { DebugExitDecision(226); }
			switch (alt226)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1589:13: subprogram_kind
				{
				DebugLocation(1589, 13);
				PushFollow(Follow._subprogram_kind_in_subprogram_body_part14823);
				subprogram_kind748=subprogram_kind();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subprogram_kind.Add(subprogram_kind748.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(226); }

			DebugLocation(1589, 30);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1589:30: ( designator )?
			int alt227=2;
			try { DebugEnterSubRule(227);
			try { DebugEnterDecision(227, false);
			int LA227_0 = input.LA(1);

			if ((LA227_0==BASIC_IDENTIFIER||LA227_0==EXTENDED_IDENTIFIER||LA227_0==STRING_LITERAL))
			{
				alt227 = 1;
			}
			} finally { DebugExitDecision(227); }
			switch (alt227)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1589:30: designator
				{
				DebugLocation(1589, 30);
				PushFollow(Follow._designator_in_subprogram_body_part14826);
				designator749=designator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_designator.Add(designator749.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(227); }



			{
			// AST REWRITE
			// elements: subprogram_statement_part, subprogram_declarative_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1590:9: -> ( subprogram_declarative_part )? ( subprogram_statement_part )?
			{
				DebugLocation(1590, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1590:12: ( subprogram_declarative_part )?
				if (stream_subprogram_declarative_part.HasNext)
				{
					DebugLocation(1590, 12);
					adaptor.AddChild(root_0, stream_subprogram_declarative_part.NextTree());

				}
				stream_subprogram_declarative_part.Reset();
				DebugLocation(1590, 41);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1590:41: ( subprogram_statement_part )?
				if (stream_subprogram_statement_part.HasNext)
				{
					DebugLocation(1590, 41);
					adaptor.AddChild(root_0, stream_subprogram_statement_part.NextTree());

				}
				stream_subprogram_statement_part.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_body_part", 196);
			LeaveRule("subprogram_body_part", 196);
			LeaveRule_subprogram_body_part();
			if (state.backtracking > 0) { Memoize(input, 196, subprogram_body_part_StartIndex); }

		}
		DebugLocation(1591, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_body_part"); }
		return retval;

	}
	// $ANTLR end "subprogram_body_part"

	partial void EnterRule_subprogram_body_or_declaration();
	partial void LeaveRule_subprogram_body_or_declaration();

	// $ANTLR start "subprogram_body_or_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1593:1: subprogram_body_or_declaration : subprogram_specification ( subprogram_body_part -> ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? ) | -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) ) SEMI ;
	[GrammarRule("subprogram_body_or_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration()
	{
		EnterRule_subprogram_body_or_declaration();
		EnterRule("subprogram_body_or_declaration", 197);
		TraceIn("subprogram_body_or_declaration", 197);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_body_or_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SEMI752 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_specification750 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_part751 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SEMI752_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_subprogram_body_part=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_body_part");
		RewriteRuleSubtreeStream stream_subprogram_specification=new RewriteRuleSubtreeStream(adaptor,"rule subprogram_specification");
		try { DebugEnterRule(GrammarFileName, "subprogram_body_or_declaration");
		DebugLocation(1593, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 197)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1594:5: ( subprogram_specification ( subprogram_body_part -> ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? ) | -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) ) SEMI )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1594:9: subprogram_specification ( subprogram_body_part -> ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? ) | -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) ) SEMI
			{
			DebugLocation(1594, 9);
			PushFollow(Follow._subprogram_specification_in_subprogram_body_or_declaration14862);
			subprogram_specification750=subprogram_specification();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subprogram_specification.Add(subprogram_specification750.Tree);
			DebugLocation(1595, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1595:9: ( subprogram_body_part -> ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? ) | -> ^( SUBPROGRAM_DECLARATION subprogram_specification ) )
			int alt228=2;
			try { DebugEnterSubRule(228);
			try { DebugEnterDecision(228, false);
			int LA228_0 = input.LA(1);

			if ((LA228_0==IS))
			{
				alt228 = 1;
			}
			else if ((LA228_0==SEMI))
			{
				alt228 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 228, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(228); }
			switch (alt228)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1596:17: subprogram_body_part
				{
				DebugLocation(1596, 17);
				PushFollow(Follow._subprogram_body_part_in_subprogram_body_or_declaration14890);
				subprogram_body_part751=subprogram_body_part();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_subprogram_body_part.Add(subprogram_body_part751.Tree);


				{
				// AST REWRITE
				// elements: subprogram_specification, subprogram_body_part
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1597:17: -> ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? )
				{
					DebugLocation(1597, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1597:20: ^( SUBPROGRAM_BODY subprogram_specification ( subprogram_body_part )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1597, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SUBPROGRAM_BODY, "SUBPROGRAM_BODY"), root_1);

					DebugLocation(1597, 39);
					adaptor.AddChild(root_1, stream_subprogram_specification.NextTree());
					DebugLocation(1597, 64);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1597:64: ( subprogram_body_part )?
					if (stream_subprogram_body_part.HasNext)
					{
						DebugLocation(1597, 64);
						adaptor.AddChild(root_1, stream_subprogram_body_part.NextTree());

					}
					stream_subprogram_body_part.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1599:17: 
				{

				{
				// AST REWRITE
				// elements: subprogram_specification
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1599:17: -> ^( SUBPROGRAM_DECLARATION subprogram_specification )
				{
					DebugLocation(1599, 20);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1599:20: ^( SUBPROGRAM_DECLARATION subprogram_specification )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1599, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SUBPROGRAM_DECLARATION, "SUBPROGRAM_DECLARATION"), root_1);

					DebugLocation(1599, 46);
					adaptor.AddChild(root_1, stream_subprogram_specification.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(228); }

			DebugLocation(1601, 9);
			SEMI752=(IToken)Match(input,SEMI,Follow._SEMI_in_subprogram_body_or_declaration14979); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI752);


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_body_or_declaration", 197);
			LeaveRule("subprogram_body_or_declaration", 197);
			LeaveRule_subprogram_body_or_declaration();
			if (state.backtracking > 0) { Memoize(input, 197, subprogram_body_or_declaration_StartIndex); }

		}
		DebugLocation(1602, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_body_or_declaration"); }
		return retval;

	}
	// $ANTLR end "subprogram_body_or_declaration"

	partial void EnterRule_subprogram_declarative_item();
	partial void LeaveRule_subprogram_declarative_item();

	// $ANTLR start "subprogram_declarative_item"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1604:1: subprogram_declarative_item : ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | use_clause | group_template_declaration | group_declaration );
	[GrammarRule("subprogram_declarative_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_declarative_item()
	{
		EnterRule_subprogram_declarative_item();
		EnterRule("subprogram_declarative_item", 198);
		TraceIn("subprogram_declarative_item", 198);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_declarative_item_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> subprogram_body_or_declaration753 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> type_declaration754 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration755 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant_declaration756 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variable_declaration757 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_declaration758 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> alias_declaration759 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_declaration760 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> attribute_specification761 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> use_clause762 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_template_declaration763 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> group_declaration764 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "subprogram_declarative_item");
		DebugLocation(1604, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 198)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1605:5: ( subprogram_body_or_declaration | type_declaration | subtype_declaration | constant_declaration | variable_declaration | file_declaration | alias_declaration | attribute_declaration | attribute_specification | use_clause | group_template_declaration | group_declaration )
			int alt229=12;
			try { DebugEnterDecision(229, false);
			switch (input.LA(1))
			{
			case FUNCTION:
			case IMPURE:
			case PROCEDURE:
			case PURE:
				{
				alt229 = 1;
				}
				break;
			case TYPE:
				{
				alt229 = 2;
				}
				break;
			case SUBTYPE:
				{
				alt229 = 3;
				}
				break;
			case CONSTANT:
				{
				alt229 = 4;
				}
				break;
			case SHARED:
			case VARIABLE:
				{
				alt229 = 5;
				}
				break;
			case FILE:
				{
				alt229 = 6;
				}
				break;
			case ALIAS:
				{
				alt229 = 7;
				}
				break;
			case ATTRIBUTE:
				{
				int LA229_8 = input.LA(2);

				if ((LA229_8==BASIC_IDENTIFIER||LA229_8==EXTENDED_IDENTIFIER))
				{
					int LA229_11 = input.LA(3);

					if ((LA229_11==COLON))
					{
						alt229 = 8;
					}
					else if ((LA229_11==OF))
					{
						alt229 = 9;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 229, 11, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA229_8==RANGETOK))
				{
					alt229 = 9;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 229, 8, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case USE:
				{
				alt229 = 10;
				}
				break;
			case GROUP:
				{
				int LA229_10 = input.LA(2);

				if ((LA229_10==BASIC_IDENTIFIER||LA229_10==EXTENDED_IDENTIFIER))
				{
					int LA229_13 = input.LA(3);

					if ((LA229_13==IS))
					{
						alt229 = 11;
					}
					else if ((LA229_13==COLON))
					{
						alt229 = 12;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 229, 13, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 229, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 229, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(229); }
			switch (alt229)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1605:9: subprogram_body_or_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1605, 9);
				PushFollow(Follow._subprogram_body_or_declaration_in_subprogram_declarative_item14998);
				subprogram_body_or_declaration753=subprogram_body_or_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_body_or_declaration753.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1606:9: type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1606, 9);
				PushFollow(Follow._type_declaration_in_subprogram_declarative_item15008);
				type_declaration754=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration754.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1607:9: subtype_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1607, 9);
				PushFollow(Follow._subtype_declaration_in_subprogram_declarative_item15018);
				subtype_declaration755=subtype_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, subtype_declaration755.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1608:9: constant_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1608, 9);
				PushFollow(Follow._constant_declaration_in_subprogram_declarative_item15028);
				constant_declaration756=constant_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_declaration756.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1609:9: variable_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1609, 9);
				PushFollow(Follow._variable_declaration_in_subprogram_declarative_item15038);
				variable_declaration757=variable_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variable_declaration757.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1610:9: file_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1610, 9);
				PushFollow(Follow._file_declaration_in_subprogram_declarative_item15048);
				file_declaration758=file_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_declaration758.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1611:9: alias_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1611, 9);
				PushFollow(Follow._alias_declaration_in_subprogram_declarative_item15058);
				alias_declaration759=alias_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, alias_declaration759.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1612:9: attribute_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1612, 9);
				PushFollow(Follow._attribute_declaration_in_subprogram_declarative_item15068);
				attribute_declaration760=attribute_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_declaration760.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1613:9: attribute_specification
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1613, 9);
				PushFollow(Follow._attribute_specification_in_subprogram_declarative_item15078);
				attribute_specification761=attribute_specification();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, attribute_specification761.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1614:9: use_clause
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1614, 9);
				PushFollow(Follow._use_clause_in_subprogram_declarative_item15088);
				use_clause762=use_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, use_clause762.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1615:9: group_template_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1615, 9);
				PushFollow(Follow._group_template_declaration_in_subprogram_declarative_item15098);
				group_template_declaration763=group_template_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_template_declaration763.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1616:9: group_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1616, 9);
				PushFollow(Follow._group_declaration_in_subprogram_declarative_item15108);
				group_declaration764=group_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, group_declaration764.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_declarative_item", 198);
			LeaveRule("subprogram_declarative_item", 198);
			LeaveRule_subprogram_declarative_item();
			if (state.backtracking > 0) { Memoize(input, 198, subprogram_declarative_item_StartIndex); }

		}
		DebugLocation(1617, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_declarative_item"); }
		return retval;

	}
	// $ANTLR end "subprogram_declarative_item"

	partial void EnterRule_subprogram_declarative_part();
	partial void LeaveRule_subprogram_declarative_part();

	// $ANTLR start "subprogram_declarative_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1619:1: subprogram_declarative_part : ( subprogram_declarative_item )+ ;
	[GrammarRule("subprogram_declarative_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_declarative_part()
	{
		EnterRule_subprogram_declarative_part();
		EnterRule("subprogram_declarative_part", 199);
		TraceIn("subprogram_declarative_part", 199);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_declarative_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> subprogram_declarative_item765 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "subprogram_declarative_part");
		DebugLocation(1619, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 199)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1620:5: ( ( subprogram_declarative_item )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1620:9: ( subprogram_declarative_item )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1620, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1620:9: ( subprogram_declarative_item )+
			int cnt230=0;
			try { DebugEnterSubRule(230);
			while (true)
			{
				int alt230=2;
				try { DebugEnterDecision(230, false);
				int LA230_0 = input.LA(1);

				if ((LA230_0==ALIAS||LA230_0==ATTRIBUTE||LA230_0==CONSTANT||LA230_0==FILE||LA230_0==FUNCTION||LA230_0==GROUP||LA230_0==IMPURE||LA230_0==PROCEDURE||LA230_0==PURE||LA230_0==SHARED||LA230_0==SUBTYPE||LA230_0==TYPE||LA230_0==USE||LA230_0==VARIABLE))
				{
					alt230 = 1;
				}


				} finally { DebugExitDecision(230); }
				switch (alt230)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1620:9: subprogram_declarative_item
					{
					DebugLocation(1620, 9);
					PushFollow(Follow._subprogram_declarative_item_in_subprogram_declarative_part15127);
					subprogram_declarative_item765=subprogram_declarative_item();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, subprogram_declarative_item765.Tree);

					}
					break;

				default:
					if (cnt230 >= 1)
						goto loop230;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee230 = new EarlyExitException( 230, input );
					DebugRecognitionException(eee230);
					throw eee230;
				}
				cnt230++;
			}
			loop230:
				;

			} finally { DebugExitSubRule(230); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_declarative_part", 199);
			LeaveRule("subprogram_declarative_part", 199);
			LeaveRule_subprogram_declarative_part();
			if (state.backtracking > 0) { Memoize(input, 199, subprogram_declarative_part_StartIndex); }

		}
		DebugLocation(1621, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_declarative_part"); }
		return retval;

	}
	// $ANTLR end "subprogram_declarative_part"

	partial void EnterRule_subprogram_kind();
	partial void LeaveRule_subprogram_kind();

	// $ANTLR start "subprogram_kind"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1623:1: subprogram_kind : ( PROCEDURE | FUNCTION );
	[GrammarRule("subprogram_kind")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_kind()
	{
		EnterRule_subprogram_kind();
		EnterRule("subprogram_kind", 200);
		TraceIn("subprogram_kind", 200);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_kind_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set766 = default(IToken);

		CommonTree set766_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "subprogram_kind");
		DebugLocation(1623, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 200)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1624:5: ( PROCEDURE | FUNCTION )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1624, 5);

			set766=(IToken)input.LT(1);
			if (input.LA(1)==FUNCTION||input.LA(1)==PROCEDURE)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set766));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_kind", 200);
			LeaveRule("subprogram_kind", 200);
			LeaveRule_subprogram_kind();
			if (state.backtracking > 0) { Memoize(input, 200, subprogram_kind_StartIndex); }

		}
		DebugLocation(1626, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_kind"); }
		return retval;

	}
	// $ANTLR end "subprogram_kind"

	partial void EnterRule_subprogram_specification();
	partial void LeaveRule_subprogram_specification();

	// $ANTLR start "subprogram_specification"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1628:1: subprogram_specification : ( PROCEDURE designator ( LPAREN parameter_interface_list_procedure RPAREN )? -> ^( PROCEDURE designator ( parameter_interface_list_procedure )? ) | ( PURE | IMPURE )? FUNCTION designator ( LPAREN parameter_interface_list_function RPAREN )? RETURN type_mark= name -> ^( FUNCTION ( PURE )? ( IMPURE )? designator $type_mark ( parameter_interface_list_function )? ) );
	[GrammarRule("subprogram_specification")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_specification()
	{
		EnterRule_subprogram_specification();
		EnterRule("subprogram_specification", 201);
		TraceIn("subprogram_specification", 201);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_specification_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken PROCEDURE767 = default(IToken);
		IToken LPAREN769 = default(IToken);
		IToken RPAREN771 = default(IToken);
		IToken PURE772 = default(IToken);
		IToken IMPURE773 = default(IToken);
		IToken FUNCTION774 = default(IToken);
		IToken LPAREN776 = default(IToken);
		IToken RPAREN778 = default(IToken);
		IToken RETURN779 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_mark = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> designator768 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameter_interface_list_procedure770 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> designator775 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameter_interface_list_function777 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PROCEDURE767_tree = default(CommonTree);
		CommonTree LPAREN769_tree = default(CommonTree);
		CommonTree RPAREN771_tree = default(CommonTree);
		CommonTree PURE772_tree = default(CommonTree);
		CommonTree IMPURE773_tree = default(CommonTree);
		CommonTree FUNCTION774_tree = default(CommonTree);
		CommonTree LPAREN776_tree = default(CommonTree);
		CommonTree RPAREN778_tree = default(CommonTree);
		CommonTree RETURN779_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_PURE=new RewriteRuleITokenStream(adaptor,"token PURE");
		RewriteRuleITokenStream stream_IMPURE=new RewriteRuleITokenStream(adaptor,"token IMPURE");
		RewriteRuleITokenStream stream_PROCEDURE=new RewriteRuleITokenStream(adaptor,"token PROCEDURE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_parameter_interface_list_function=new RewriteRuleSubtreeStream(adaptor,"rule parameter_interface_list_function");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_parameter_interface_list_procedure=new RewriteRuleSubtreeStream(adaptor,"rule parameter_interface_list_procedure");
		RewriteRuleSubtreeStream stream_designator=new RewriteRuleSubtreeStream(adaptor,"rule designator");
		try { DebugEnterRule(GrammarFileName, "subprogram_specification");
		DebugLocation(1628, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 201)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1629:5: ( PROCEDURE designator ( LPAREN parameter_interface_list_procedure RPAREN )? -> ^( PROCEDURE designator ( parameter_interface_list_procedure )? ) | ( PURE | IMPURE )? FUNCTION designator ( LPAREN parameter_interface_list_function RPAREN )? RETURN type_mark= name -> ^( FUNCTION ( PURE )? ( IMPURE )? designator $type_mark ( parameter_interface_list_function )? ) )
			int alt234=2;
			try { DebugEnterDecision(234, false);
			int LA234_0 = input.LA(1);

			if ((LA234_0==PROCEDURE))
			{
				alt234 = 1;
			}
			else if ((LA234_0==FUNCTION||LA234_0==IMPURE||LA234_0==PURE))
			{
				alt234 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 234, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(234); }
			switch (alt234)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1629:9: PROCEDURE designator ( LPAREN parameter_interface_list_procedure RPAREN )?
				{
				DebugLocation(1629, 9);
				PROCEDURE767=(IToken)Match(input,PROCEDURE,Follow._PROCEDURE_in_subprogram_specification15176); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PROCEDURE.Add(PROCEDURE767);

				DebugLocation(1629, 19);
				PushFollow(Follow._designator_in_subprogram_specification15178);
				designator768=designator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_designator.Add(designator768.Tree);
				DebugLocation(1629, 30);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1629:30: ( LPAREN parameter_interface_list_procedure RPAREN )?
				int alt231=2;
				try { DebugEnterSubRule(231);
				try { DebugEnterDecision(231, false);
				int LA231_0 = input.LA(1);

				if ((LA231_0==LPAREN))
				{
					alt231 = 1;
				}
				} finally { DebugExitDecision(231); }
				switch (alt231)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1629:32: LPAREN parameter_interface_list_procedure RPAREN
					{
					DebugLocation(1629, 32);
					LPAREN769=(IToken)Match(input,LPAREN,Follow._LPAREN_in_subprogram_specification15182); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LPAREN.Add(LPAREN769);

					DebugLocation(1629, 39);
					PushFollow(Follow._parameter_interface_list_procedure_in_subprogram_specification15184);
					parameter_interface_list_procedure770=parameter_interface_list_procedure();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_parameter_interface_list_procedure.Add(parameter_interface_list_procedure770.Tree);
					DebugLocation(1629, 74);
					RPAREN771=(IToken)Match(input,RPAREN,Follow._RPAREN_in_subprogram_specification15186); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RPAREN.Add(RPAREN771);


					}
					break;

				}
				} finally { DebugExitSubRule(231); }



				{
				// AST REWRITE
				// elements: parameter_interface_list_procedure, PROCEDURE, designator
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1630:9: -> ^( PROCEDURE designator ( parameter_interface_list_procedure )? )
				{
					DebugLocation(1630, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1630:12: ^( PROCEDURE designator ( parameter_interface_list_procedure )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1630, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_PROCEDURE.NextNode(), root_1);

					DebugLocation(1630, 25);
					adaptor.AddChild(root_1, stream_designator.NextTree());
					DebugLocation(1630, 36);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1630:36: ( parameter_interface_list_procedure )?
					if (stream_parameter_interface_list_procedure.HasNext)
					{
						DebugLocation(1630, 36);
						adaptor.AddChild(root_1, stream_parameter_interface_list_procedure.NextTree());

					}
					stream_parameter_interface_list_procedure.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1631:9: ( PURE | IMPURE )? FUNCTION designator ( LPAREN parameter_interface_list_function RPAREN )? RETURN type_mark= name
				{
				DebugLocation(1631, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1631:9: ( PURE | IMPURE )?
				int alt232=3;
				try { DebugEnterSubRule(232);
				try { DebugEnterDecision(232, false);
				int LA232_0 = input.LA(1);

				if ((LA232_0==PURE))
				{
					alt232 = 1;
				}
				else if ((LA232_0==IMPURE))
				{
					alt232 = 2;
				}
				} finally { DebugExitDecision(232); }
				switch (alt232)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1631:11: PURE
					{
					DebugLocation(1631, 11);
					PURE772=(IToken)Match(input,PURE,Follow._PURE_in_subprogram_specification15222); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_PURE.Add(PURE772);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1631:18: IMPURE
					{
					DebugLocation(1631, 18);
					IMPURE773=(IToken)Match(input,IMPURE,Follow._IMPURE_in_subprogram_specification15226); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_IMPURE.Add(IMPURE773);


					}
					break;

				}
				} finally { DebugExitSubRule(232); }

				DebugLocation(1631, 28);
				FUNCTION774=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_subprogram_specification15231); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION774);

				DebugLocation(1631, 37);
				PushFollow(Follow._designator_in_subprogram_specification15233);
				designator775=designator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_designator.Add(designator775.Tree);
				DebugLocation(1632, 9);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1632:9: ( LPAREN parameter_interface_list_function RPAREN )?
				int alt233=2;
				try { DebugEnterSubRule(233);
				try { DebugEnterDecision(233, false);
				int LA233_0 = input.LA(1);

				if ((LA233_0==LPAREN))
				{
					alt233 = 1;
				}
				} finally { DebugExitDecision(233); }
				switch (alt233)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1632:11: LPAREN parameter_interface_list_function RPAREN
					{
					DebugLocation(1632, 11);
					LPAREN776=(IToken)Match(input,LPAREN,Follow._LPAREN_in_subprogram_specification15245); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LPAREN.Add(LPAREN776);

					DebugLocation(1632, 18);
					PushFollow(Follow._parameter_interface_list_function_in_subprogram_specification15247);
					parameter_interface_list_function777=parameter_interface_list_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_parameter_interface_list_function.Add(parameter_interface_list_function777.Tree);
					DebugLocation(1632, 52);
					RPAREN778=(IToken)Match(input,RPAREN,Follow._RPAREN_in_subprogram_specification15249); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RPAREN.Add(RPAREN778);


					}
					break;

				}
				} finally { DebugExitSubRule(233); }

				DebugLocation(1632, 62);
				RETURN779=(IToken)Match(input,RETURN,Follow._RETURN_in_subprogram_specification15254); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RETURN.Add(RETURN779);

				DebugLocation(1632, 78);
				PushFollow(Follow._name_in_subprogram_specification15258);
				type_mark=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(type_mark.Tree);


				{
				// AST REWRITE
				// elements: FUNCTION, parameter_interface_list_function, type_mark, IMPURE, PURE, designator
				// token labels: 
				// rule labels: retval, type_mark
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_type_mark=new RewriteRuleSubtreeStream(adaptor,"rule type_mark",type_mark!=null?type_mark.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1633:9: -> ^( FUNCTION ( PURE )? ( IMPURE )? designator $type_mark ( parameter_interface_list_function )? )
				{
					DebugLocation(1633, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1633:12: ^( FUNCTION ( PURE )? ( IMPURE )? designator $type_mark ( parameter_interface_list_function )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1633, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

					DebugLocation(1633, 24);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1633:24: ( PURE )?
					if (stream_PURE.HasNext)
					{
						DebugLocation(1633, 24);
						adaptor.AddChild(root_1, stream_PURE.NextNode());

					}
					stream_PURE.Reset();
					DebugLocation(1633, 30);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1633:30: ( IMPURE )?
					if (stream_IMPURE.HasNext)
					{
						DebugLocation(1633, 30);
						adaptor.AddChild(root_1, stream_IMPURE.NextNode());

					}
					stream_IMPURE.Reset();
					DebugLocation(1633, 38);
					adaptor.AddChild(root_1, stream_designator.NextTree());
					DebugLocation(1633, 50);
					adaptor.AddChild(root_1, stream_type_mark.NextTree());
					DebugLocation(1633, 60);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1633:60: ( parameter_interface_list_function )?
					if (stream_parameter_interface_list_function.HasNext)
					{
						DebugLocation(1633, 60);
						adaptor.AddChild(root_1, stream_parameter_interface_list_function.NextTree());

					}
					stream_parameter_interface_list_function.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_specification", 201);
			LeaveRule("subprogram_specification", 201);
			LeaveRule_subprogram_specification();
			if (state.backtracking > 0) { Memoize(input, 201, subprogram_specification_StartIndex); }

		}
		DebugLocation(1634, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_specification"); }
		return retval;

	}
	// $ANTLR end "subprogram_specification"

	partial void EnterRule_subprogram_statement_part();
	partial void LeaveRule_subprogram_statement_part();

	// $ANTLR start "subprogram_statement_part"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1636:1: subprogram_statement_part : ( sequential_statement )+ ;
	[GrammarRule("subprogram_statement_part")]
	private AstParserRuleReturnScope<CommonTree, IToken> subprogram_statement_part()
	{
		EnterRule_subprogram_statement_part();
		EnterRule("subprogram_statement_part", 202);
		TraceIn("subprogram_statement_part", 202);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subprogram_statement_part_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> sequential_statement780 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "subprogram_statement_part");
		DebugLocation(1636, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 202)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1637:5: ( ( sequential_statement )+ )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1637:9: ( sequential_statement )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1637, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1637:9: ( sequential_statement )+
			int cnt235=0;
			try { DebugEnterSubRule(235);
			while (true)
			{
				int alt235=2;
				try { DebugEnterDecision(235, false);
				int LA235_0 = input.LA(1);

				if ((LA235_0==ASSERT||LA235_0==BASIC_IDENTIFIER||LA235_0==CASE||LA235_0==EXIT||LA235_0==EXTENDED_IDENTIFIER||LA235_0==FOR||LA235_0==IF||LA235_0==LOOP||LA235_0==LPAREN||LA235_0==NEXT||LA235_0==NULLTOK||LA235_0==REPORT||LA235_0==RETURN||LA235_0==STRING_LITERAL||LA235_0==WAIT||LA235_0==WHILE))
				{
					alt235 = 1;
				}


				} finally { DebugExitDecision(235); }
				switch (alt235)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1637:9: sequential_statement
					{
					DebugLocation(1637, 9);
					PushFollow(Follow._sequential_statement_in_subprogram_statement_part15307);
					sequential_statement780=sequential_statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, sequential_statement780.Tree);

					}
					break;

				default:
					if (cnt235 >= 1)
						goto loop235;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee235 = new EarlyExitException( 235, input );
					DebugRecognitionException(eee235);
					throw eee235;
				}
				cnt235++;
			}
			loop235:
				;

			} finally { DebugExitSubRule(235); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subprogram_statement_part", 202);
			LeaveRule("subprogram_statement_part", 202);
			LeaveRule_subprogram_statement_part();
			if (state.backtracking > 0) { Memoize(input, 202, subprogram_statement_part_StartIndex); }

		}
		DebugLocation(1638, 4);
		} finally { DebugExitRule(GrammarFileName, "subprogram_statement_part"); }
		return retval;

	}
	// $ANTLR end "subprogram_statement_part"

	partial void EnterRule_subtype_declaration();
	partial void LeaveRule_subtype_declaration();

	// $ANTLR start "subtype_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1640:1: subtype_declaration : SUBTYPE identifier IS subtype_indication SEMI -> ^( SUBTYPE identifier subtype_indication ) ;
	[GrammarRule("subtype_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> subtype_declaration()
	{
		EnterRule_subtype_declaration();
		EnterRule("subtype_declaration", 203);
		TraceIn("subtype_declaration", 203);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subtype_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SUBTYPE781 = default(IToken);
		IToken IS783 = default(IToken);
		IToken SEMI785 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier782 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication784 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SUBTYPE781_tree = default(CommonTree);
		CommonTree IS783_tree = default(CommonTree);
		CommonTree SEMI785_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SUBTYPE=new RewriteRuleITokenStream(adaptor,"token SUBTYPE");
		RewriteRuleITokenStream stream_IS=new RewriteRuleITokenStream(adaptor,"token IS");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "subtype_declaration");
		DebugLocation(1640, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 203)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1641:5: ( SUBTYPE identifier IS subtype_indication SEMI -> ^( SUBTYPE identifier subtype_indication ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1641:9: SUBTYPE identifier IS subtype_indication SEMI
			{
			DebugLocation(1641, 9);
			SUBTYPE781=(IToken)Match(input,SUBTYPE,Follow._SUBTYPE_in_subtype_declaration15327); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SUBTYPE.Add(SUBTYPE781);

			DebugLocation(1641, 17);
			PushFollow(Follow._identifier_in_subtype_declaration15329);
			identifier782=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier782.Tree);
			DebugLocation(1641, 28);
			IS783=(IToken)Match(input,IS,Follow._IS_in_subtype_declaration15331); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IS.Add(IS783);

			DebugLocation(1641, 31);
			PushFollow(Follow._subtype_indication_in_subtype_declaration15333);
			subtype_indication784=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication784.Tree);
			DebugLocation(1641, 50);
			SEMI785=(IToken)Match(input,SEMI,Follow._SEMI_in_subtype_declaration15335); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI785);



			{
			// AST REWRITE
			// elements: identifier, SUBTYPE, subtype_indication
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1642:9: -> ^( SUBTYPE identifier subtype_indication )
			{
				DebugLocation(1642, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1642:12: ^( SUBTYPE identifier subtype_indication )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1642, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_SUBTYPE.NextNode(), root_1);

				DebugLocation(1642, 23);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(1642, 34);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subtype_declaration", 203);
			LeaveRule("subtype_declaration", 203);
			LeaveRule_subtype_declaration();
			if (state.backtracking > 0) { Memoize(input, 203, subtype_declaration_StartIndex); }

		}
		DebugLocation(1643, 4);
		} finally { DebugExitRule(GrammarFileName, "subtype_declaration"); }
		return retval;

	}
	// $ANTLR end "subtype_declaration"

	partial void EnterRule_subtype_indication();
	partial void LeaveRule_subtype_indication();

	// $ANTLR start "subtype_indication"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1649:1: subtype_indication : n1= name_without_parens (n2= name_without_parens )? ( constraint )? -> ^( SUBTYPE_INDICATION ( $n2)? $n1 ( constraint )? ) ;
	[GrammarRule("subtype_indication")]
	private AstParserRuleReturnScope<CommonTree, IToken> subtype_indication()
	{
		EnterRule_subtype_indication();
		EnterRule("subtype_indication", 204);
		TraceIn("subtype_indication", 204);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int subtype_indication_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> n1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> n2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constraint786 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_name_without_parens=new RewriteRuleSubtreeStream(adaptor,"rule name_without_parens");
		RewriteRuleSubtreeStream stream_constraint=new RewriteRuleSubtreeStream(adaptor,"rule constraint");
		try { DebugEnterRule(GrammarFileName, "subtype_indication");
		DebugLocation(1649, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 204)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:5: (n1= name_without_parens (n2= name_without_parens )? ( constraint )? -> ^( SUBTYPE_INDICATION ( $n2)? $n1 ( constraint )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:9: n1= name_without_parens (n2= name_without_parens )? ( constraint )?
			{
			DebugLocation(1650, 11);
			PushFollow(Follow._name_without_parens_in_subtype_indication15380);
			n1=name_without_parens();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name_without_parens.Add(n1.Tree);
			DebugLocation(1650, 34);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:34: (n2= name_without_parens )?
			int alt236=2;
			try { DebugEnterSubRule(236);
			try { DebugEnterDecision(236, false);
			int LA236_0 = input.LA(1);

			if ((LA236_0==BASIC_IDENTIFIER||LA236_0==EXTENDED_IDENTIFIER||LA236_0==STRING_LITERAL))
			{
				alt236 = 1;
			}
			} finally { DebugExitDecision(236); }
			switch (alt236)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:34: n2= name_without_parens
				{
				DebugLocation(1650, 34);
				PushFollow(Follow._name_without_parens_in_subtype_indication15384);
				n2=name_without_parens();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name_without_parens.Add(n2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(236); }

			DebugLocation(1650, 56);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:56: ( constraint )?
			int alt237=2;
			try { DebugEnterSubRule(237);
			try { DebugEnterDecision(237, false);
			int LA237_0 = input.LA(1);

			if ((LA237_0==LPAREN||LA237_0==RANGETOK))
			{
				alt237 = 1;
			}
			} finally { DebugExitDecision(237); }
			switch (alt237)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1650:56: constraint
				{
				DebugLocation(1650, 56);
				PushFollow(Follow._constraint_in_subtype_indication15387);
				constraint786=constraint();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constraint.Add(constraint786.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(237); }



			{
			// AST REWRITE
			// elements: n1, constraint, n2
			// token labels: 
			// rule labels: n1, retval, n2
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_n1=new RewriteRuleSubtreeStream(adaptor,"rule n1",n1!=null?n1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_n2=new RewriteRuleSubtreeStream(adaptor,"rule n2",n2!=null?n2.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1651:9: -> ^( SUBTYPE_INDICATION ( $n2)? $n1 ( constraint )? )
			{
				DebugLocation(1651, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1651:12: ^( SUBTYPE_INDICATION ( $n2)? $n1 ( constraint )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1651, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SUBTYPE_INDICATION, "SUBTYPE_INDICATION"), root_1);

				DebugLocation(1651, 35);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1651:35: ( $n2)?
				if (stream_n2.HasNext)
				{
					DebugLocation(1651, 35);
					adaptor.AddChild(root_1, stream_n2.NextTree());

				}
				stream_n2.Reset();
				DebugLocation(1651, 40);
				adaptor.AddChild(root_1, stream_n1.NextTree());
				DebugLocation(1651, 43);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1651:43: ( constraint )?
				if (stream_constraint.HasNext)
				{
					DebugLocation(1651, 43);
					adaptor.AddChild(root_1, stream_constraint.NextTree());

				}
				stream_constraint.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subtype_indication", 204);
			LeaveRule("subtype_indication", 204);
			LeaveRule_subtype_indication();
			if (state.backtracking > 0) { Memoize(input, 204, subtype_indication_StartIndex); }

		}
		DebugLocation(1652, 4);
		} finally { DebugExitRule(GrammarFileName, "subtype_indication"); }
		return retval;

	}
	// $ANTLR end "subtype_indication"

	partial void EnterRule_suffix();
	partial void LeaveRule_suffix();

	// $ANTLR start "suffix"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1654:1: suffix : (simple_name= identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL | ALL );
	[GrammarRule("suffix")]
	private AstParserRuleReturnScope<CommonTree, IToken> suffix()
	{
		EnterRule_suffix();
		EnterRule("suffix", 205);
		TraceIn("suffix", 205);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int suffix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken operator_symbol = default(IToken);
		IToken CHARACTER_LITERAL787 = default(IToken);
		IToken ALL788 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> simple_name = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree operator_symbol_tree = default(CommonTree);
		CommonTree CHARACTER_LITERAL787_tree = default(CommonTree);
		CommonTree ALL788_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "suffix");
		DebugLocation(1654, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 205)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1655:5: (simple_name= identifier | CHARACTER_LITERAL |operator_symbol= STRING_LITERAL | ALL )
			int alt238=4;
			try { DebugEnterDecision(238, false);
			switch (input.LA(1))
			{
			case BASIC_IDENTIFIER:
			case EXTENDED_IDENTIFIER:
				{
				alt238 = 1;
				}
				break;
			case CHARACTER_LITERAL:
				{
				alt238 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt238 = 3;
				}
				break;
			case ALL:
				{
				alt238 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 238, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(238); }
			switch (alt238)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1655:9: simple_name= identifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1655, 20);
				PushFollow(Follow._identifier_in_suffix15435);
				simple_name=identifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple_name.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1656:9: CHARACTER_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1656, 9);
				CHARACTER_LITERAL787=(IToken)Match(input,CHARACTER_LITERAL,Follow._CHARACTER_LITERAL_in_suffix15445); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHARACTER_LITERAL787_tree = (CommonTree)adaptor.Create(CHARACTER_LITERAL787);
				adaptor.AddChild(root_0, CHARACTER_LITERAL787_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1657:9: operator_symbol= STRING_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1657, 24);
				operator_symbol=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_suffix15457); if (state.failed) return retval;
				if (state.backtracking == 0) {
				operator_symbol_tree = (CommonTree)adaptor.Create(operator_symbol);
				adaptor.AddChild(root_0, operator_symbol_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1658:9: ALL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1658, 9);
				ALL788=(IToken)Match(input,ALL,Follow._ALL_in_suffix15467); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ALL788_tree = (CommonTree)adaptor.Create(ALL788);
				adaptor.AddChild(root_0, ALL788_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("suffix", 205);
			LeaveRule("suffix", 205);
			LeaveRule_suffix();
			if (state.backtracking > 0) { Memoize(input, 205, suffix_StartIndex); }

		}
		DebugLocation(1659, 4);
		} finally { DebugExitRule(GrammarFileName, "suffix"); }
		return retval;

	}
	// $ANTLR end "suffix"

	partial void EnterRule_target();
	partial void LeaveRule_target();

	// $ANTLR start "target"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1661:1: target : ( name | aggregate );
	[GrammarRule("target")]
	private AstParserRuleReturnScope<CommonTree, IToken> target()
	{
		EnterRule_target();
		EnterRule("target", 206);
		TraceIn("target", 206);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int target_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> name789 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> aggregate790 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "target");
		DebugLocation(1661, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 206)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1662:5: ( name | aggregate )
			int alt239=2;
			try { DebugEnterDecision(239, false);
			int LA239_0 = input.LA(1);

			if ((LA239_0==BASIC_IDENTIFIER||LA239_0==EXTENDED_IDENTIFIER||LA239_0==STRING_LITERAL))
			{
				alt239 = 1;
			}
			else if ((LA239_0==LPAREN))
			{
				alt239 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 239, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(239); }
			switch (alt239)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1662:9: name
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1662, 9);
				PushFollow(Follow._name_in_target15486);
				name789=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, name789.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1663:9: aggregate
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1663, 9);
				PushFollow(Follow._aggregate_in_target15496);
				aggregate790=aggregate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, aggregate790.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("target", 206);
			LeaveRule("target", 206);
			LeaveRule_target();
			if (state.backtracking > 0) { Memoize(input, 206, target_StartIndex); }

		}
		DebugLocation(1664, 4);
		} finally { DebugExitRule(GrammarFileName, "target"); }
		return retval;

	}
	// $ANTLR end "target"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1666:1: term : factor ( multiplying_operator ^ factor )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 207);
		TraceIn("term", 207);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int term_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> factor791 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiplying_operator792 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> factor793 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(1666, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 207)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1667:5: ( factor ( multiplying_operator ^ factor )* )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1667:9: factor ( multiplying_operator ^ factor )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1667, 9);
			PushFollow(Follow._factor_in_term15515);
			factor791=factor();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, factor791.Tree);
			DebugLocation(1667, 16);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1667:16: ( multiplying_operator ^ factor )*
			try { DebugEnterSubRule(240);
			while (true)
			{
				int alt240=2;
				try { DebugEnterDecision(240, false);
				int LA240_0 = input.LA(1);

				if ((LA240_0==DIV||(LA240_0>=MOD && LA240_0<=MUL)||LA240_0==REM))
				{
					alt240 = 1;
				}


				} finally { DebugExitDecision(240); }
				switch ( alt240 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1667:18: multiplying_operator ^ factor
					{
					DebugLocation(1667, 38);
					PushFollow(Follow._multiplying_operator_in_term15519);
					multiplying_operator792=multiplying_operator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (CommonTree)adaptor.BecomeRoot(multiplying_operator792.Tree, root_0);
					DebugLocation(1667, 40);
					PushFollow(Follow._factor_in_term15522);
					factor793=factor();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, factor793.Tree);

					}
					break;

				default:
					goto loop240;
				}
			}

			loop240:
				;

			} finally { DebugExitSubRule(240); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 207);
			LeaveRule("term", 207);
			LeaveRule_term();
			if (state.backtracking > 0) { Memoize(input, 207, term_StartIndex); }

		}
		DebugLocation(1668, 4);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_timeout_clause();
	partial void LeaveRule_timeout_clause();

	// $ANTLR start "timeout_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1670:1: timeout_clause : FOR time= expression -> ^( FOR $time) ;
	[GrammarRule("timeout_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> timeout_clause()
	{
		EnterRule_timeout_clause();
		EnterRule("timeout_clause", 208);
		TraceIn("timeout_clause", 208);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int timeout_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken FOR794 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> time = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR794_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "timeout_clause");
		DebugLocation(1670, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 208)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1671:5: ( FOR time= expression -> ^( FOR $time) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1671:9: FOR time= expression
			{
			DebugLocation(1671, 9);
			FOR794=(IToken)Match(input,FOR,Follow._FOR_in_timeout_clause15544); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR794);

			DebugLocation(1671, 17);
			PushFollow(Follow._expression_in_timeout_clause15548);
			time=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(time.Tree);


			{
			// AST REWRITE
			// elements: FOR, time
			// token labels: 
			// rule labels: retval, time
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_time=new RewriteRuleSubtreeStream(adaptor,"rule time",time!=null?time.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1672:9: -> ^( FOR $time)
			{
				DebugLocation(1672, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1672:12: ^( FOR $time)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1672, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

				DebugLocation(1672, 20);
				adaptor.AddChild(root_1, stream_time.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("timeout_clause", 208);
			LeaveRule("timeout_clause", 208);
			LeaveRule_timeout_clause();
			if (state.backtracking > 0) { Memoize(input, 208, timeout_clause_StartIndex); }

		}
		DebugLocation(1673, 4);
		} finally { DebugExitRule(GrammarFileName, "timeout_clause"); }
		return retval;

	}
	// $ANTLR end "timeout_clause"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1675:1: type_declaration : ( full_type_declaration | incomplete_type_declaration );
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 209);
		TraceIn("type_declaration", 209);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int type_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> full_type_declaration795 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> incomplete_type_declaration796 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(1675, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 209)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1676:5: ( full_type_declaration | incomplete_type_declaration )
			int alt241=2;
			try { DebugEnterDecision(241, false);
			int LA241_0 = input.LA(1);

			if ((LA241_0==TYPE))
			{
				int LA241_1 = input.LA(2);

				if ((LA241_1==BASIC_IDENTIFIER||LA241_1==EXTENDED_IDENTIFIER))
				{
					int LA241_2 = input.LA(3);

					if ((LA241_2==IS))
					{
						alt241 = 1;
					}
					else if ((LA241_2==SEMI))
					{
						alt241 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 241, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 241, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 241, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(241); }
			switch (alt241)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1676:9: full_type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1676, 9);
				PushFollow(Follow._full_type_declaration_in_type_declaration15585);
				full_type_declaration795=full_type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, full_type_declaration795.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1677:9: incomplete_type_declaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1677, 9);
				PushFollow(Follow._incomplete_type_declaration_in_type_declaration15595);
				incomplete_type_declaration796=incomplete_type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, incomplete_type_declaration796.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 209);
			LeaveRule("type_declaration", 209);
			LeaveRule_type_declaration();
			if (state.backtracking > 0) { Memoize(input, 209, type_declaration_StartIndex); }

		}
		DebugLocation(1678, 4);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_type_definition();
	partial void LeaveRule_type_definition();

	// $ANTLR start "type_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1680:1: type_definition : ( scalar_type_definition | composite_type_definition | access_type_definition | file_type_definition );
	[GrammarRule("type_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> type_definition()
	{
		EnterRule_type_definition();
		EnterRule("type_definition", 210);
		TraceIn("type_definition", 210);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int type_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> scalar_type_definition797 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> composite_type_definition798 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> access_type_definition799 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> file_type_definition800 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "type_definition");
		DebugLocation(1680, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 210)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1681:5: ( scalar_type_definition | composite_type_definition | access_type_definition | file_type_definition )
			int alt242=4;
			try { DebugEnterDecision(242, false);
			switch (input.LA(1))
			{
			case LPAREN:
			case RANGETOK:
				{
				alt242 = 1;
				}
				break;
			case ARRAY:
			case RECORD:
				{
				alt242 = 2;
				}
				break;
			case ACCESS:
				{
				alt242 = 3;
				}
				break;
			case FILE:
				{
				alt242 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 242, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(242); }
			switch (alt242)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1681:9: scalar_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1681, 9);
				PushFollow(Follow._scalar_type_definition_in_type_definition15614);
				scalar_type_definition797=scalar_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, scalar_type_definition797.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1682:9: composite_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1682, 9);
				PushFollow(Follow._composite_type_definition_in_type_definition15624);
				composite_type_definition798=composite_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, composite_type_definition798.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1683:9: access_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1683, 9);
				PushFollow(Follow._access_type_definition_in_type_definition15634);
				access_type_definition799=access_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, access_type_definition799.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1684:9: file_type_definition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1684, 9);
				PushFollow(Follow._file_type_definition_in_type_definition15644);
				file_type_definition800=file_type_definition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, file_type_definition800.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_definition", 210);
			LeaveRule("type_definition", 210);
			LeaveRule_type_definition();
			if (state.backtracking > 0) { Memoize(input, 210, type_definition_StartIndex); }

		}
		DebugLocation(1685, 4);
		} finally { DebugExitRule(GrammarFileName, "type_definition"); }
		return retval;

	}
	// $ANTLR end "type_definition"

	partial void EnterRule_unconstrained_array_definition();
	partial void LeaveRule_unconstrained_array_definition();

	// $ANTLR start "unconstrained_array_definition"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1687:1: unconstrained_array_definition : LPAREN index_subtype_definition ( COMMA index_subtype_definition )* RPAREN OF element_subtype_indication= subtype_indication -> ^( UNCONSTRAINED_ARRAY_DEFINITION ( index_subtype_definition )+ $element_subtype_indication) ;
	[GrammarRule("unconstrained_array_definition")]
	private AstParserRuleReturnScope<CommonTree, IToken> unconstrained_array_definition()
	{
		EnterRule_unconstrained_array_definition();
		EnterRule("unconstrained_array_definition", 211);
		TraceIn("unconstrained_array_definition", 211);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int unconstrained_array_definition_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN801 = default(IToken);
		IToken COMMA803 = default(IToken);
		IToken RPAREN805 = default(IToken);
		IToken OF806 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> element_subtype_indication = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> index_subtype_definition802 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> index_subtype_definition804 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN801_tree = default(CommonTree);
		CommonTree COMMA803_tree = default(CommonTree);
		CommonTree RPAREN805_tree = default(CommonTree);
		CommonTree OF806_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_index_subtype_definition=new RewriteRuleSubtreeStream(adaptor,"rule index_subtype_definition");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		try { DebugEnterRule(GrammarFileName, "unconstrained_array_definition");
		DebugLocation(1687, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 211)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1688:5: ( LPAREN index_subtype_definition ( COMMA index_subtype_definition )* RPAREN OF element_subtype_indication= subtype_indication -> ^( UNCONSTRAINED_ARRAY_DEFINITION ( index_subtype_definition )+ $element_subtype_indication) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1688:9: LPAREN index_subtype_definition ( COMMA index_subtype_definition )* RPAREN OF element_subtype_indication= subtype_indication
			{
			DebugLocation(1688, 9);
			LPAREN801=(IToken)Match(input,LPAREN,Follow._LPAREN_in_unconstrained_array_definition15663); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN801);

			DebugLocation(1688, 16);
			PushFollow(Follow._index_subtype_definition_in_unconstrained_array_definition15665);
			index_subtype_definition802=index_subtype_definition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index_subtype_definition.Add(index_subtype_definition802.Tree);
			DebugLocation(1688, 41);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1688:41: ( COMMA index_subtype_definition )*
			try { DebugEnterSubRule(243);
			while (true)
			{
				int alt243=2;
				try { DebugEnterDecision(243, false);
				int LA243_0 = input.LA(1);

				if ((LA243_0==COMMA))
				{
					alt243 = 1;
				}


				} finally { DebugExitDecision(243); }
				switch ( alt243 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1688:43: COMMA index_subtype_definition
					{
					DebugLocation(1688, 43);
					COMMA803=(IToken)Match(input,COMMA,Follow._COMMA_in_unconstrained_array_definition15669); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA803);

					DebugLocation(1688, 49);
					PushFollow(Follow._index_subtype_definition_in_unconstrained_array_definition15671);
					index_subtype_definition804=index_subtype_definition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_index_subtype_definition.Add(index_subtype_definition804.Tree);

					}
					break;

				default:
					goto loop243;
				}
			}

			loop243:
				;

			} finally { DebugExitSubRule(243); }

			DebugLocation(1688, 77);
			RPAREN805=(IToken)Match(input,RPAREN,Follow._RPAREN_in_unconstrained_array_definition15676); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN805);

			DebugLocation(1689, 9);
			OF806=(IToken)Match(input,OF,Follow._OF_in_unconstrained_array_definition15686); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OF.Add(OF806);

			DebugLocation(1689, 38);
			PushFollow(Follow._subtype_indication_in_unconstrained_array_definition15690);
			element_subtype_indication=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(element_subtype_indication.Tree);


			{
			// AST REWRITE
			// elements: index_subtype_definition, element_subtype_indication
			// token labels: 
			// rule labels: retval, element_subtype_indication
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_element_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule element_subtype_indication",element_subtype_indication!=null?element_subtype_indication.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1690:9: -> ^( UNCONSTRAINED_ARRAY_DEFINITION ( index_subtype_definition )+ $element_subtype_indication)
			{
				DebugLocation(1690, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1690:12: ^( UNCONSTRAINED_ARRAY_DEFINITION ( index_subtype_definition )+ $element_subtype_indication)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1690, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(UNCONSTRAINED_ARRAY_DEFINITION, "UNCONSTRAINED_ARRAY_DEFINITION"), root_1);

				DebugLocation(1690, 46);
				if (!(stream_index_subtype_definition.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_index_subtype_definition.HasNext )
				{
					DebugLocation(1690, 46);
					adaptor.AddChild(root_1, stream_index_subtype_definition.NextTree());

				}
				stream_index_subtype_definition.Reset();
				DebugLocation(1690, 73);
				adaptor.AddChild(root_1, stream_element_subtype_indication.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unconstrained_array_definition", 211);
			LeaveRule("unconstrained_array_definition", 211);
			LeaveRule_unconstrained_array_definition();
			if (state.backtracking > 0) { Memoize(input, 211, unconstrained_array_definition_StartIndex); }

		}
		DebugLocation(1691, 4);
		} finally { DebugExitRule(GrammarFileName, "unconstrained_array_definition"); }
		return retval;

	}
	// $ANTLR end "unconstrained_array_definition"

	partial void EnterRule_use_clause();
	partial void LeaveRule_use_clause();

	// $ANTLR start "use_clause"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1693:1: use_clause : USE selected_name1= name ( COMMA selected_name2= name )* SEMI -> ^( USE ( name )+ ) ;
	[GrammarRule("use_clause")]
	private AstParserRuleReturnScope<CommonTree, IToken> use_clause()
	{
		EnterRule_use_clause();
		EnterRule("use_clause", 212);
		TraceIn("use_clause", 212);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int use_clause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken USE807 = default(IToken);
		IToken COMMA808 = default(IToken);
		IToken SEMI809 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> selected_name1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> selected_name2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree USE807_tree = default(CommonTree);
		CommonTree COMMA808_tree = default(CommonTree);
		CommonTree SEMI809_tree = default(CommonTree);
		RewriteRuleITokenStream stream_USE=new RewriteRuleITokenStream(adaptor,"token USE");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "use_clause");
		DebugLocation(1693, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 212)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1694:5: ( USE selected_name1= name ( COMMA selected_name2= name )* SEMI -> ^( USE ( name )+ ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1694:9: USE selected_name1= name ( COMMA selected_name2= name )* SEMI
			{
			DebugLocation(1694, 9);
			USE807=(IToken)Match(input,USE,Follow._USE_in_use_clause15731); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_USE.Add(USE807);

			DebugLocation(1694, 27);
			PushFollow(Follow._name_in_use_clause15735);
			selected_name1=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(selected_name1.Tree);
			DebugLocation(1694, 33);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1694:33: ( COMMA selected_name2= name )*
			try { DebugEnterSubRule(244);
			while (true)
			{
				int alt244=2;
				try { DebugEnterDecision(244, false);
				int LA244_0 = input.LA(1);

				if ((LA244_0==COMMA))
				{
					alt244 = 1;
				}


				} finally { DebugExitDecision(244); }
				switch ( alt244 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1694:35: COMMA selected_name2= name
					{
					DebugLocation(1694, 35);
					COMMA808=(IToken)Match(input,COMMA,Follow._COMMA_in_use_clause15739); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA808);

					DebugLocation(1694, 55);
					PushFollow(Follow._name_in_use_clause15743);
					selected_name2=name();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_name.Add(selected_name2.Tree);

					}
					break;

				default:
					goto loop244;
				}
			}

			loop244:
				;

			} finally { DebugExitSubRule(244); }

			DebugLocation(1694, 64);
			SEMI809=(IToken)Match(input,SEMI,Follow._SEMI_in_use_clause15748); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI809);



			{
			// AST REWRITE
			// elements: name, USE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1695:9: -> ^( USE ( name )+ )
			{
				DebugLocation(1695, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1695:12: ^( USE ( name )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1695, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_USE.NextNode(), root_1);

				DebugLocation(1695, 19);
				if (!(stream_name.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_name.HasNext )
				{
					DebugLocation(1695, 19);
					adaptor.AddChild(root_1, stream_name.NextTree());

				}
				stream_name.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("use_clause", 212);
			LeaveRule("use_clause", 212);
			LeaveRule_use_clause();
			if (state.backtracking > 0) { Memoize(input, 212, use_clause_StartIndex); }

		}
		DebugLocation(1696, 4);
		} finally { DebugExitRule(GrammarFileName, "use_clause"); }
		return retval;

	}
	// $ANTLR end "use_clause"

	partial void EnterRule_variable_assignment_statement();
	partial void LeaveRule_variable_assignment_statement();

	// $ANTLR start "variable_assignment_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1698:1: variable_assignment_statement : target VARASGN expression SEMI -> ^( VARIABLE_ASSIGNMENT_STATEMENT target expression ) ;
	[GrammarRule("variable_assignment_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> variable_assignment_statement()
	{
		EnterRule_variable_assignment_statement();
		EnterRule("variable_assignment_statement", 213);
		TraceIn("variable_assignment_statement", 213);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variable_assignment_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken VARASGN811 = default(IToken);
		IToken SEMI813 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> target810 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression812 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree VARASGN811_tree = default(CommonTree);
		CommonTree SEMI813_tree = default(CommonTree);
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_target=new RewriteRuleSubtreeStream(adaptor,"rule target");
		try { DebugEnterRule(GrammarFileName, "variable_assignment_statement");
		DebugLocation(1698, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 213)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1699:5: ( target VARASGN expression SEMI -> ^( VARIABLE_ASSIGNMENT_STATEMENT target expression ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1699:9: target VARASGN expression SEMI
			{
			DebugLocation(1699, 9);
			PushFollow(Follow._target_in_variable_assignment_statement15786);
			target810=target();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_target.Add(target810.Tree);
			DebugLocation(1699, 16);
			VARASGN811=(IToken)Match(input,VARASGN,Follow._VARASGN_in_variable_assignment_statement15788); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VARASGN.Add(VARASGN811);

			DebugLocation(1699, 24);
			PushFollow(Follow._expression_in_variable_assignment_statement15790);
			expression812=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression812.Tree);
			DebugLocation(1699, 35);
			SEMI813=(IToken)Match(input,SEMI,Follow._SEMI_in_variable_assignment_statement15792); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI813);



			{
			// AST REWRITE
			// elements: expression, target
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1700:9: -> ^( VARIABLE_ASSIGNMENT_STATEMENT target expression )
			{
				DebugLocation(1700, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1700:12: ^( VARIABLE_ASSIGNMENT_STATEMENT target expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1700, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARIABLE_ASSIGNMENT_STATEMENT, "VARIABLE_ASSIGNMENT_STATEMENT"), root_1);

				DebugLocation(1700, 45);
				adaptor.AddChild(root_1, stream_target.NextTree());
				DebugLocation(1700, 52);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_assignment_statement", 213);
			LeaveRule("variable_assignment_statement", 213);
			LeaveRule_variable_assignment_statement();
			if (state.backtracking > 0) { Memoize(input, 213, variable_assignment_statement_StartIndex); }

		}
		DebugLocation(1701, 4);
		} finally { DebugExitRule(GrammarFileName, "variable_assignment_statement"); }
		return retval;

	}
	// $ANTLR end "variable_assignment_statement"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1703:1: variable_declaration : ( SHARED )? VARIABLE identifier_list COLON subtype_indication ( VARASGN expression )? SEMI -> ^( VARIABLE ( SHARED )? identifier_list subtype_indication ( expression )? ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 214);
		TraceIn("variable_declaration", 214);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variable_declaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken SHARED814 = default(IToken);
		IToken VARIABLE815 = default(IToken);
		IToken COLON817 = default(IToken);
		IToken VARASGN819 = default(IToken);
		IToken SEMI821 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier_list816 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> subtype_indication818 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression820 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SHARED814_tree = default(CommonTree);
		CommonTree VARIABLE815_tree = default(CommonTree);
		CommonTree COLON817_tree = default(CommonTree);
		CommonTree VARASGN819_tree = default(CommonTree);
		CommonTree SEMI821_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SHARED=new RewriteRuleITokenStream(adaptor,"token SHARED");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VARASGN=new RewriteRuleITokenStream(adaptor,"token VARASGN");
		RewriteRuleITokenStream stream_VARIABLE=new RewriteRuleITokenStream(adaptor,"token VARIABLE");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_subtype_indication=new RewriteRuleSubtreeStream(adaptor,"rule subtype_indication");
		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,"rule identifier_list");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(1703, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 214)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:5: ( ( SHARED )? VARIABLE identifier_list COLON subtype_indication ( VARASGN expression )? SEMI -> ^( VARIABLE ( SHARED )? identifier_list subtype_indication ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:9: ( SHARED )? VARIABLE identifier_list COLON subtype_indication ( VARASGN expression )? SEMI
			{
			DebugLocation(1704, 9);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:9: ( SHARED )?
			int alt245=2;
			try { DebugEnterSubRule(245);
			try { DebugEnterDecision(245, false);
			int LA245_0 = input.LA(1);

			if ((LA245_0==SHARED))
			{
				alt245 = 1;
			}
			} finally { DebugExitDecision(245); }
			switch (alt245)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:9: SHARED
				{
				DebugLocation(1704, 9);
				SHARED814=(IToken)Match(input,SHARED,Follow._SHARED_in_variable_declaration15831); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SHARED.Add(SHARED814);


				}
				break;

			}
			} finally { DebugExitSubRule(245); }

			DebugLocation(1704, 17);
			VARIABLE815=(IToken)Match(input,VARIABLE,Follow._VARIABLE_in_variable_declaration15834); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VARIABLE.Add(VARIABLE815);

			DebugLocation(1704, 26);
			PushFollow(Follow._identifier_list_in_variable_declaration15836);
			identifier_list816=identifier_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier_list.Add(identifier_list816.Tree);
			DebugLocation(1704, 42);
			COLON817=(IToken)Match(input,COLON,Follow._COLON_in_variable_declaration15838); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON817);

			DebugLocation(1704, 48);
			PushFollow(Follow._subtype_indication_in_variable_declaration15840);
			subtype_indication818=subtype_indication();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_subtype_indication.Add(subtype_indication818.Tree);
			DebugLocation(1704, 67);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:67: ( VARASGN expression )?
			int alt246=2;
			try { DebugEnterSubRule(246);
			try { DebugEnterDecision(246, false);
			int LA246_0 = input.LA(1);

			if ((LA246_0==VARASGN))
			{
				alt246 = 1;
			}
			} finally { DebugExitDecision(246); }
			switch (alt246)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1704:69: VARASGN expression
				{
				DebugLocation(1704, 69);
				VARASGN819=(IToken)Match(input,VARASGN,Follow._VARASGN_in_variable_declaration15844); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARASGN.Add(VARASGN819);

				DebugLocation(1704, 77);
				PushFollow(Follow._expression_in_variable_declaration15846);
				expression820=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression820.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(246); }

			DebugLocation(1704, 91);
			SEMI821=(IToken)Match(input,SEMI,Follow._SEMI_in_variable_declaration15851); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI821);



			{
			// AST REWRITE
			// elements: subtype_indication, expression, SHARED, identifier_list, VARIABLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1705:9: -> ^( VARIABLE ( SHARED )? identifier_list subtype_indication ( expression )? )
			{
				DebugLocation(1705, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1705:12: ^( VARIABLE ( SHARED )? identifier_list subtype_indication ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1705, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_VARIABLE.NextNode(), root_1);

				DebugLocation(1705, 24);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1705:24: ( SHARED )?
				if (stream_SHARED.HasNext)
				{
					DebugLocation(1705, 24);
					adaptor.AddChild(root_1, stream_SHARED.NextNode());

				}
				stream_SHARED.Reset();
				DebugLocation(1705, 32);
				adaptor.AddChild(root_1, stream_identifier_list.NextTree());
				DebugLocation(1705, 48);
				adaptor.AddChild(root_1, stream_subtype_indication.NextTree());
				DebugLocation(1705, 67);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1705:67: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(1705, 67);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 214);
			LeaveRule("variable_declaration", 214);
			LeaveRule_variable_declaration();
			if (state.backtracking > 0) { Memoize(input, 214, variable_declaration_StartIndex); }

		}
		DebugLocation(1706, 4);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_wait_statement();
	partial void LeaveRule_wait_statement();

	// $ANTLR start "wait_statement"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1708:1: wait_statement : WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? SEMI -> ^( WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? ) ;
	[GrammarRule("wait_statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> wait_statement()
	{
		EnterRule_wait_statement();
		EnterRule("wait_statement", 215);
		TraceIn("wait_statement", 215);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int wait_statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken WAIT822 = default(IToken);
		IToken SEMI826 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sensitivity_clause823 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition_clause824 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> timeout_clause825 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WAIT822_tree = default(CommonTree);
		CommonTree SEMI826_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WAIT=new RewriteRuleITokenStream(adaptor,"token WAIT");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_sensitivity_clause=new RewriteRuleSubtreeStream(adaptor,"rule sensitivity_clause");
		RewriteRuleSubtreeStream stream_timeout_clause=new RewriteRuleSubtreeStream(adaptor,"rule timeout_clause");
		RewriteRuleSubtreeStream stream_condition_clause=new RewriteRuleSubtreeStream(adaptor,"rule condition_clause");
		try { DebugEnterRule(GrammarFileName, "wait_statement");
		DebugLocation(1708, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 215)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:5: ( WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? SEMI -> ^( WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:9: WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? SEMI
			{
			DebugLocation(1709, 9);
			WAIT822=(IToken)Match(input,WAIT,Follow._WAIT_in_wait_statement15896); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WAIT.Add(WAIT822);

			DebugLocation(1709, 14);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:14: ( sensitivity_clause )?
			int alt247=2;
			try { DebugEnterSubRule(247);
			try { DebugEnterDecision(247, false);
			int LA247_0 = input.LA(1);

			if ((LA247_0==ON))
			{
				alt247 = 1;
			}
			} finally { DebugExitDecision(247); }
			switch (alt247)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:14: sensitivity_clause
				{
				DebugLocation(1709, 14);
				PushFollow(Follow._sensitivity_clause_in_wait_statement15898);
				sensitivity_clause823=sensitivity_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_sensitivity_clause.Add(sensitivity_clause823.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(247); }

			DebugLocation(1709, 34);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:34: ( condition_clause )?
			int alt248=2;
			try { DebugEnterSubRule(248);
			try { DebugEnterDecision(248, false);
			int LA248_0 = input.LA(1);

			if ((LA248_0==UNTIL))
			{
				alt248 = 1;
			}
			} finally { DebugExitDecision(248); }
			switch (alt248)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:34: condition_clause
				{
				DebugLocation(1709, 34);
				PushFollow(Follow._condition_clause_in_wait_statement15901);
				condition_clause824=condition_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition_clause.Add(condition_clause824.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(248); }

			DebugLocation(1709, 52);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:52: ( timeout_clause )?
			int alt249=2;
			try { DebugEnterSubRule(249);
			try { DebugEnterDecision(249, false);
			int LA249_0 = input.LA(1);

			if ((LA249_0==FOR))
			{
				alt249 = 1;
			}
			} finally { DebugExitDecision(249); }
			switch (alt249)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1709:52: timeout_clause
				{
				DebugLocation(1709, 52);
				PushFollow(Follow._timeout_clause_in_wait_statement15904);
				timeout_clause825=timeout_clause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_timeout_clause.Add(timeout_clause825.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(249); }

			DebugLocation(1709, 68);
			SEMI826=(IToken)Match(input,SEMI,Follow._SEMI_in_wait_statement15907); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI826);



			{
			// AST REWRITE
			// elements: WAIT, sensitivity_clause, timeout_clause, condition_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1710:9: -> ^( WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? )
			{
				DebugLocation(1710, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1710:12: ^( WAIT ( sensitivity_clause )? ( condition_clause )? ( timeout_clause )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1710, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_WAIT.NextNode(), root_1);

				DebugLocation(1710, 20);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1710:20: ( sensitivity_clause )?
				if (stream_sensitivity_clause.HasNext)
				{
					DebugLocation(1710, 20);
					adaptor.AddChild(root_1, stream_sensitivity_clause.NextTree());

				}
				stream_sensitivity_clause.Reset();
				DebugLocation(1710, 40);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1710:40: ( condition_clause )?
				if (stream_condition_clause.HasNext)
				{
					DebugLocation(1710, 40);
					adaptor.AddChild(root_1, stream_condition_clause.NextTree());

				}
				stream_condition_clause.Reset();
				DebugLocation(1710, 58);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1710:58: ( timeout_clause )?
				if (stream_timeout_clause.HasNext)
				{
					DebugLocation(1710, 58);
					adaptor.AddChild(root_1, stream_timeout_clause.NextTree());

				}
				stream_timeout_clause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("wait_statement", 215);
			LeaveRule("wait_statement", 215);
			LeaveRule_wait_statement();
			if (state.backtracking > 0) { Memoize(input, 215, wait_statement_StartIndex); }

		}
		DebugLocation(1711, 4);
		} finally { DebugExitRule(GrammarFileName, "wait_statement"); }
		return retval;

	}
	// $ANTLR end "wait_statement"

	partial void EnterRule_waveform();
	partial void LeaveRule_waveform();

	// $ANTLR start "waveform"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1713:1: waveform : ( waveform_element ( COMMA waveform_element )* -> ^( WAVEFORM ( waveform_element )+ ) | UNAFFECTED );
	[GrammarRule("waveform")]
	private AstParserRuleReturnScope<CommonTree, IToken> waveform()
	{
		EnterRule_waveform();
		EnterRule("waveform", 216);
		TraceIn("waveform", 216);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int waveform_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken COMMA828 = default(IToken);
		IToken UNAFFECTED830 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> waveform_element827 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> waveform_element829 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA828_tree = default(CommonTree);
		CommonTree UNAFFECTED830_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_waveform_element=new RewriteRuleSubtreeStream(adaptor,"rule waveform_element");
		try { DebugEnterRule(GrammarFileName, "waveform");
		DebugLocation(1713, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 216)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1714:5: ( waveform_element ( COMMA waveform_element )* -> ^( WAVEFORM ( waveform_element )+ ) | UNAFFECTED )
			int alt251=2;
			try { DebugEnterDecision(251, false);
			int LA251_0 = input.LA(1);

			if ((LA251_0==ABS||LA251_0==BASIC_IDENTIFIER||LA251_0==BINANRY_BASED_INTEGER||(LA251_0>=BIT_STRING_LITERAL_BINARY && LA251_0<=BIT_STRING_LITERAL_OCTAL)||LA251_0==CHARACTER_LITERAL||LA251_0==DEC_BASED_INTEGER||LA251_0==EXTENDED_IDENTIFIER||LA251_0==FLOAT_POINT_LITERAL||LA251_0==HEXA_BASED_INTEGER||LA251_0==LPAREN||LA251_0==MINUS||LA251_0==NEW||(LA251_0>=NOT && LA251_0<=OCTAL_BASED_INTEGER)||LA251_0==PLUS||LA251_0==STRING_LITERAL))
			{
				alt251 = 1;
			}
			else if ((LA251_0==UNAFFECTED))
			{
				alt251 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 251, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(251); }
			switch (alt251)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1714:9: waveform_element ( COMMA waveform_element )*
				{
				DebugLocation(1714, 9);
				PushFollow(Follow._waveform_element_in_waveform15951);
				waveform_element827=waveform_element();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_waveform_element.Add(waveform_element827.Tree);
				DebugLocation(1714, 26);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1714:26: ( COMMA waveform_element )*
				try { DebugEnterSubRule(250);
				while (true)
				{
					int alt250=2;
					try { DebugEnterDecision(250, false);
					int LA250_0 = input.LA(1);

					if ((LA250_0==COMMA))
					{
						alt250 = 1;
					}


					} finally { DebugExitDecision(250); }
					switch ( alt250 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1714:28: COMMA waveform_element
						{
						DebugLocation(1714, 28);
						COMMA828=(IToken)Match(input,COMMA,Follow._COMMA_in_waveform15955); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA828);

						DebugLocation(1714, 34);
						PushFollow(Follow._waveform_element_in_waveform15957);
						waveform_element829=waveform_element();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_waveform_element.Add(waveform_element829.Tree);

						}
						break;

					default:
						goto loop250;
					}
				}

				loop250:
					;

				} finally { DebugExitSubRule(250); }



				{
				// AST REWRITE
				// elements: waveform_element
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 1715:9: -> ^( WAVEFORM ( waveform_element )+ )
				{
					DebugLocation(1715, 12);
					// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1715:12: ^( WAVEFORM ( waveform_element )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(1715, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WAVEFORM, "WAVEFORM"), root_1);

					DebugLocation(1715, 24);
					if (!(stream_waveform_element.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_waveform_element.HasNext )
					{
						DebugLocation(1715, 24);
						adaptor.AddChild(root_1, stream_waveform_element.NextTree());

					}
					stream_waveform_element.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1716:9: UNAFFECTED
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1716, 9);
				UNAFFECTED830=(IToken)Match(input,UNAFFECTED,Follow._UNAFFECTED_in_waveform15989); if (state.failed) return retval;
				if (state.backtracking == 0) {
				UNAFFECTED830_tree = (CommonTree)adaptor.Create(UNAFFECTED830);
				adaptor.AddChild(root_0, UNAFFECTED830_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("waveform", 216);
			LeaveRule("waveform", 216);
			LeaveRule_waveform();
			if (state.backtracking > 0) { Memoize(input, 216, waveform_StartIndex); }

		}
		DebugLocation(1717, 4);
		} finally { DebugExitRule(GrammarFileName, "waveform"); }
		return retval;

	}
	// $ANTLR end "waveform"

	partial void EnterRule_waveform_element();
	partial void LeaveRule_waveform_element();

	// $ANTLR start "waveform_element"
	// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1719:1: waveform_element : expression ( AFTER expression )? -> ^( WAVEFORM_ELEMENT expression ( expression )? ) ;
	[GrammarRule("waveform_element")]
	private AstParserRuleReturnScope<CommonTree, IToken> waveform_element()
	{
		EnterRule_waveform_element();
		EnterRule("waveform_element", 217);
		TraceIn("waveform_element", 217);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int waveform_element_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken AFTER832 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression831 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression833 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree AFTER832_tree = default(CommonTree);
		RewriteRuleITokenStream stream_AFTER=new RewriteRuleITokenStream(adaptor,"token AFTER");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "waveform_element");
		DebugLocation(1719, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 217)) { return retval; }

			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1720:5: ( expression ( AFTER expression )? -> ^( WAVEFORM_ELEMENT expression ( expression )? ) )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1720:9: expression ( AFTER expression )?
			{
			DebugLocation(1720, 9);
			PushFollow(Follow._expression_in_waveform_element16008);
			expression831=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression831.Tree);
			DebugLocation(1720, 20);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1720:20: ( AFTER expression )?
			int alt252=2;
			try { DebugEnterSubRule(252);
			try { DebugEnterDecision(252, false);
			int LA252_0 = input.LA(1);

			if ((LA252_0==AFTER))
			{
				alt252 = 1;
			}
			} finally { DebugExitDecision(252); }
			switch (alt252)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1720:22: AFTER expression
				{
				DebugLocation(1720, 22);
				AFTER832=(IToken)Match(input,AFTER,Follow._AFTER_in_waveform_element16012); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_AFTER.Add(AFTER832);

				DebugLocation(1720, 28);
				PushFollow(Follow._expression_in_waveform_element16014);
				expression833=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression833.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(252); }



			{
			// AST REWRITE
			// elements: expression, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1721:9: -> ^( WAVEFORM_ELEMENT expression ( expression )? )
			{
				DebugLocation(1721, 12);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1721:12: ^( WAVEFORM_ELEMENT expression ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1721, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WAVEFORM_ELEMENT, "WAVEFORM_ELEMENT"), root_1);

				DebugLocation(1721, 32);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1721, 43);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1721:43: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(1721, 43);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("waveform_element", 217);
			LeaveRule("waveform_element", 217);
			LeaveRule_waveform_element();
			if (state.backtracking > 0) { Memoize(input, 217, waveform_element_StartIndex); }

		}
		DebugLocation(1724, 4);
		} finally { DebugExitRule(GrammarFileName, "waveform_element"); }
		return retval;

	}
	// $ANTLR end "waveform_element"

	partial void EnterRule_synpred1_VhdlAntlr_fragment();
	partial void LeaveRule_synpred1_VhdlAntlr_fragment();

	// $ANTLR start synpred1_VhdlAntlr
	public void synpred1_VhdlAntlr_fragment()
	{
		EnterRule_synpred1_VhdlAntlr_fragment();
		EnterRule("synpred1_VhdlAntlr_fragment", 218);
		TraceIn("synpred1_VhdlAntlr_fragment", 218);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:326:17: ( LPAREN index_subtype_definition )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:326:18: LPAREN index_subtype_definition
			{
			DebugLocation(326, 18);
			Match(input,LPAREN,Follow._LPAREN_in_synpred1_VhdlAntlr3580); if (state.failed) return;
			DebugLocation(326, 25);
			PushFollow(Follow._index_subtype_definition_in_synpred1_VhdlAntlr3582);
			index_subtype_definition();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_VhdlAntlr_fragment", 218);
			LeaveRule("synpred1_VhdlAntlr_fragment", 218);
			LeaveRule_synpred1_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred1_VhdlAntlr

	partial void EnterRule_synpred2_VhdlAntlr_fragment();
	partial void LeaveRule_synpred2_VhdlAntlr_fragment();

	// $ANTLR start synpred2_VhdlAntlr
	public void synpred2_VhdlAntlr_fragment()
	{
		EnterRule_synpred2_VhdlAntlr_fragment();
		EnterRule("synpred2_VhdlAntlr_fragment", 219);
		TraceIn("synpred2_VhdlAntlr_fragment", 219);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:11: ( formal_part ARROW )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:342:12: formal_part ARROW
			{
			DebugLocation(342, 12);
			PushFollow(Follow._formal_part_in_synpred2_VhdlAntlr3752);
			formal_part();
			PopFollow();
			if (state.failed) return;
			DebugLocation(342, 24);
			Match(input,ARROW,Follow._ARROW_in_synpred2_VhdlAntlr3754); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_VhdlAntlr_fragment", 219);
			LeaveRule("synpred2_VhdlAntlr_fragment", 219);
			LeaveRule_synpred2_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred2_VhdlAntlr

	partial void EnterRule_synpred3_VhdlAntlr_fragment();
	partial void LeaveRule_synpred3_VhdlAntlr_fragment();

	// $ANTLR start synpred3_VhdlAntlr
	public void synpred3_VhdlAntlr_fragment()
	{
		EnterRule_synpred3_VhdlAntlr_fragment();
		EnterRule("synpred3_VhdlAntlr_fragment", 220);
		TraceIn("synpred3_VhdlAntlr_fragment", 220);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:518:21: ( concurrent_statement_optional_label )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:518:22: concurrent_statement_optional_label
			{
			DebugLocation(518, 22);
			PushFollow(Follow._concurrent_statement_optional_label_in_synpred3_VhdlAntlr5340);
			concurrent_statement_optional_label();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_VhdlAntlr_fragment", 220);
			LeaveRule("synpred3_VhdlAntlr_fragment", 220);
			LeaveRule_synpred3_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred3_VhdlAntlr

	partial void EnterRule_synpred4_VhdlAntlr_fragment();
	partial void LeaveRule_synpred4_VhdlAntlr_fragment();

	// $ANTLR start synpred4_VhdlAntlr
	public void synpred4_VhdlAntlr_fragment()
	{
		EnterRule_synpred4_VhdlAntlr_fragment();
		EnterRule("synpred4_VhdlAntlr_fragment", 221);
		TraceIn("synpred4_VhdlAntlr_fragment", 221);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:541:9: ( target LE )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:541:10: target LE
			{
			DebugLocation(541, 10);
			PushFollow(Follow._target_in_synpred4_VhdlAntlr5585);
			target();
			PopFollow();
			if (state.failed) return;
			DebugLocation(541, 17);
			Match(input,LE,Follow._LE_in_synpred4_VhdlAntlr5587); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_VhdlAntlr_fragment", 221);
			LeaveRule("synpred4_VhdlAntlr_fragment", 221);
			LeaveRule_synpred4_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred4_VhdlAntlr

	partial void EnterRule_synpred5_VhdlAntlr_fragment();
	partial void LeaveRule_synpred5_VhdlAntlr_fragment();

	// $ANTLR start synpred5_VhdlAntlr
	public void synpred5_VhdlAntlr_fragment()
	{
		EnterRule_synpred5_VhdlAntlr_fragment();
		EnterRule("synpred5_VhdlAntlr_fragment", 222);
		TraceIn("synpred5_VhdlAntlr_fragment", 222);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:542:9: ( concurrent_procedure_call_statement )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:542:10: concurrent_procedure_call_statement
			{
			DebugLocation(542, 10);
			PushFollow(Follow._concurrent_procedure_call_statement_in_synpred5_VhdlAntlr5602);
			concurrent_procedure_call_statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_VhdlAntlr_fragment", 222);
			LeaveRule("synpred5_VhdlAntlr_fragment", 222);
			LeaveRule_synpred5_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred5_VhdlAntlr

	partial void EnterRule_synpred6_VhdlAntlr_fragment();
	partial void LeaveRule_synpred6_VhdlAntlr_fragment();

	// $ANTLR start synpred6_VhdlAntlr
	public void synpred6_VhdlAntlr_fragment()
	{
		EnterRule_synpred6_VhdlAntlr_fragment();
		EnterRule("synpred6_VhdlAntlr_fragment", 223);
		TraceIn("synpred6_VhdlAntlr_fragment", 223);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:659:9: ( simple_expression direction )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:659:10: simple_expression direction
			{
			DebugLocation(659, 10);
			PushFollow(Follow._simple_expression_in_synpred6_VhdlAntlr6556);
			simple_expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(659, 28);
			PushFollow(Follow._direction_in_synpred6_VhdlAntlr6558);
			direction();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_VhdlAntlr_fragment", 223);
			LeaveRule("synpred6_VhdlAntlr_fragment", 223);
			LeaveRule_synpred6_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred6_VhdlAntlr

	partial void EnterRule_synpred7_VhdlAntlr_fragment();
	partial void LeaveRule_synpred7_VhdlAntlr_fragment();

	// $ANTLR start synpred7_VhdlAntlr
	public void synpred7_VhdlAntlr_fragment()
	{
		EnterRule_synpred7_VhdlAntlr_fragment();
		EnterRule("synpred7_VhdlAntlr_fragment", 224);
		TraceIn("synpred7_VhdlAntlr_fragment", 224);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:11: ( choices ARROW )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:666:12: choices ARROW
			{
			DebugLocation(666, 12);
			PushFollow(Follow._choices_in_synpred7_VhdlAntlr6645);
			choices();
			PopFollow();
			if (state.failed) return;
			DebugLocation(666, 20);
			Match(input,ARROW,Follow._ARROW_in_synpred7_VhdlAntlr6647); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_VhdlAntlr_fragment", 224);
			LeaveRule("synpred7_VhdlAntlr_fragment", 224);
			LeaveRule_synpred7_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred7_VhdlAntlr

	partial void EnterRule_synpred8_VhdlAntlr_fragment();
	partial void LeaveRule_synpred8_VhdlAntlr_fragment();

	// $ANTLR start synpred8_VhdlAntlr
	public void synpred8_VhdlAntlr_fragment()
	{
		EnterRule_synpred8_VhdlAntlr_fragment();
		EnterRule("synpred8_VhdlAntlr_fragment", 225);
		TraceIn("synpred8_VhdlAntlr_fragment", 225);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:23: ( name_part )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1100:24: name_part
			{
			DebugLocation(1100, 24);
			PushFollow(Follow._name_part_in_synpred8_VhdlAntlr10628);
			name_part();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_VhdlAntlr_fragment", 225);
			LeaveRule("synpred8_VhdlAntlr_fragment", 225);
			LeaveRule_synpred8_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred8_VhdlAntlr

	partial void EnterRule_synpred9_VhdlAntlr_fragment();
	partial void LeaveRule_synpred9_VhdlAntlr_fragment();

	// $ANTLR start synpred9_VhdlAntlr
	public void synpred9_VhdlAntlr_fragment()
	{
		EnterRule_synpred9_VhdlAntlr_fragment();
		EnterRule("synpred9_VhdlAntlr_fragment", 226);
		TraceIn("synpred9_VhdlAntlr_fragment", 226);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1116:9: ( LPAREN name ( constraint )? RPAREN )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1116:10: LPAREN name ( constraint )? RPAREN
			{
			DebugLocation(1116, 10);
			Match(input,LPAREN,Follow._LPAREN_in_synpred9_VhdlAntlr10772); if (state.failed) return;
			DebugLocation(1116, 17);
			PushFollow(Follow._name_in_synpred9_VhdlAntlr10774);
			name();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1116, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1116:22: ( constraint )?
			int alt253=2;
			try { DebugEnterSubRule(253);
			try { DebugEnterDecision(253, false);
			int LA253_0 = input.LA(1);

			if ((LA253_0==LPAREN||LA253_0==RANGETOK))
			{
				alt253 = 1;
			}
			} finally { DebugExitDecision(253); }
			switch (alt253)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1116:22: constraint
				{
				DebugLocation(1116, 22);
				PushFollow(Follow._constraint_in_synpred9_VhdlAntlr10776);
				constraint();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(253); }

			DebugLocation(1116, 34);
			Match(input,RPAREN,Follow._RPAREN_in_synpred9_VhdlAntlr10779); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_VhdlAntlr_fragment", 226);
			LeaveRule("synpred9_VhdlAntlr_fragment", 226);
			LeaveRule_synpred9_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred9_VhdlAntlr

	partial void EnterRule_synpred10_VhdlAntlr_fragment();
	partial void LeaveRule_synpred10_VhdlAntlr_fragment();

	// $ANTLR start synpred10_VhdlAntlr
	public void synpred10_VhdlAntlr_fragment()
	{
		EnterRule_synpred10_VhdlAntlr_fragment();
		EnterRule("synpred10_VhdlAntlr_fragment", 227);
		TraceIn("synpred10_VhdlAntlr_fragment", 227);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1138:9: ( LPAREN name ( constraint )? RPAREN )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1138:10: LPAREN name ( constraint )? RPAREN
			{
			DebugLocation(1138, 10);
			Match(input,LPAREN,Follow._LPAREN_in_synpred10_VhdlAntlr11095); if (state.failed) return;
			DebugLocation(1138, 17);
			PushFollow(Follow._name_in_synpred10_VhdlAntlr11097);
			name();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1138, 22);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1138:22: ( constraint )?
			int alt254=2;
			try { DebugEnterSubRule(254);
			try { DebugEnterDecision(254, false);
			int LA254_0 = input.LA(1);

			if ((LA254_0==LPAREN||LA254_0==RANGETOK))
			{
				alt254 = 1;
			}
			} finally { DebugExitDecision(254); }
			switch (alt254)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1138:22: constraint
				{
				DebugLocation(1138, 22);
				PushFollow(Follow._constraint_in_synpred10_VhdlAntlr11099);
				constraint();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(254); }

			DebugLocation(1138, 34);
			Match(input,RPAREN,Follow._RPAREN_in_synpred10_VhdlAntlr11102); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_VhdlAntlr_fragment", 227);
			LeaveRule("synpred10_VhdlAntlr_fragment", 227);
			LeaveRule_synpred10_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred10_VhdlAntlr

	partial void EnterRule_synpred11_VhdlAntlr_fragment();
	partial void LeaveRule_synpred11_VhdlAntlr_fragment();

	// $ANTLR start synpred11_VhdlAntlr
	public void synpred11_VhdlAntlr_fragment()
	{
		EnterRule_synpred11_VhdlAntlr_fragment();
		EnterRule("synpred11_VhdlAntlr_fragment", 228);
		TraceIn("synpred11_VhdlAntlr_fragment", 228);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1149:17: ( expression direction )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1149:18: expression direction
			{
			DebugLocation(1149, 18);
			PushFollow(Follow._expression_in_synpred11_VhdlAntlr11277);
			expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1149, 29);
			PushFollow(Follow._direction_in_synpred11_VhdlAntlr11279);
			direction();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_VhdlAntlr_fragment", 228);
			LeaveRule("synpred11_VhdlAntlr_fragment", 228);
			LeaveRule_synpred11_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred11_VhdlAntlr

	partial void EnterRule_synpred12_VhdlAntlr_fragment();
	partial void LeaveRule_synpred12_VhdlAntlr_fragment();

	// $ANTLR start synpred12_VhdlAntlr
	public void synpred12_VhdlAntlr_fragment()
	{
		EnterRule_synpred12_VhdlAntlr_fragment();
		EnterRule("synpred12_VhdlAntlr_fragment", 229);
		TraceIn("synpred12_VhdlAntlr_fragment", 229);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1175:11: ( LPAREN expression RPAREN )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1175:12: LPAREN expression RPAREN
			{
			DebugLocation(1175, 12);
			Match(input,LPAREN,Follow._LPAREN_in_synpred12_VhdlAntlr11527); if (state.failed) return;
			DebugLocation(1175, 19);
			PushFollow(Follow._expression_in_synpred12_VhdlAntlr11529);
			expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1175, 30);
			Match(input,RPAREN,Follow._RPAREN_in_synpred12_VhdlAntlr11531); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_VhdlAntlr_fragment", 229);
			LeaveRule("synpred12_VhdlAntlr_fragment", 229);
			LeaveRule_synpred12_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred12_VhdlAntlr

	partial void EnterRule_synpred13_VhdlAntlr_fragment();
	partial void LeaveRule_synpred13_VhdlAntlr_fragment();

	// $ANTLR start synpred13_VhdlAntlr
	public void synpred13_VhdlAntlr_fragment()
	{
		EnterRule_synpred13_VhdlAntlr_fragment();
		EnterRule("synpred13_VhdlAntlr_fragment", 230);
		TraceIn("synpred13_VhdlAntlr_fragment", 230);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1400:9: ( simple_expression direction )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1400:10: simple_expression direction
			{
			DebugLocation(1400, 10);
			PushFollow(Follow._simple_expression_in_synpred13_VhdlAntlr13286);
			simple_expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1400, 28);
			PushFollow(Follow._direction_in_synpred13_VhdlAntlr13288);
			direction();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_VhdlAntlr_fragment", 230);
			LeaveRule("synpred13_VhdlAntlr_fragment", 230);
			LeaveRule_synpred13_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred13_VhdlAntlr

	partial void EnterRule_synpred14_VhdlAntlr_fragment();
	partial void LeaveRule_synpred14_VhdlAntlr_fragment();

	// $ANTLR start synpred14_VhdlAntlr
	public void synpred14_VhdlAntlr_fragment()
	{
		EnterRule_synpred14_VhdlAntlr_fragment();
		EnterRule("synpred14_VhdlAntlr_fragment", 231);
		TraceIn("synpred14_VhdlAntlr_fragment", 231);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1442:9: ( range_constraint UNITS )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1442:10: range_constraint UNITS
			{
			DebugLocation(1442, 10);
			PushFollow(Follow._range_constraint_in_synpred14_VhdlAntlr13643);
			range_constraint();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1442, 27);
			Match(input,UNITS,Follow._UNITS_in_synpred14_VhdlAntlr13645); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_VhdlAntlr_fragment", 231);
			LeaveRule("synpred14_VhdlAntlr_fragment", 231);
			LeaveRule_synpred14_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred14_VhdlAntlr

	partial void EnterRule_synpred15_VhdlAntlr_fragment();
	partial void LeaveRule_synpred15_VhdlAntlr_fragment();

	// $ANTLR start synpred15_VhdlAntlr
	public void synpred15_VhdlAntlr_fragment()
	{
		EnterRule_synpred15_VhdlAntlr_fragment();
		EnterRule("synpred15_VhdlAntlr_fragment", 232);
		TraceIn("synpred15_VhdlAntlr_fragment", 232);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1497:9: ( target LE )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1497:10: target LE
			{
			DebugLocation(1497, 10);
			PushFollow(Follow._target_in_synpred15_VhdlAntlr14090);
			target();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1497, 17);
			Match(input,LE,Follow._LE_in_synpred15_VhdlAntlr14092); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_VhdlAntlr_fragment", 232);
			LeaveRule("synpred15_VhdlAntlr_fragment", 232);
			LeaveRule_synpred15_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred15_VhdlAntlr

	partial void EnterRule_synpred16_VhdlAntlr_fragment();
	partial void LeaveRule_synpred16_VhdlAntlr_fragment();

	// $ANTLR start synpred16_VhdlAntlr
	public void synpred16_VhdlAntlr_fragment()
	{
		EnterRule_synpred16_VhdlAntlr_fragment();
		EnterRule("synpred16_VhdlAntlr_fragment", 233);
		TraceIn("synpred16_VhdlAntlr_fragment", 233);
		try
		{
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1498:9: ( target VARASGN )
			DebugEnterAlt(1);
			// D:\\CurrentProjects\\Compiler\\VHDL\\vhdl_grammar\\VhdlAntlr.g:1498:10: target VARASGN
			{
			DebugLocation(1498, 10);
			PushFollow(Follow._target_in_synpred16_VhdlAntlr14107);
			target();
			PopFollow();
			if (state.failed) return;
			DebugLocation(1498, 17);
			Match(input,VARASGN,Follow._VARASGN_in_synpred16_VhdlAntlr14109); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_VhdlAntlr_fragment", 233);
			LeaveRule("synpred16_VhdlAntlr_fragment", 233);
			LeaveRule_synpred16_VhdlAntlr_fragment();
		}
	}
	// $ANTLR end synpred16_VhdlAntlr
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _ACCESS_in_access_type_definition2954 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_access_type_definition2956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_actual_part2999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_actual_part3009 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_aggregate3069 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _element_association_in_aggregate3071 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _COMMA_in_aggregate3075 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _element_association_in_aggregate3077 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_aggregate3082 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALIAS_in_alias_declaration3120 = new BitSet(new ulong[]{0x8001000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _alias_designator_in_alias_declaration3122 = new BitSet(new ulong[]{0x20000000000UL,0x20000000000UL});
		public static readonly BitSet _COLON_in_alias_declaration3126 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_alias_declaration3128 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_alias_declaration3133 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_alias_declaration3135 = new BitSet(new ulong[]{0x0UL,0x100000000000UL,0x100000000000UL});
		public static readonly BitSet _signature_in_alias_declaration3137 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_alias_declaration3140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_alias_designator3185 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_alias_designator3195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_alias_designator3207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_allocator3228 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_allocator3232 = new BitSet(new ulong[]{0x1001002UL,0x20000000000400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_allocator3262 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _index_constraint_in_allocator3265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qualified_expression_in_allocator3341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARCHITECTURE_in_architecture_body3407 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_architecture_body3409 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_architecture_body3411 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_architecture_body3415 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_architecture_body3417 = new BitSet(new ulong[]{0x210100002040100UL,0x20414800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _architecture_declarative_part_in_architecture_body3429 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _BEGIN_in_architecture_body3440 = new BitSet(new ulong[]{0x1010000UL,0x20000000000402UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _architecture_statement_part_in_architecture_body3452 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_architecture_body3463 = new BitSet(new ulong[]{0x1002000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _ARCHITECTURE_in_architecture_body3465 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_architecture_body3468 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_architecture_body3471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_declarative_item_in_architecture_declarative_part3518 = new BitSet(new ulong[]{0x210100000040102UL,0x20414800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _concurrent_statement_in_architecture_statement_part3532 = new BitSet(new ulong[]{0x1010002UL,0x20000000000400UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _ARRAY_in_array_type_definition3550 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _unconstrained_array_definition_in_array_type_definition3586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constrained_array_definition_in_array_type_definition3604 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSERT_in_assertion3633 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_assertion3635 = new BitSet(new ulong[]{0x2UL,0x0UL,0x201000000000UL});
		public static readonly BitSet _REPORT_in_assertion3639 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_assertion3643 = new BitSet(new ulong[]{0x2UL,0x0UL,0x200000000000UL});
		public static readonly BitSet _SEVERITY_in_assertion3650 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_assertion3654 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_assertion_statement3716 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_assertion_statement3718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_part_in_association_element3758 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ARROW_in_association_element3760 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _actual_part_in_association_element3765 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _association_element_in_association_list3799 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_association_list3803 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _association_element_in_association_list3805 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _ATTRIBUTE_in_attribute_declaration3846 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_attribute_declaration3848 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_attribute_declaration3850 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_attribute_declaration3854 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_attribute_declaration3856 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_attribute_designator3899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RANGETOK_in_attribute_designator3909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ATTRIBUTE_in_attribute_specification3933 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x20000000UL});
		public static readonly BitSet _attribute_designator_in_attribute_specification3935 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_attribute_specification3937 = new BitSet(new ulong[]{0x8001000200UL,0x400UL,0x200000000002000UL});
		public static readonly BitSet _entity_specification_in_attribute_specification3939 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_attribute_specification3941 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_attribute_specification3943 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_attribute_specification3945 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_binding_indication3988 = new BitSet(new ulong[]{0x4000000000000UL,0x4UL,0x800UL});
		public static readonly BitSet _entity_aspect_in_binding_indication3990 = new BitSet(new ulong[]{0x2UL,0x80000UL,0x200000UL});
		public static readonly BitSet _generic_map_aspect_in_binding_indication3995 = new BitSet(new ulong[]{0x2UL,0x0UL,0x200000UL});
		public static readonly BitSet _port_map_aspect_in_binding_indication3998 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_block_configuration4037 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _block_specification_in_block_configuration4039 = new BitSet(new ulong[]{0x0UL,0x4002UL,0x0UL,0x100UL});
		public static readonly BitSet _use_clause_in_block_configuration4049 = new BitSet(new ulong[]{0x0UL,0x4002UL,0x0UL,0x100UL});
		public static readonly BitSet _configuration_item_in_block_configuration4060 = new BitSet(new ulong[]{0x0UL,0x4002UL});
		public static readonly BitSet _END_in_block_configuration4071 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _FOR_in_block_configuration4073 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_block_configuration4075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_body_or_declaration_in_block_declarative_item4118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_block_declarative_item4128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_block_declarative_item4138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_block_declarative_item4148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signal_declaration_in_block_declarative_item4158 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_block_declarative_item4170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_block_declarative_item4180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_block_declarative_item4190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _component_declaration_in_block_declarative_item4200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_declaration_in_block_declarative_item4210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_block_declarative_item4220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _configuration_specification_in_block_declarative_item4230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _disconnection_specification_in_block_declarative_item4240 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_block_declarative_item4250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_block_declarative_item4260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_block_declarative_item4270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_declarative_item_in_block_declarative_part4289 = new BitSet(new ulong[]{0x210100000040102UL,0x20414800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _generic_clause_in_block_header4311 = new BitSet(new ulong[]{0x2UL,0x80000UL,0x200000UL});
		public static readonly BitSet _generic_map_aspect_in_block_header4315 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_block_header4317 = new BitSet(new ulong[]{0x2UL,0x0UL,0x200000UL});
		public static readonly BitSet _port_clause_in_block_header4335 = new BitSet(new ulong[]{0x2UL,0x0UL,0x200000UL});
		public static readonly BitSet _port_map_aspect_in_block_header4339 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_block_header4341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_block_specification4396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_block_statement4416 = new BitSet(new ulong[]{0x210100002040100UL,0x20020020494800UL,0x1000C00009200000UL,0x502UL});
		public static readonly BitSet _LPAREN_in_block_statement4420 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_block_statement4424 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_block_statement4426 = new BitSet(new ulong[]{0x210100002040100UL,0x20020494800UL,0x1000C00009200000UL,0x502UL});
		public static readonly BitSet _IS_in_block_statement4431 = new BitSet(new ulong[]{0x210100002040100UL,0x20494800UL,0x1000C00009200000UL,0x502UL});
		public static readonly BitSet _block_header_in_block_statement4442 = new BitSet(new ulong[]{0x210100002040100UL,0x20414800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _block_declarative_part_in_block_statement4454 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _BEGIN_in_block_statement4465 = new BitSet(new ulong[]{0x1010000UL,0x20000000000402UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _block_statement_part_in_block_statement4477 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_block_statement4488 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _BLOCK_in_block_statement4490 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_block_statement4492 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_block_statement4495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_statement_in_block_statement_part4551 = new BitSet(new ulong[]{0x1010002UL,0x20000000000400UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _CASE_in_case_statement4571 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_case_statement4573 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_case_statement4575 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x8000UL});
		public static readonly BitSet _case_statement_alternative_in_case_statement4585 = new BitSet(new ulong[]{0x0UL,0x2UL,0x0UL,0x8000UL});
		public static readonly BitSet _END_in_case_statement4596 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _CASE_in_case_statement4598 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_case_statement4600 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_case_statement4603 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_case_statement_alternative4647 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _choices_in_case_statement_alternative4649 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ARROW_in_case_statement_alternative4651 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequence_of_statements_in_case_statement_alternative4653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression_in_choice4687 = new BitSet(new ulong[]{0x4000000000000002UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_choice4716 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _simple_expression_in_choice4718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OTHERS_in_choice4803 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _choice_in_choices4824 = new BitSet(new ulong[]{0x400002UL,0x40UL});
		public static readonly BitSet _BAR_in_choices4830 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _EXCLAMATION_in_choices4834 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _choice_in_choices4838 = new BitSet(new ulong[]{0x400002UL,0x40UL});
		public static readonly BitSet _FOR_in_component_configuration4879 = new BitSet(new ulong[]{0x1000200UL,0x400UL,0x2000UL});
		public static readonly BitSet _component_specification_in_component_configuration4883 = new BitSet(new ulong[]{0x0UL,0x84002UL,0x100000200000UL,0x100UL});
		public static readonly BitSet _binding_indication_in_component_configuration4897 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_component_configuration4899 = new BitSet(new ulong[]{0x0UL,0x4002UL});
		public static readonly BitSet _block_configuration_in_component_configuration4914 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_component_configuration4925 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _FOR_in_component_configuration4927 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_component_configuration4929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMPONENT_in_component_declaration4976 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_component_declaration4978 = new BitSet(new ulong[]{0x0UL,0x20000080002UL,0x200000UL});
		public static readonly BitSet _IS_in_component_declaration4980 = new BitSet(new ulong[]{0x0UL,0x80002UL,0x200000UL});
		public static readonly BitSet _generic_clause_in_component_declaration4993 = new BitSet(new ulong[]{0x0UL,0x2UL,0x200000UL});
		public static readonly BitSet _port_clause_in_component_declaration5006 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_component_declaration5017 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _COMPONENT_in_component_declaration5019 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_component_declaration5021 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_component_declaration5024 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instantiated_unit_in_component_instantiation_statement5077 = new BitSet(new ulong[]{0x0UL,0x80000UL,0x100000200000UL});
		public static readonly BitSet _generic_map_aspect_in_component_instantiation_statement5089 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000200000UL});
		public static readonly BitSet _port_map_aspect_in_component_instantiation_statement5102 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_component_instantiation_statement5105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instantiation_list_in_component_specification5151 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_component_specification5153 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_component_specification5157 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_type_definition_in_composite_type_definition5191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_type_definition_in_composite_type_definition5201 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_in_concurrent_assertion_statement5220 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_concurrent_assertion_statement5222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _procedure_call_in_concurrent_procedure_call_statement5253 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_concurrent_procedure_call_statement5255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_concurrent_statement5301 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_concurrent_statement5303 = new BitSet(new ulong[]{0x4100081010000UL,0x20000010004404UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _concurrent_statement_optional_label_in_concurrent_statement5344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_statement_with_label_in_concurrent_statement5398 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_statement_optional_label_in_concurrent_statement5464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_statement_in_concurrent_statement_with_label5483 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _component_instantiation_statement_in_concurrent_statement_with_label5493 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _generate_statement_in_concurrent_statement_with_label5503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSTPONED_in_concurrent_statement_optional_label5522 = new BitSet(new ulong[]{0x1010000UL,0x20000000000400UL,0x200000004000000UL,0x40000UL});
		public static readonly BitSet _concurrent_statement_optional_label_2_in_concurrent_statement_optional_label5526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_statement_optional_label_2_in_concurrent_statement_optional_label5555 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _process_statement_in_concurrent_statement_optional_label_25574 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditional_signal_assignment_in_concurrent_statement_optional_label_25591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_procedure_call_statement_in_concurrent_statement_optional_label_25606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_assertion_statement_in_concurrent_statement_optional_label_25616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selected_signal_assignment_in_concurrent_statement_optional_label_25626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_condition5647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UNTIL_in_condition_clause5666 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_condition_clause5668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_conditional_signal_assignment5705 = new BitSet(new ulong[]{0x0UL,0x200000000000UL});
		public static readonly BitSet _LE_in_conditional_signal_assignment5707 = new BitSet(new ulong[]{0x80008075000010UL,0x12000020C002400UL,0x2000004001001C8UL,0x5UL});
		public static readonly BitSet _signal_assignment_options_in_conditional_signal_assignment5711 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _conditional_waveforms_in_conditional_signal_assignment5715 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_conditional_signal_assignment5717 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _waveform_in_conditional_waveforms5761 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x8000UL});
		public static readonly BitSet _WHEN_in_conditional_waveforms5765 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_conditional_waveforms5767 = new BitSet(new ulong[]{0x8000000000000002UL});
		public static readonly BitSet _ELSE_in_conditional_waveforms5771 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _conditional_waveforms2_in_conditional_waveforms5773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _waveform_in_conditional_waveforms25822 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x8000UL});
		public static readonly BitSet _WHEN_in_conditional_waveforms25826 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_conditional_waveforms25828 = new BitSet(new ulong[]{0x8000000000000002UL});
		public static readonly BitSet _ELSE_in_conditional_waveforms25832 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _conditional_waveforms2_in_conditional_waveforms25834 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONFIGURATION_in_configuration_declaration5878 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_configuration_declaration5880 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_configuration_declaration5882 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_configuration_declaration5886 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_configuration_declaration5888 = new BitSet(new ulong[]{0x40000UL,0x404000UL,0x0UL,0x100UL});
		public static readonly BitSet _configuration_declarative_part_in_configuration_declaration5900 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _block_configuration_in_configuration_declaration5913 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_configuration_declaration5923 = new BitSet(new ulong[]{0x4000001000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _CONFIGURATION_in_configuration_declaration5925 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_configuration_declaration5928 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_configuration_declaration5931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_configuration_declarative_item5981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_configuration_declarative_item5991 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_configuration_declarative_item6001 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _configuration_declarative_item_in_configuration_declarative_part6020 = new BitSet(new ulong[]{0x40002UL,0x400000UL,0x0UL,0x100UL});
		public static readonly BitSet _block_configuration_in_configuration_item6040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _component_configuration_in_configuration_item6050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_configuration_specification6069 = new BitSet(new ulong[]{0x1000200UL,0x400UL,0x2000UL});
		public static readonly BitSet _component_specification_in_configuration_specification6071 = new BitSet(new ulong[]{0x0UL,0x80000UL,0x100000200000UL,0x100UL});
		public static readonly BitSet _binding_indication_in_configuration_specification6073 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_configuration_specification6075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONSTANT_in_constant_declaration6115 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_constant_declaration6117 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_constant_declaration6119 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_constant_declaration6121 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL,0x200UL});
		public static readonly BitSet _VARASGN_in_constant_declaration6125 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_constant_declaration6127 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_constant_declaration6132 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _index_constraint_in_constrained_array_definition6175 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_constrained_array_definition6177 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_constrained_array_definition6181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_constraint_in_constraint6221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _index_constraint_in_constraint6231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _context_item_in_context_clause6250 = new BitSet(new ulong[]{0x2UL,0x1000000000000UL,0x0UL,0x100UL});
		public static readonly BitSet _library_clause_in_context_item6270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_context_item6280 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRANSPORT_in_delay_mechanism6299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REJECT_in_delay_mechanism6350 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_delay_mechanism6352 = new BitSet(new ulong[]{0x0UL,0x200000000UL});
		public static readonly BitSet _INERTIAL_in_delay_mechanism6357 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _design_unit_in_design_file6393 = new BitSet(new ulong[]{0x4000000002000UL,0x1000000000004UL,0x10000UL,0x100UL});
		public static readonly BitSet _EOF_in_design_file6396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _context_clause_in_design_unit6415 = new BitSet(new ulong[]{0x4000000002000UL,0x4UL,0x10000UL});
		public static readonly BitSet _primary_unit_in_design_unit6418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _secondary_unit_in_design_unit6420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_designator6440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_designator6452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DISCONNECT_in_disconnection_specification6500 = new BitSet(new ulong[]{0x1000200UL,0x400UL,0x200000000002000UL});
		public static readonly BitSet _guarded_signal_specification_in_disconnection_specification6502 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _AFTER_in_disconnection_specification6504 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_disconnection_specification6508 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_disconnection_specification6510 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression_in_discrete_range6562 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_discrete_range6564 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _simple_expression_in_discrete_range6566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_without_parens_in_discrete_range6598 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL,0x20000000UL});
		public static readonly BitSet _constraint_in_discrete_range6600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _choices_in_element_association6651 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ARROW_in_element_association6653 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_element_association6658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_list_in_element_declaration6692 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_element_declaration6694 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_element_declaration6698 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_element_declaration6700 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENTITY_in_entity_aspect6734 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_entity_aspect6738 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_entity_aspect6742 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_entity_aspect6746 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_entity_aspect6748 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONFIGURATION_in_entity_aspect6784 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_entity_aspect6788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_entity_aspect6817 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_class_in_entity_class_entry7015 = new BitSet(new ulong[]{0x800000002UL});
		public static readonly BitSet _BOX_in_entity_class_entry7017 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_class_entry_in_entity_class_entry_list7037 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_entity_class_entry_list7041 = new BitSet(new ulong[]{0x14100000002000UL,0x4040000410804UL,0x1000800001010000UL,0x422UL});
		public static readonly BitSet _entity_class_entry_in_entity_class_entry_list7043 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _ENTITY_in_entity_declaration7079 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_entity_declaration7081 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_entity_declaration7083 = new BitSet(new ulong[]{0x210000002040100UL,0x20490802UL,0x1000C00009200000UL,0x502UL});
		public static readonly BitSet _entity_header_in_entity_declaration7093 = new BitSet(new ulong[]{0x210000002040100UL,0x20410802UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _entity_declarative_part_in_entity_declaration7103 = new BitSet(new ulong[]{0x2000000UL,0x2UL});
		public static readonly BitSet _BEGIN_in_entity_declaration7116 = new BitSet(new ulong[]{0x1010000UL,0x402UL,0x200000004800000UL});
		public static readonly BitSet _entity_statement_part_in_entity_declaration7118 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_entity_declaration7132 = new BitSet(new ulong[]{0x1000000UL,0x404UL,0x100000000000UL});
		public static readonly BitSet _ENTITY_in_entity_declaration7134 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_entity_declaration7137 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_entity_declaration7140 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_body_or_declaration_in_entity_declarative_item7189 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_entity_declarative_item7199 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_entity_declarative_item7209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_entity_declarative_item7219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signal_declaration_in_entity_declarative_item7229 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_entity_declarative_item7241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_entity_declarative_item7251 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_entity_declarative_item7261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_declaration_in_entity_declarative_item7271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_entity_declarative_item7281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _disconnection_specification_in_entity_declarative_item7291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_entity_declarative_item7301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_entity_declarative_item7311 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_entity_declarative_item7321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_declarative_item_in_entity_declarative_part7340 = new BitSet(new ulong[]{0x210000000040102UL,0x20410800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _entity_tag_in_entity_designator7360 = new BitSet(new ulong[]{0x2UL,0x100000000000UL});
		public static readonly BitSet _signature_in_entity_designator7362 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _generic_clause_in_entity_header7384 = new BitSet(new ulong[]{0x2UL,0x0UL,0x200000UL});
		public static readonly BitSet _port_clause_in_entity_header7397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_designator_in_entity_name_list7417 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_entity_name_list7421 = new BitSet(new ulong[]{0x8001000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _entity_designator_in_entity_name_list7423 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _OTHERS_in_entity_name_list7449 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALL_in_entity_name_list7459 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_name_list_in_entity_specification7478 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_entity_specification7480 = new BitSet(new ulong[]{0x14100000002000UL,0x4040000410804UL,0x1000800001010000UL,0x422UL});
		public static readonly BitSet _entity_class_in_entity_specification7482 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_entity_statement7517 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_entity_statement7519 = new BitSet(new ulong[]{0x1010000UL,0x400UL,0x200000004800000UL});
		public static readonly BitSet _POSTPONED_in_entity_statement7524 = new BitSet(new ulong[]{0x1010000UL,0x400UL,0x200000004000000UL});
		public static readonly BitSet _entity_statement2_in_entity_statement7527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_assertion_statement_in_entity_statement27570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_procedure_call_statement_in_entity_statement27580 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _process_statement_in_entity_statement27590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_statement_in_entity_statement_part7609 = new BitSet(new ulong[]{0x1010002UL,0x400UL,0x200000004800000UL});
		public static readonly BitSet _identifier_in_entity_tag7631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_entity_tag7641 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_entity_tag7653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_enumeration_literal7672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_enumeration_literal7682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_enumeration_type_definition7701 = new BitSet(new ulong[]{0x8001000000UL,0x400UL});
		public static readonly BitSet _enumeration_literal_in_enumeration_type_definition7703 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _COMMA_in_enumeration_type_definition7707 = new BitSet(new ulong[]{0x8001000000UL,0x400UL});
		public static readonly BitSet _enumeration_literal_in_enumeration_type_definition7709 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_enumeration_type_definition7714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXIT_in_exit_statement7752 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL,0x8000UL});
		public static readonly BitSet _identifier_in_exit_statement7756 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL,0x8000UL});
		public static readonly BitSet _WHEN_in_exit_statement7761 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_exit_statement7763 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_exit_statement7768 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression2_in_expression7810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relation_in_expression27847 = new BitSet(new ulong[]{0x802UL,0x0UL,0x1022UL,0x180000UL});
		public static readonly BitSet _logical_operator_in_expression27851 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _relation_in_expression27854 = new BitSet(new ulong[]{0x802UL,0x0UL,0x1022UL,0x180000UL});
		public static readonly BitSet _primary_in_factor7876 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _DOUBLESTAR_in_factor7880 = new BitSet(new ulong[]{0x80008075000000UL,0x20000008002400UL,0x200000000000188UL});
		public static readonly BitSet _primary_in_factor7883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ABS_in_factor7896 = new BitSet(new ulong[]{0x80008075000000UL,0x20000008002400UL,0x200000000000188UL});
		public static readonly BitSet _primary_in_factor7898 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_factor7926 = new BitSet(new ulong[]{0x80008075000000UL,0x20000008002400UL,0x200000000000188UL});
		public static readonly BitSet _primary_in_factor7928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILE_in_file_declaration7965 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_file_declaration7967 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_file_declaration7969 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_file_declaration7971 = new BitSet(new ulong[]{0x0UL,0x20000000000UL,0x100000000800UL});
		public static readonly BitSet _file_open_information_in_file_declaration7973 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_file_declaration7976 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_file_logical_name8020 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_file_open_information8041 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_file_open_information8045 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_file_open_information8050 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _file_logical_name_in_file_open_information8052 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILE_in_file_type_definition8092 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_file_type_definition8094 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_file_type_definition8098 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_formal_part8143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_full_type_declaration8162 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_full_type_declaration8164 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_full_type_declaration8166 = new BitSet(new ulong[]{0x4020UL,0x20000000000800UL,0xA0000000UL});
		public static readonly BitSet _type_definition_in_full_type_declaration8168 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_full_type_declaration8170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _generation_scheme_in_generate_statement8210 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _GENERATE_in_generate_statement8220 = new BitSet(new ulong[]{0x210100003050100UL,0x20000020414C02UL,0x1200C0000D800000UL,0x40502UL});
		public static readonly BitSet _block_declarative_item_in_generate_statement8232 = new BitSet(new ulong[]{0x210100002040100UL,0x20414800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _BEGIN_in_generate_statement8235 = new BitSet(new ulong[]{0x1010000UL,0x20000000000402UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _concurrent_statement_in_generate_statement8248 = new BitSet(new ulong[]{0x1010000UL,0x20000000000402UL,0x200000004800000UL,0x40000UL});
		public static readonly BitSet _END_in_generate_statement8259 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _GENERATE_in_generate_statement8261 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_generate_statement8263 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_generate_statement8266 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_generation_scheme8312 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _parameter_specification_in_generation_scheme8316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_generation_scheme8326 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_generation_scheme8328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GENERIC_in_generic_clause8347 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_generic_clause8349 = new BitSet(new ulong[]{0x10000001000000UL,0x400UL});
		public static readonly BitSet _generic_interface_list_in_generic_clause8351 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_generic_clause8353 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_generic_clause8355 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_constant_declaration_optional_class_in_generic_interface_list8392 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_generic_interface_list8404 = new BitSet(new ulong[]{0x10000001000000UL,0x400UL});
		public static readonly BitSet _interface_constant_declaration_optional_class_in_generic_interface_list8406 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _GENERIC_in_generic_map_aspect8441 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _MAP_in_generic_map_aspect8443 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_generic_map_aspect8445 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _association_list_in_generic_map_aspect8449 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_generic_map_aspect8451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_group_constituent8489 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_group_constituent8499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_constituent_in_group_constituent_list8518 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_group_constituent_list8522 = new BitSet(new ulong[]{0x8001000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _group_constituent_in_group_constituent_list8524 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _GROUP_in_group_declaration8558 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_group_declaration8560 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_group_declaration8562 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_group_declaration8566 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_group_declaration8576 = new BitSet(new ulong[]{0x8001000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _group_constituent_list_in_group_declaration8578 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_group_declaration8580 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_group_declaration8582 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GROUP_in_group_template_declaration8624 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_group_template_declaration8626 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_group_template_declaration8628 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_group_template_declaration8630 = new BitSet(new ulong[]{0x14100000002000UL,0x4040000410804UL,0x1000800001010000UL,0x422UL});
		public static readonly BitSet _entity_class_entry_list_in_group_template_declaration8632 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_group_template_declaration8634 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_group_template_declaration8636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signal_list_in_guarded_signal_specification8677 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_guarded_signal_specification8679 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_guarded_signal_specification8683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_end_identifier8741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_identifier_list8755 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_identifier_list8759 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_identifier_list8761 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _IF_in_if_statement8797 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_if_statement8799 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4000000000000000UL});
		public static readonly BitSet _THEN_in_if_statement8801 = new BitSet(new ulong[]{0x8000004001010000UL,0x28000010004483UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequence_of_statements_in_if_statement8813 = new BitSet(new ulong[]{0x8000000000000000UL,0x3UL});
		public static readonly BitSet _if_statement_elsif_part_in_if_statement8823 = new BitSet(new ulong[]{0x8000000000000000UL,0x3UL});
		public static readonly BitSet _if_statement_else_part_in_if_statement8836 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_if_statement8847 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _IF_in_if_statement8849 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_if_statement8851 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_if_statement8854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSIF_in_if_statement_elsif_part8905 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_if_statement_elsif_part8907 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4000000000000000UL});
		public static readonly BitSet _THEN_in_if_statement_elsif_part8909 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequence_of_statements_in_if_statement_elsif_part8911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_if_statement_else_part8951 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequence_of_statements_in_if_statement_else_part8953 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_incomplete_type_declaration8991 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_incomplete_type_declaration8993 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_incomplete_type_declaration8995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_index_constraint9032 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _discrete_range_in_index_constraint9034 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _COMMA_in_index_constraint9038 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _discrete_range_in_index_constraint9040 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_index_constraint9045 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_index_subtype_definition9085 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000UL});
		public static readonly BitSet _RANGETOK_in_index_subtype_definition9087 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _BOX_in_index_subtype_definition9089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMPONENT_in_instantiated_unit9121 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_instantiated_unit9126 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENTITY_in_instantiated_unit9158 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_instantiated_unit9162 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_instantiated_unit9166 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_instantiated_unit9170 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_instantiated_unit9172 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONFIGURATION_in_instantiated_unit9208 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_without_parens_in_instantiated_unit9212 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_instantiation_list9252 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_instantiation_list9256 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_instantiation_list9260 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _OTHERS_in_instantiation_list9292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALL_in_instantiation_list9302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_constraint_in_integer_or_floating_type_definition9323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_list_in_interface_ambigous_declaration_procedure9360 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_ambigous_declaration_procedure9362 = new BitSet(new ulong[]{0x1000000UL,0x440000400UL,0x200000000008000UL});
		public static readonly BitSet _IN_in_interface_ambigous_declaration_procedure9390 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_ambigous_declaration_procedure9395 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_ambigous_declaration_procedure9399 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_ambigous_declaration_procedure9403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OUT_in_interface_ambigous_declaration_procedure9464 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _INOUT_in_interface_ambigous_declaration_procedure9470 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_ambigous_declaration_procedure9476 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_ambigous_declaration_procedure9480 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_ambigous_declaration_procedure9484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONSTANT_in_interface_constant_declaration9553 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_constant_declaration9555 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_constant_declaration9557 = new BitSet(new ulong[]{0x1000000UL,0x40000400UL,0x200000000000000UL});
		public static readonly BitSet _IN_in_interface_constant_declaration9559 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_constant_declaration9562 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_constant_declaration9574 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_constant_declaration9578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONSTANT_in_interface_constant_declaration_optional_class9645 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_constant_declaration_optional_class9648 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_constant_declaration_optional_class9650 = new BitSet(new ulong[]{0x1000000UL,0x40000400UL,0x200000000000000UL});
		public static readonly BitSet _IN_in_interface_constant_declaration_optional_class9652 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_constant_declaration_optional_class9655 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_constant_declaration_optional_class9667 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_constant_declaration_optional_class9671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_constant_declaration_optional_class_in_interface_element_function9739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_signal_declaration_in_interface_element_function9749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_variable_declaration_in_interface_element_function9759 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_file_declaration_in_interface_element_function9769 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_constant_declaration_in_interface_element_procedure9788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_signal_declaration_in_interface_element_procedure9798 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_variable_declaration_in_interface_element_procedure9808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_file_declaration_in_interface_element_procedure9818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_ambigous_declaration_procedure_in_interface_element_procedure9828 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILE_in_interface_file_declaration9847 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_file_declaration9849 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_file_declaration9851 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_file_declaration9853 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SIGNAL_in_interface_signal_declaration9895 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_signal_declaration9897 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_signal_declaration9899 = new BitSet(new ulong[]{0x1001000000UL,0x2000440000400UL,0x200000000008000UL});
		public static readonly BitSet _mode_in_interface_signal_declaration9901 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_signal_declaration9904 = new BitSet(new ulong[]{0x2000000002UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _BUS_in_interface_signal_declaration9906 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_signal_declaration9919 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_signal_declaration9923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SIGNAL_in_interface_signal_declaration_for_port9993 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_signal_declaration_for_port9996 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_signal_declaration_for_port9998 = new BitSet(new ulong[]{0x1001000000UL,0x2000440000400UL,0x200000000008000UL});
		public static readonly BitSet _mode_in_interface_signal_declaration_for_port10000 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_signal_declaration_for_port10003 = new BitSet(new ulong[]{0x2000000002UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _BUS_in_interface_signal_declaration_for_port10005 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_signal_declaration_for_port10018 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_signal_declaration_for_port10022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VARIABLE_in_interface_variable_declaration10094 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_interface_variable_declaration10096 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_interface_variable_declaration10098 = new BitSet(new ulong[]{0x1001000000UL,0x2000440000400UL,0x200000000008000UL});
		public static readonly BitSet _mode_in_interface_variable_declaration10100 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_interface_variable_declaration10103 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_interface_variable_declaration10115 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_interface_variable_declaration10119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_iteration_scheme10186 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_iteration_scheme10188 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_iteration_scheme10216 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _parameter_specification_in_iteration_scheme10220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIBRARY_in_library_clause10279 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _logical_name_list_in_library_clause10281 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_library_clause10283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_logical_name_list10322 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_logical_name_list10326 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_logical_name_list10330 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _iteration_scheme_in_loop_statement10435 = new BitSet(new ulong[]{0x0UL,0x8000000000000UL});
		public static readonly BitSet _LOOP_in_loop_statement10445 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004482UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequence_of_statements_in_loop_statement10455 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_loop_statement10465 = new BitSet(new ulong[]{0x0UL,0x8000000000000UL});
		public static readonly BitSet _LOOP_in_loop_statement10467 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_loop_statement10469 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_loop_statement10472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_prefix_in_name10623 = new BitSet(new ulong[]{0x1000000000001002UL,0x20100000000000UL});
		public static readonly BitSet _name_part_in_name10632 = new BitSet(new ulong[]{0x1000000000001002UL,0x20100000000000UL});
		public static readonly BitSet _name_prefix_in_name_with_association10675 = new BitSet(new ulong[]{0x1000000000001002UL,0x20100000000000UL});
		public static readonly BitSet _name_with_association_part_in_name_with_association10677 = new BitSet(new ulong[]{0x1000000000001002UL,0x20100000000000UL});
		public static readonly BitSet _name_prefix_in_name_without_parens10718 = new BitSet(new ulong[]{0x1000000000001002UL,0x100000000000UL});
		public static readonly BitSet _name_without_parens_part_in_name_without_parens10720 = new BitSet(new ulong[]{0x1000000000001002UL,0x100000000000UL});
		public static readonly BitSet _name_selected_part_in_name_part10761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_name_part10791 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_name_part10793 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL,0x20020000000UL});
		public static readonly BitSet _constraint_in_name_part10821 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_name_part10915 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_name_part10925 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_name_part10927 = new BitSet(new ulong[]{0x4000040000000000UL,0x0UL,0x8000020000000000UL});
		public static readonly BitSet _direction_in_name_part10955 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_name_part10957 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _COMMA_in_name_part11011 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_name_part11013 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_name_part11059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_attribute_part_in_name_part11069 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_selected_part_in_name_with_association_part11084 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_name_with_association_part11114 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_name_with_association_part11116 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL,0x20020000000UL});
		public static readonly BitSet _constraint_in_name_with_association_part11144 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_name_with_association_part11238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_name_with_association_part11248 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _expression_in_name_with_association_part11283 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_name_with_association_part11285 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_name_with_association_part11287 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _association_list_in_name_with_association_part11339 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_name_with_association_part11379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_attribute_part_in_name_with_association_part11389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_selected_part_in_name_without_parens_part11408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_attribute_part_in_name_without_parens_part11418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_name_prefix11439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_name_prefix11451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_name_selected_part11470 = new BitSet(new ulong[]{0x8001000200UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _suffix_in_name_selected_part11472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signature_in_name_attribute_part11509 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _APOSTROPHE_in_name_attribute_part11512 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x20000000UL});
		public static readonly BitSet _attribute_designator_in_name_attribute_part11514 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_name_attribute_part11535 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_name_attribute_part11537 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_name_attribute_part11539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEXT_in_next_statement11585 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL,0x8000UL});
		public static readonly BitSet _identifier_in_next_statement11589 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL,0x8000UL});
		public static readonly BitSet _WHEN_in_next_statement11594 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _condition_in_next_statement11596 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_next_statement11601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULLTOK_in_null_statement11643 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_null_statement11645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GUARDED_in_signal_assignment_options11677 = new BitSet(new ulong[]{0x2UL,0x200000000UL,0x400000000UL,0x1UL});
		public static readonly BitSet _delay_mechanism_in_signal_assignment_options11680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PACKAGE_in_package_body11701 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _BODY_in_package_body11703 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_package_body11705 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_package_body11707 = new BitSet(new ulong[]{0x10000000000100UL,0x20410802UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _package_body_declarative_part_in_package_body11717 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_package_body11728 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000010000UL});
		public static readonly BitSet _PACKAGE_in_package_body11732 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _BODY_in_package_body11734 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_package_body11739 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_package_body11742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_body_or_declaration_in_package_body_declarative_item11785 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_package_body_declarative_item11795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_package_body_declarative_item11805 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_package_body_declarative_item11815 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_package_body_declarative_item11827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_package_body_declarative_item11837 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_package_body_declarative_item11847 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_package_body_declarative_item11857 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_package_body_declarative_item11867 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_package_body_declarative_item11877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _package_body_declarative_item_in_package_body_declarative_part11896 = new BitSet(new ulong[]{0x10000000000102UL,0x20410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _PACKAGE_in_package_declaration11917 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_package_declaration11919 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_package_declaration11921 = new BitSet(new ulong[]{0x210100000040100UL,0x20410802UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _package_declarative_part_in_package_declaration11931 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_package_declaration11942 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000010000UL});
		public static readonly BitSet _PACKAGE_in_package_declaration11944 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_package_declaration11947 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_package_declaration11950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_declaration_in_package_declarative_item11993 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_package_declarative_item12003 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_package_declarative_item12013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_package_declarative_item12023 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signal_declaration_in_package_declarative_item12033 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_package_declarative_item12045 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_package_declarative_item12055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_package_declarative_item12065 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _component_declaration_in_package_declarative_item12075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_declaration_in_package_declarative_item12085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_package_declarative_item12095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _disconnection_specification_in_package_declarative_item12105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_package_declarative_item12115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_package_declarative_item12125 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_package_declarative_item12135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _package_declarative_item_in_package_declarative_part12154 = new BitSet(new ulong[]{0x210100000040102UL,0x20410800UL,0x1000C00009000000UL,0x502UL});
		public static readonly BitSet _interface_element_function_in_parameter_interface_list_function12174 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_parameter_interface_list_function12178 = new BitSet(new ulong[]{0x10000001000000UL,0xC00UL,0x800000000000UL,0x400UL});
		public static readonly BitSet _interface_element_function_in_parameter_interface_list_function12180 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _interface_element_procedure_in_parameter_interface_list_procedure12215 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_parameter_interface_list_procedure12219 = new BitSet(new ulong[]{0x10000001000000UL,0xC00UL,0x800000000000UL,0x400UL});
		public static readonly BitSet _interface_element_procedure_in_parameter_interface_list_procedure12221 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _identifier_in_parameter_specification12256 = new BitSet(new ulong[]{0x0UL,0x40000000UL});
		public static readonly BitSet _IN_in_parameter_specification12258 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _discrete_range_in_parameter_specification12260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_constraint_in_physical_type_definition12294 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _UNITS_in_physical_type_definition12296 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_physical_type_definition12308 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_physical_type_definition12310 = new BitSet(new ulong[]{0x1000000UL,0x402UL});
		public static readonly BitSet _secondary_unit_declaration_in_physical_type_definition12320 = new BitSet(new ulong[]{0x1000000UL,0x402UL});
		public static readonly BitSet _END_in_physical_type_definition12331 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _UNITS_in_physical_type_definition12333 = new BitSet(new ulong[]{0x1000002UL,0x400UL});
		public static readonly BitSet _end_identifier_in_physical_type_definition12335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PORT_in_port_clause12401 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_port_clause12403 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x800000000000UL});
		public static readonly BitSet _port_interface_list_in_port_clause12405 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_port_clause12407 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_port_clause12409 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interface_signal_declaration_for_port_in_port_interface_list12446 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_port_interface_list12450 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x800000000000UL});
		public static readonly BitSet _interface_signal_declaration_for_port_in_port_interface_list12452 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _PORT_in_port_map_aspect12487 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _MAP_in_port_map_aspect12489 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_port_map_aspect12491 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _association_list_in_port_map_aspect12495 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_port_map_aspect12497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _abstract_literal_in_primary12563 = new BitSet(new ulong[]{0x1000002UL,0x400UL});
		public static readonly BitSet _identifier_in_primary12575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_POINT_LITERAL_in_primary12623 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_primary12633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIT_STRING_LITERAL_BINARY_in_primary12647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIT_STRING_LITERAL_OCTAL_in_primary12657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIT_STRING_LITERAL_HEX_in_primary12667 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULLTOK_in_primary12677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_primary12687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _allocator_in_primary12697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_with_association_in_primary12709 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _qualified_expression_in_primary12737 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _entity_declaration_in_primary_unit12832 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _configuration_declaration_in_primary_unit12842 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _package_declaration_in_primary_unit12852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_without_parens_in_procedure_call12873 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_procedure_call12877 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001009C8UL});
		public static readonly BitSet _association_list_in_procedure_call12881 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_procedure_call12883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _procedure_call_in_procedure_call_statement12929 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_procedure_call_statement12931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_body_or_declaration_in_process_declarative_item12962 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_process_declarative_item12972 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_process_declarative_item12982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_process_declarative_item12992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_process_declarative_item13002 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_process_declarative_item13012 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_process_declarative_item13022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_declaration_in_process_declarative_item13032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_process_declarative_item13042 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_process_declarative_item13052 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_process_declarative_item13062 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_process_declarative_item13072 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _process_declarative_item_in_process_declarative_part13091 = new BitSet(new ulong[]{0x10000000040102UL,0x20410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _PROCESS_in_process_statement13112 = new BitSet(new ulong[]{0x10000002040100UL,0x20020020410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _LPAREN_in_process_statement13116 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _sensitivity_list_in_process_statement13118 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_process_statement13120 = new BitSet(new ulong[]{0x10000002040100UL,0x20020410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _IS_in_process_statement13125 = new BitSet(new ulong[]{0x10000002040100UL,0x20410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _process_declarative_part_in_process_statement13136 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _BEGIN_in_process_statement13147 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004482UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _process_statement_part_in_process_statement13157 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_process_statement13168 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4800000UL});
		public static readonly BitSet _POSTPONED_in_process_statement13170 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4000000UL});
		public static readonly BitSet _PROCESS_in_process_statement13173 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x100000000000UL});
		public static readonly BitSet _end_identifier_in_process_statement13175 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_process_statement13178 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sequential_statement_in_process_statement_part13230 = new BitSet(new ulong[]{0x4001010002UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _APOSTROPHE_in_qualified_expression13252 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _aggregate_in_qualified_expression13254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression_in_range13292 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_range13294 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _simple_expression_in_range13297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_range13309 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RANGETOK_in_range_constraint13328 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _range_in_range_constraint13330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RECORD_in_record_type_definition13368 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _element_declaration_in_record_type_definition13378 = new BitSet(new ulong[]{0x1000000UL,0x402UL});
		public static readonly BitSet _END_in_record_type_definition13389 = new BitSet(new ulong[]{0x0UL,0x0UL,0x80000000UL});
		public static readonly BitSet _RECORD_in_record_type_definition13391 = new BitSet(new ulong[]{0x1000002UL,0x400UL});
		public static readonly BitSet _identifier_in_record_type_definition13393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_relation13432 = new BitSet(new ulong[]{0x2UL,0x40200002020020UL,0x4UL});
		public static readonly BitSet _relational_operator_in_relation13436 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _shift_expression_in_relation13439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REPORT_in_report_statement13530 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_report_statement13534 = new BitSet(new ulong[]{0x0UL,0x0UL,0x300000000000UL});
		public static readonly BitSet _SEVERITY_in_report_statement13538 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_report_statement13542 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_report_statement13547 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_return_statement13589 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2001000001001C8UL});
		public static readonly BitSet _expression_in_return_statement13591 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_return_statement13594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumeration_type_definition_in_scalar_type_definition13632 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _physical_type_definition_in_scalar_type_definition13649 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _integer_or_floating_type_definition_in_scalar_type_definition13659 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _architecture_body_in_secondary_unit13678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _package_body_in_secondary_unit13688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_secondary_unit_declaration13707 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _EQ_in_secondary_unit_declaration13709 = new BitSet(new ulong[]{0x80000005000000UL,0x8000400UL,0x200000000000100UL});
		public static readonly BitSet _abstract_literal_in_secondary_unit_declaration13711 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_secondary_unit_declaration13716 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_secondary_unit_declaration13718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_selected_signal_assignment13755 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_selected_signal_assignment13757 = new BitSet(new ulong[]{0x0UL,0x0UL,0x40000000000UL});
		public static readonly BitSet _SELECT_in_selected_signal_assignment13759 = new BitSet(new ulong[]{0x1000000UL,0x20000000000400UL,0x200000000000000UL});
		public static readonly BitSet _target_in_selected_signal_assignment13761 = new BitSet(new ulong[]{0x0UL,0x200000000000UL});
		public static readonly BitSet _LE_in_selected_signal_assignment13763 = new BitSet(new ulong[]{0x80008075000010UL,0x12000020C002400UL,0x2000004001001C8UL,0x5UL});
		public static readonly BitSet _signal_assignment_options_in_selected_signal_assignment13767 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _selected_waveforms_in_selected_signal_assignment13771 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_selected_signal_assignment13773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _waveform_in_selected_waveform13819 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x8000UL});
		public static readonly BitSet _WHEN_in_selected_waveform13821 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001021C8UL});
		public static readonly BitSet _choices_in_selected_waveform13823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selected_waveform_in_selected_waveforms13856 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_selected_waveforms13860 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _selected_waveform_in_selected_waveforms13862 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _ON_in_sensitivity_clause13897 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _sensitivity_list_in_sensitivity_clause13899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_sensitivity_list13938 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_sensitivity_list13942 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_sensitivity_list13946 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _sequential_statement_in_sequence_of_statements13981 = new BitSet(new ulong[]{0x4001010002UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _identifier_in_sequential_statement14003 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_sequential_statement14005 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _sequential_statement_2_in_sequential_statement14009 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sequential_statement_2_in_sequential_statement14040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _wait_statement_in_sequential_statement_214059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assertion_statement_in_sequential_statement_214069 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _report_statement_in_sequential_statement_214079 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _signal_assignment_statement_in_sequential_statement_214096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_assignment_statement_in_sequential_statement_214113 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _procedure_call_statement_in_sequential_statement_214123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_statement_in_sequential_statement_214133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _case_statement_in_sequential_statement_214143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loop_statement_in_sequential_statement_214153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _next_statement_in_sequential_statement_214163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exit_statement_in_sequential_statement_214173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_statement_in_sequential_statement_214183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _null_statement_in_sequential_statement_214193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression2_in_shift_expression14212 = new BitSet(new ulong[]{0x2UL,0x0UL,0x198018000000000UL});
		public static readonly BitSet _shift_operator_in_shift_expression14216 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _simple_expression2_in_shift_expression14219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_signal_assignment_statement14339 = new BitSet(new ulong[]{0x0UL,0x200000000000UL});
		public static readonly BitSet _LE_in_signal_assignment_statement14341 = new BitSet(new ulong[]{0x80008075000010UL,0x120000208002400UL,0x2000004001001C8UL,0x5UL});
		public static readonly BitSet _delay_mechanism_in_signal_assignment_statement14343 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL,0x4UL});
		public static readonly BitSet _waveform_in_signal_assignment_statement14346 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_signal_assignment_statement14348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SIGNAL_in_signal_declaration14390 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_signal_declaration14392 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_signal_declaration14394 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_signal_declaration14396 = new BitSet(new ulong[]{0x2000000000UL,0x0UL,0x100200000000UL,0x200UL});
		public static readonly BitSet _signal_kind_in_signal_declaration14398 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL,0x200UL});
		public static readonly BitSet _VARASGN_in_signal_declaration14403 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_signal_declaration14405 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_signal_declaration14410 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_signal_list14486 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_signal_list14490 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_signal_list14494 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _OTHERS_in_signal_list14526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALL_in_signal_list14536 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_signature14555 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200004040000000UL});
		public static readonly BitSet _signature_type_marks_in_signature14557 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4040000000UL});
		public static readonly BitSet _RETURN_in_signature14562 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_signature14566 = new BitSet(new ulong[]{0x0UL,0x0UL,0x40000000UL});
		public static readonly BitSet _RBRACKET_in_signature14571 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_signature_type_marks14619 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_signature_type_marks14623 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_signature_type_marks14625 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _simple_expression2_in_simple_expression14660 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sign_in_simple_expression214697 = new BitSet(new ulong[]{0x80008075000010UL,0x20000008002400UL,0x2000000000001C8UL});
		public static readonly BitSet _term_in_simple_expression214700 = new BitSet(new ulong[]{0x402UL,0x100000000000000UL,0x100000UL});
		public static readonly BitSet _adding_operator_in_simple_expression214704 = new BitSet(new ulong[]{0x80008075000010UL,0x20000008002400UL,0x2000000000001C8UL});
		public static readonly BitSet _term_in_simple_expression214707 = new BitSet(new ulong[]{0x402UL,0x100000000000000UL,0x100000UL});
		public static readonly BitSet _subprogram_specification_in_subprogram_declaration14740 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_subprogram_declaration14742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IS_in_subprogram_body_part14779 = new BitSet(new ulong[]{0x10000002040100UL,0x20410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _subprogram_declarative_part_in_subprogram_body_part14789 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _BEGIN_in_subprogram_body_part14800 = new BitSet(new ulong[]{0x4001010000UL,0x28000010004482UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _subprogram_statement_part_in_subprogram_body_part14810 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _END_in_subprogram_body_part14821 = new BitSet(new ulong[]{0x1000002UL,0x10400UL,0x200000001000000UL});
		public static readonly BitSet _subprogram_kind_in_subprogram_body_part14823 = new BitSet(new ulong[]{0x1000002UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _designator_in_subprogram_body_part14826 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_specification_in_subprogram_body_or_declaration14862 = new BitSet(new ulong[]{0x0UL,0x20000000000UL,0x100000000000UL});
		public static readonly BitSet _subprogram_body_part_in_subprogram_body_or_declaration14890 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_subprogram_body_or_declaration14979 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_body_or_declaration_in_subprogram_declarative_item14998 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_subprogram_declarative_item15008 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subtype_declaration_in_subprogram_declarative_item15018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_declaration_in_subprogram_declarative_item15028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_subprogram_declarative_item15038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_declaration_in_subprogram_declarative_item15048 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_declaration_in_subprogram_declarative_item15058 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_declaration_in_subprogram_declarative_item15068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_specification_in_subprogram_declarative_item15078 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _use_clause_in_subprogram_declarative_item15088 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_template_declaration_in_subprogram_declarative_item15098 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _group_declaration_in_subprogram_declarative_item15108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subprogram_declarative_item_in_subprogram_declarative_part15127 = new BitSet(new ulong[]{0x10000000040102UL,0x20410800UL,0x1000400009000000UL,0x502UL});
		public static readonly BitSet _PROCEDURE_in_subprogram_specification15176 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _designator_in_subprogram_specification15178 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL});
		public static readonly BitSet _LPAREN_in_subprogram_specification15182 = new BitSet(new ulong[]{0x10000001000000UL,0xC00UL,0x800000000000UL,0x400UL});
		public static readonly BitSet _parameter_interface_list_procedure_in_subprogram_specification15184 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_subprogram_specification15186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PURE_in_subprogram_specification15222 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _IMPURE_in_subprogram_specification15226 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _FUNCTION_in_subprogram_specification15231 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _designator_in_subprogram_specification15233 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL,0x4000000000UL});
		public static readonly BitSet _LPAREN_in_subprogram_specification15245 = new BitSet(new ulong[]{0x10000001000000UL,0xC00UL,0x800000000000UL,0x400UL});
		public static readonly BitSet _parameter_interface_list_function_in_subprogram_specification15247 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_subprogram_specification15249 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4000000000UL});
		public static readonly BitSet _RETURN_in_subprogram_specification15254 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_subprogram_specification15258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sequential_statement_in_subprogram_statement_part15307 = new BitSet(new ulong[]{0x4001010002UL,0x28000010004480UL,0x200005000000090UL,0x11000UL});
		public static readonly BitSet _SUBTYPE_in_subtype_declaration15327 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_in_subtype_declaration15329 = new BitSet(new ulong[]{0x0UL,0x20000000000UL});
		public static readonly BitSet _IS_in_subtype_declaration15331 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_subtype_declaration15333 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_subtype_declaration15335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_without_parens_in_subtype_indication15380 = new BitSet(new ulong[]{0x1000002UL,0x20000000000400UL,0x200000020000000UL});
		public static readonly BitSet _name_without_parens_in_subtype_indication15384 = new BitSet(new ulong[]{0x2UL,0x20000000000000UL,0x20000000UL});
		public static readonly BitSet _constraint_in_subtype_indication15387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_suffix15435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARACTER_LITERAL_in_suffix15445 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_suffix15457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALL_in_suffix15467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_target15486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_target15496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _factor_in_term15515 = new BitSet(new ulong[]{0x800000000000002UL,0x600000000000000UL,0x800000000UL});
		public static readonly BitSet _multiplying_operator_in_term15519 = new BitSet(new ulong[]{0x80008075000010UL,0x20000008002400UL,0x2000000000001C8UL});
		public static readonly BitSet _factor_in_term15522 = new BitSet(new ulong[]{0x800000000000002UL,0x600000000000000UL,0x800000000UL});
		public static readonly BitSet _FOR_in_timeout_clause15544 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_timeout_clause15548 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _full_type_declaration_in_type_declaration15585 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _incomplete_type_declaration_in_type_declaration15595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _scalar_type_definition_in_type_definition15614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _composite_type_definition_in_type_definition15624 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _access_type_definition_in_type_definition15634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _file_type_definition_in_type_definition15644 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_unconstrained_array_definition15663 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _index_subtype_definition_in_unconstrained_array_definition15665 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _COMMA_in_unconstrained_array_definition15669 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _index_subtype_definition_in_unconstrained_array_definition15671 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_unconstrained_array_definition15676 = new BitSet(new ulong[]{0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _OF_in_unconstrained_array_definition15686 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_unconstrained_array_definition15690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_use_clause15731 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_use_clause15735 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _COMMA_in_use_clause15739 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_use_clause15743 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_use_clause15748 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_variable_assignment_statement15786 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_variable_assignment_statement15788 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_variable_assignment_statement15790 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_variable_assignment_statement15792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SHARED_in_variable_declaration15831 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x400UL});
		public static readonly BitSet _VARIABLE_in_variable_declaration15834 = new BitSet(new ulong[]{0x1000000UL,0x400UL});
		public static readonly BitSet _identifier_list_in_variable_declaration15836 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _COLON_in_variable_declaration15838 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _subtype_indication_in_variable_declaration15840 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL,0x200UL});
		public static readonly BitSet _VARASGN_in_variable_declaration15844 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_variable_declaration15846 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_variable_declaration15851 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WAIT_in_wait_statement15896 = new BitSet(new ulong[]{0x0UL,0x4000UL,0x100000000400UL,0x40UL});
		public static readonly BitSet _sensitivity_clause_in_wait_statement15898 = new BitSet(new ulong[]{0x0UL,0x4000UL,0x100000000000UL,0x40UL});
		public static readonly BitSet _condition_clause_in_wait_statement15901 = new BitSet(new ulong[]{0x0UL,0x4000UL,0x100000000000UL});
		public static readonly BitSet _timeout_clause_in_wait_statement15904 = new BitSet(new ulong[]{0x0UL,0x0UL,0x100000000000UL});
		public static readonly BitSet _SEMI_in_wait_statement15907 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _waveform_element_in_waveform15951 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _COMMA_in_waveform15955 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _waveform_element_in_waveform15957 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _UNAFFECTED_in_waveform15989 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_waveform_element16008 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _AFTER_in_waveform_element16012 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_waveform_element16014 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_synpred1_VhdlAntlr3580 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _index_subtype_definition_in_synpred1_VhdlAntlr3582 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_part_in_synpred2_VhdlAntlr3752 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ARROW_in_synpred2_VhdlAntlr3754 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_statement_optional_label_in_synpred3_VhdlAntlr5340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_synpred4_VhdlAntlr5585 = new BitSet(new ulong[]{0x0UL,0x200000000000UL});
		public static readonly BitSet _LE_in_synpred4_VhdlAntlr5587 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concurrent_procedure_call_statement_in_synpred5_VhdlAntlr5602 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression_in_synpred6_VhdlAntlr6556 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_synpred6_VhdlAntlr6558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _choices_in_synpred7_VhdlAntlr6645 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ARROW_in_synpred7_VhdlAntlr6647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_part_in_synpred8_VhdlAntlr10628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_synpred9_VhdlAntlr10772 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_synpred9_VhdlAntlr10774 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL,0x20020000000UL});
		public static readonly BitSet _constraint_in_synpred9_VhdlAntlr10776 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_synpred9_VhdlAntlr10779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_synpred10_VhdlAntlr11095 = new BitSet(new ulong[]{0x1000000UL,0x400UL,0x200000000000000UL});
		public static readonly BitSet _name_in_synpred10_VhdlAntlr11097 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL,0x20020000000UL});
		public static readonly BitSet _constraint_in_synpred10_VhdlAntlr11099 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_synpred10_VhdlAntlr11102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_synpred11_VhdlAntlr11277 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_synpred11_VhdlAntlr11279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_synpred12_VhdlAntlr11527 = new BitSet(new ulong[]{0x80008075000010UL,0x120000008002400UL,0x2000000001001C8UL});
		public static readonly BitSet _expression_in_synpred12_VhdlAntlr11529 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _RPAREN_in_synpred12_VhdlAntlr11531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expression_in_synpred13_VhdlAntlr13286 = new BitSet(new ulong[]{0x4000000000000000UL,0x0UL,0x8000000000000000UL});
		public static readonly BitSet _direction_in_synpred13_VhdlAntlr13288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_constraint_in_synpred14_VhdlAntlr13643 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _UNITS_in_synpred14_VhdlAntlr13645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_synpred15_VhdlAntlr14090 = new BitSet(new ulong[]{0x0UL,0x200000000000UL});
		public static readonly BitSet _LE_in_synpred15_VhdlAntlr14092 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _target_in_synpred16_VhdlAntlr14107 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x200UL});
		public static readonly BitSet _VARASGN_in_synpred16_VhdlAntlr14109 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
